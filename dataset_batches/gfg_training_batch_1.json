[
  {
    "code_with_comments": "#include <bits/stdc++.h>\nusing namespace std;\n// An optimized version of Bubble Sort\nvoid bubbleSort(vector<int>& arr) {\n    int n = arr.size();\n    bool swapped;\n    for (int i = 0; i < n - 1; i++) {\n        swapped = false;\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                swap(arr[j], arr[j + 1]);\n                swapped = true;\n            }\n        }\n        // If no two elements were swapped, then break\n        if (!swapped)\n            break;\n    }\n}\n// Function to print a vector\nvoid printVector(const vector<int>& arr) {\n    for (int num : arr)\n        cout << \" \" << num;\n}\nint main() {\n    vector<int> arr = { 64, 34, 25, 12, 22, 11, 90 };\n    bubbleSort(arr);\n    cout << \"Sorted array: \\n\";\n    printVector(arr);\n    return 0;\n}",
    "code_without_comments": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid bubbleSort(vector<int>& arr) {\n    int n = arr.size();\n    bool swapped;\n    for (int i = 0; i < n - 1; i++) {\n        swapped = false;\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                swap(arr[j], arr[j + 1]);\n                swapped = true;\n            }\n        }\n\n        if (!swapped)\n            break;\n    }\n}\n\nvoid printVector(const vector<int>& arr) {\n    for (int num : arr)\n        cout << \" \" << num;\n}\nint main() {\n    vector<int> arr = { 64, 34, 25, 12, 22, 11, 90 };\n    bubbleSort(arr);\n    cout << \"Sorted array: \\n\";\n    printVector(arr);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/bubble-sort-algorithm/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "// Optimized implementation of Bubble sort\n#include <stdbool.h>\n#include <stdio.h>\nvoid swap(int* xp, int* yp){\n    int temp = *xp;\n    *xp = *yp;\n    *yp = temp;\n}\n// An optimized version of Bubble Sort\nvoid bubbleSort(int arr[], int n){\n    int i, j;\n    bool swapped;\n    for (i = 0; i < n - 1; i++) {\n        swapped = false;\n        for (j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                swap(&arr[j], &arr[j + 1]);\n                swapped = true;\n            }\n        }\n        // If no two elements were swapped by inner loop,\n        // then break\n        if (swapped == false)\n            break;\n    }\n}\n// Function to print an array\nvoid printArray(int arr[], int size){\n    int i;\n    for (i = 0; i < size; i++)\n        printf(\"%d \", arr[i]);\n}\nint main(){\n    int arr[] = { 64, 34, 25, 12, 22, 11, 90 };\n    int n = sizeof(arr) / sizeof(arr[0]);\n    bubbleSort(arr, n);\n    printf(\"Sorted array: \\n\");\n    printArray(arr, n);\n    return 0;\n}",
    "code_without_comments": "\n#include <stdbool.h>\n#include <stdio.h>\nvoid swap(int* xp, int* yp){\n    int temp = *xp;\n    *xp = *yp;\n    *yp = temp;\n}\n\nvoid bubbleSort(int arr[], int n){\n    int i, j;\n    bool swapped;\n    for (i = 0; i < n - 1; i++) {\n        swapped = false;\n        for (j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                swap(&arr[j], &arr[j + 1]);\n                swapped = true;\n            }\n        }\n\n\n        if (swapped == false)\n            break;\n    }\n}\n\nvoid printArray(int arr[], int size){\n    int i;\n    for (i = 0; i < size; i++)\n        printf(\"%d \", arr[i]);\n}\nint main(){\n    int arr[] = { 64, 34, 25, 12, 22, 11, 90 };\n    int n = sizeof(arr) / sizeof(arr[0]);\n    bubbleSort(arr, n);\n    printf(\"Sorted array: \\n\");\n    printArray(arr, n);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/bubble-sort-algorithm/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "# Optimized Python program for implementation of Bubble Sort\ndef bubbleSort(arr):\n    n = len(arr)\n    # Traverse through all array elements\n    for i in range(n):\n        swapped = False\n        # Last i elements are already in place\n        for j in range(0, n-i-1):\n            # Traverse the array from 0 to n-i-1\n            # Swap if the element found is greater\n            # than the next element\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n                swapped = True\n        if (swapped == False):\n            break\n# Driver code to test above\nif __name__ == \"__main__\":\n    arr = [64, 34, 25, 12, 22, 11, 90]\n    bubbleSort(arr)\n    print(\"Sorted array:\")\n    for i in range(len(arr)):\n        print(\"%d\" % arr[i], end=\" \")",
    "code_without_comments": "\ndef bubbleSort(arr):\n    n = len(arr)\n\n    for i in range(n):\n        swapped = False\n\n        for j in range(0, n-i-1):\n\n\n\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n                swapped = True\n        if (swapped == False):\n            break\n\nif __name__ == \"__main__\":\n    arr = [64, 34, 25, 12, 22, 11, 90]\n    bubbleSort(arr)\n    print(\"Sorted array:\")\n    for i in range(len(arr)):\n        print(\"%d\" % arr[i], end=\" \")",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/bubble-sort-algorithm/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "// C++ program to implement Selection Sort\n#include <bits/stdc++.h>\nusing namespace std;\nvoid selectionSort(vector<int> &arr) {\n    int n = arr.size();\n    for (int i = 0; i < n - 1; ++i) {\n        // Assume the current position holds\n        // the minimum element\n        int min_idx = i;\n        // Iterate through the unsorted portion\n        // to find the actual minimum\n        for (int j = i + 1; j < n; ++j) {\n            if (arr[j] < arr[min_idx]) {\n                // Update min_idx if a smaller\n                // element is found\n                min_idx = j;\n            }\n        }\n        // Move minimum element to its\n        // correct position\n        swap(arr[i], arr[min_idx]);\n    }\n}\nvoid printArray(vector<int> &arr) {\n    for (int &val : arr) {\n        cout << val << \" \";\n    }\n    cout << endl;\n}\nint main() {\n    vector<int> arr = {64, 25, 12, 22, 11};\n    cout << \"Original array: \";\n    printArray(arr);\n    selectionSort(arr);\n    cout << \"Sorted array: \";\n    printArray(arr);\n    return 0;\n}",
    "code_without_comments": "\n#include <bits/stdc++.h>\nusing namespace std;\nvoid selectionSort(vector<int> &arr) {\n    int n = arr.size();\n    for (int i = 0; i < n - 1; ++i) {\n\n\n        int min_idx = i;\n\n\n        for (int j = i + 1; j < n; ++j) {\n            if (arr[j] < arr[min_idx]) {\n\n\n                min_idx = j;\n            }\n        }\n\n\n        swap(arr[i], arr[min_idx]);\n    }\n}\nvoid printArray(vector<int> &arr) {\n    for (int &val : arr) {\n        cout << val << \" \";\n    }\n    cout << endl;\n}\nint main() {\n    vector<int> arr = {64, 25, 12, 22, 11};\n    cout << \"Original array: \";\n    printArray(arr);\n    selectionSort(arr);\n    cout << \"Sorted array: \";\n    printArray(arr);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/selection-sort-algorithm-2/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "// C program for implementation of selection sort\n#include <stdio.h>\nvoid selectionSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        // Assume the current position holds\n        // the minimum element\n        int min_idx = i;\n        // Iterate through the unsorted portion\n        // to find the actual minimum\n        for (int j = i + 1; j < n; j++) {\n            if (arr[j] < arr[min_idx]) {\n                // Update min_idx if a smaller element is found\n                min_idx = j;\n            }\n        }\n        // Move minimum element to its\n        // correct position\n        int temp = arr[i];\n        arr[i] = arr[min_idx];\n        arr[min_idx] = temp;\n    }\n}\nvoid printArray(int arr[], int n) {\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n}\nint main() {\n    int arr[] = {64, 25, 12, 22, 11};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    printf(\"Original array: \");\n    printArray(arr, n);\n    selectionSort(arr, n);\n    printf(\"Sorted array: \");\n    printArray(arr, n);\n    return 0;\n}",
    "code_without_comments": "\n#include <stdio.h>\nvoid selectionSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n\n\n        int min_idx = i;\n\n\n        for (int j = i + 1; j < n; j++) {\n            if (arr[j] < arr[min_idx]) {\n\n                min_idx = j;\n            }\n        }\n\n\n        int temp = arr[i];\n        arr[i] = arr[min_idx];\n        arr[min_idx] = temp;\n    }\n}\nvoid printArray(int arr[], int n) {\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n}\nint main() {\n    int arr[] = {64, 25, 12, 22, 11};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    printf(\"Original array: \");\n    printArray(arr, n);\n    selectionSort(arr, n);\n    printf(\"Sorted array: \");\n    printArray(arr, n);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/selection-sort-algorithm-2/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "# Python program for implementation of Selection\n# Sort\ndef selection_sort(arr):\n    n = len(arr)\n    for i in range(n - 1):\n        # Assume the current position holds\n        # the minimum element\n        min_idx = i\n        # Iterate through the unsorted portion\n        # to find the actual minimum\n        for j in range(i + 1, n):\n            if arr[j] < arr[min_idx]:\n                # Update min_idx if a smaller element is found\n                min_idx = j\n        # Move minimum element to its\n        # correct position\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\ndef print_array(arr):\n    for val in arr:\n        print(val, end=\" \")\n    print()\nif __name__ == \"__main__\":\n    arr = [64, 25, 12, 22, 11]\n    print(\"Original array: \", end=\"\")\n    print_array(arr)\n    selection_sort(arr)\n    print(\"Sorted array: \", end=\"\")\n    print_array(arr)",
    "code_without_comments": "\n\ndef selection_sort(arr):\n    n = len(arr)\n    for i in range(n - 1):\n\n\n        min_idx = i\n\n\n        for j in range(i + 1, n):\n            if arr[j] < arr[min_idx]:\n\n                min_idx = j\n\n\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\ndef print_array(arr):\n    for val in arr:\n        print(val, end=\" \")\n    print()\nif __name__ == \"__main__\":\n    arr = [64, 25, 12, 22, 11]\n    print(\"Original array: \", end=\"\")\n    print_array(arr)\n    selection_sort(arr)\n    print(\"Sorted array: \", end=\"\")\n    print_array(arr)",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/selection-sort-algorithm-2/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "// C++ program for implementation of Insertion Sort\n#include <iostream>\nusing namespace std;\n/* Function to sort array using insertion sort */\nvoid insertionSort(int arr[], int n)\n{\n    for (int i = 1; i < n; ++i) {\n        int key = arr[i];\n        int j = i - 1;\n        /* Move elements of arr[0..i-1], that are\n           greater than key, to one position ahead\n           of their current position */\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n        arr[j + 1] = key;\n    }\n}\n/* A utility function to print array of size n */\nvoid printArray(int arr[], int n)\n{\n    for (int i = 0; i < n; ++i)\n        cout << arr[i] << \" \";\n    cout << endl;\n}\n// Driver method\nint main()\n{\n    int arr[] = { 12, 11, 13, 5, 6 };\n    int n = sizeof(arr) / sizeof(arr[0]);\n    insertionSort(arr, n);\n    printArray(arr, n);\n    return 0;\n}\n/* This code is contributed by Hritik Shah. */",
    "code_without_comments": "\n#include <iostream>\nusing namespace std;\n\nvoid insertionSort(int arr[], int n)\n{\n    for (int i = 1; i < n; ++i) {\n        int key = arr[i];\n        int j = i - 1;\n\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n        arr[j + 1] = key;\n    }\n}\n\nvoid printArray(int arr[], int n)\n{\n    for (int i = 0; i < n; ++i)\n        cout << arr[i] << \" \";\n    cout << endl;\n}\n\nint main()\n{\n    int arr[] = { 12, 11, 13, 5, 6 };\n    int n = sizeof(arr) / sizeof(arr[0]);\n    insertionSort(arr, n);\n    printArray(arr, n);\n    return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/insertion-sort-algorithm/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "// C program for implementation of Insertion Sort\n#include <stdio.h>\n/* Function to sort array using insertion sort */\nvoid insertionSort(int arr[], int n)\n{\n    for (int i = 1; i < n; ++i) {\n        int key = arr[i];\n        int j = i - 1;\n        /* Move elements of arr[0..i-1], that are\n           greater than key, to one position ahead\n           of their current position */\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n        arr[j + 1] = key;\n    }\n}\n/* A utility function to print array of size n */\nvoid printArray(int arr[], int n)\n{\n    for (int i = 0; i < n; ++i)\n        printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n}\n// Driver method\nint main()\n{\n    int arr[] = { 12, 11, 13, 5, 6 };\n    int n = sizeof(arr) / sizeof(arr[0]);\n    insertionSort(arr, n);\n    printArray(arr, n);\n    return 0;\n}\n/* This code is contributed by Hritik Shah. */",
    "code_without_comments": "\n#include <stdio.h>\n\nvoid insertionSort(int arr[], int n)\n{\n    for (int i = 1; i < n; ++i) {\n        int key = arr[i];\n        int j = i - 1;\n\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n        arr[j + 1] = key;\n    }\n}\n\nvoid printArray(int arr[], int n)\n{\n    for (int i = 0; i < n; ++i)\n        printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n}\n\nint main()\n{\n    int arr[] = { 12, 11, 13, 5, 6 };\n    int n = sizeof(arr) / sizeof(arr[0]);\n    insertionSort(arr, n);\n    printArray(arr, n);\n    return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/insertion-sort-algorithm/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "// Java program for implementation of Insertion Sort\npublic class InsertionSort {\n    /* Function to sort array using insertion sort */\n    void sort(int arr[])\n    {\n        int n = arr.length;\n        for (int i = 1; i < n; ++i) {\n            int key = arr[i];\n            int j = i - 1;\n            /* Move elements of arr[0..i-1], that are\n               greater than key, to one position ahead\n               of their current position */\n            while (j >= 0 && arr[j] > key) {\n                arr[j + 1] = arr[j];\n                j = j - 1;\n            }\n            arr[j + 1] = key;\n        }\n    }\n    /* A utility function to print array of size n */\n    static void printArray(int arr[])\n    {\n        int n = arr.length;\n        for (int i = 0; i < n; ++i)\n            System.out.print(arr[i] + \" \");\n        System.out.println();\n    }\n    // Driver method\n    public static void main(String args[])\n    {\n        int arr[] = { 12, 11, 13, 5, 6 };\n        InsertionSort ob = new InsertionSort();\n        ob.sort(arr);\n        printArray(arr);\n    }\n}\n/* This code is contributed by Hritik Shah. */",
    "code_without_comments": "// Java program for implementation of Insertion Sort\npublic class InsertionSort {\n    /* Function to sort array using insertion sort */\n    void sort(int arr[])\n    {\n        int n = arr.length;\n        for (int i = 1; i < n; ++i) {\n            int key = arr[i];\n            int j = i - 1;\n            /* Move elements of arr[0..i-1], that are\n               greater than key, to one position ahead\n               of their current position */\n            while (j >= 0 && arr[j] > key) {\n                arr[j + 1] = arr[j];\n                j = j - 1;\n            }\n            arr[j + 1] = key;\n        }\n    }\n    /* A utility function to print array of size n */\n    static void printArray(int arr[])\n    {\n        int n = arr.length;\n        for (int i = 0; i < n; ++i)\n            System.out.print(arr[i] + \" \");\n        System.out.println();\n    }\n    // Driver method\n    public static void main(String args[])\n    {\n        int arr[] = { 12, 11, 13, 5, 6 };\n        InsertionSort ob = new InsertionSort();\n        ob.sort(arr);\n        printArray(arr);\n    }\n}\n/* This code is contributed by Hritik Shah. */",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/insertion-sort-algorithm/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "# Python program for implementation of Insertion Sort\n# Function to sort array using insertion sort\ndef insertionSort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        # Move elements of arr[0..i-1], that are\n        # greater than key, to one position ahead\n        # of their current position\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n# A utility function to print array of size n\ndef printArray(arr):\n    for i in range(len(arr)):\n        print(arr[i], end=\" \")\n    print()\n# Driver method\nif __name__ == \"__main__\":\n    arr = [12, 11, 13, 5, 6]\n    insertionSort(arr)\n    printArray(arr)\n    # This code is contributed by Hritik Shah.",
    "code_without_comments": "\n\ndef insertionSort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n\n\n\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n\ndef printArray(arr):\n    for i in range(len(arr)):\n        print(arr[i], end=\" \")\n    print()\n\nif __name__ == \"__main__\":\n    arr = [12, 11, 13, 5, 6]\n    insertionSort(arr)\n    printArray(arr)\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/insertion-sort-algorithm/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\n// Merges two subarrays of arr[].\n// First subarray is arr[left..mid]\n// Second subarray is arr[mid+1..right]\nvoid merge(vector<int>& arr, int left,\n                     int mid, int right){\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n    // Create temp vectors\n    vector<int> L(n1), R(n2);\n    // Copy data to temp vectors L[] and R[]\n    for (int i = 0; i < n1; i++)\n        L[i] = arr[left + i];\n    for (int j = 0; j < n2; j++)\n        R[j] = arr[mid + 1 + j];\n    int i = 0, j = 0;\n    int k = left;\n    // Merge the temp vectors back\n    // into arr[left..right]\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        }\n        else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n    // Copy the remaining elements of L[],\n    // if there are any\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n    // Copy the remaining elements of R[],\n    // if there are any\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n// begin is for left index and end is right index\n// of the sub-array of arr to be sorted\nvoid mergeSort(vector<int>& arr, int left, int right){\n    if (left >= right)\n        return;\n    int mid = left + (right - left) / 2;\n    mergeSort(arr, left, mid);\n    mergeSort(arr, mid + 1, right);\n    merge(arr, left, mid, right);\n}\n// Driver code\nint main(){\n    vector<int> arr = {38, 27, 43, 10};\n    int n = arr.size();\n    mergeSort(arr, 0, n - 1);\n    for (int i = 0; i < arr.size(); i++)\n        cout << arr[i] << \" \";\n    cout << endl;\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n\n\nvoid merge(vector<int>& arr, int left,\n                     int mid, int right){\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n\n    vector<int> L(n1), R(n2);\n\n    for (int i = 0; i < n1; i++)\n        L[i] = arr[left + i];\n    for (int j = 0; j < n2; j++)\n        R[j] = arr[mid + 1 + j];\n    int i = 0, j = 0;\n    int k = left;\n\n\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        }\n        else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n\n\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n\n\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\n\nvoid mergeSort(vector<int>& arr, int left, int right){\n    if (left >= right)\n        return;\n    int mid = left + (right - left) / 2;\n    mergeSort(arr, left, mid);\n    mergeSort(arr, mid + 1, right);\n    merge(arr, left, mid, right);\n}\n\nint main(){\n    vector<int> arr = {38, 27, 43, 10};\n    int n = arr.size();\n    mergeSort(arr, 0, n - 1);\n    for (int i = 0; i < arr.size(); i++)\n        cout << arr[i] << \" \";\n    cout << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/merge-sort/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <stdio.h>\n#include <stdlib.h>\n// Merges two subarrays of arr[].\n// First subarray is arr[l..m]\n// Second subarray is arr[m+1..r]\nvoid merge(int arr[], int l, int m, int r){\n    int i, j, k;\n    int n1 = m - l + 1;\n    int n2 = r - m;\n    // Create temp arrays\n    int L[n1], R[n2];\n    // Copy data to temp arrays L[] and R[]\n    for (i = 0; i < n1; i++)\n        L[i] = arr[l + i];\n    for (j = 0; j < n2; j++)\n        R[j] = arr[m + 1 + j];\n    // Merge the temp arrays back into arr[l..r\n    i = 0;\n    j = 0;\n    k = l;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        }\n        else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n    // Copy the remaining elements of L[],\n    // if there are any\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n    // Copy the remaining elements of R[],\n    // if there are any\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n// l is for left index and r is right index of the\n// sub-array of arr to be sorted\nvoid mergeSort(int arr[], int l, int r){\n    if (l < r) {\n        int m = l + (r - l) / 2;\n        // Sort first and second halves\n        mergeSort(arr, l, m);\n        mergeSort(arr, m + 1, r);\n        merge(arr, l, m, r);\n    }\n}\n// Driver code\nint main(){\n    int arr[] = {38, 27, 43, 10};\n    int arr_size = sizeof(arr) / sizeof(arr[0]);\n    mergeSort(arr, 0, arr_size - 1);\n    int i;\n    for (i = 0; i < arr_size; i++)\n        printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n    return 0;\n}",
    "code_without_comments": "#include <stdio.h>\n#include <stdlib.h>\n\n\n\nvoid merge(int arr[], int l, int m, int r){\n    int i, j, k;\n    int n1 = m - l + 1;\n    int n2 = r - m;\n\n    int L[n1], R[n2];\n\n    for (i = 0; i < n1; i++)\n        L[i] = arr[l + i];\n    for (j = 0; j < n2; j++)\n        R[j] = arr[m + 1 + j];\n\n    i = 0;\n    j = 0;\n    k = l;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        }\n        else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n\n\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n\n\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\n\nvoid mergeSort(int arr[], int l, int r){\n    if (l < r) {\n        int m = l + (r - l) / 2;\n\n        mergeSort(arr, l, m);\n        mergeSort(arr, m + 1, r);\n        merge(arr, l, m, r);\n    }\n}\n\nint main(){\n    int arr[] = {38, 27, 43, 10};\n    int arr_size = sizeof(arr) / sizeof(arr[0]);\n    mergeSort(arr, 0, arr_size - 1);\n    int i;\n    for (i = 0; i < arr_size; i++)\n        printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/merge-sort/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    # Create temp arrays\n    L = [0] * n1\n    R = [0] * n2\n    # Copy data to temp arrays L[] and R[]\n    for i in range(n1):\n        L[i] = arr[left + i]\n    for j in range(n2):\n        R[j] = arr[mid + 1 + j]\n    i = 0\n    j = 0\n    k = left\n    # Merge the temp arrays back\n    # into arr[left..right]\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n        k += 1\n    # Copy the remaining elements of L[],\n    # if there are any\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    # Copy the remaining elements of R[],\n    # if there are any\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\ndef mergeSort(arr, left, right):\n    if left < right:\n        mid = (left + right) // 2\n        mergeSort(arr, left, mid)\n        mergeSort(arr, mid + 1, right)\n        merge(arr, left, mid, right)\n# Driver code\nif __name__ == \"__main__\":\n    arr = [38, 27, 43, 10]\n    mergeSort(arr, 0, len(arr) - 1)\n    for i in arr:\n        print(i, end=\" \")\n    print()",
    "code_without_comments": "def merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n\n    L = [0] * n1\n    R = [0] * n2\n\n    for i in range(n1):\n        L[i] = arr[left + i]\n    for j in range(n2):\n        R[j] = arr[mid + 1 + j]\n    i = 0\n    j = 0\n    k = left\n\n\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n        k += 1\n\n\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n\n\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\ndef mergeSort(arr, left, right):\n    if left < right:\n        mid = (left + right) // 2\n        mergeSort(arr, left, mid)\n        mergeSort(arr, mid + 1, right)\n        merge(arr, left, mid, right)\n\nif __name__ == \"__main__\":\n    arr = [38, 27, 43, 10]\n    mergeSort(arr, 0, len(arr) - 1)\n    for i in arr:\n        print(i, end=\" \")\n    print()",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/merge-sort/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nint partition(vector<int>& arr, int low, int high) {\n    // choose the pivot\n    int pivot = arr[high];\n    // undex of smaller element and indicates\n    // the right position of pivot found so far\n    int i = low - 1;\n    // Traverse arr[low..high] and move all smaller\n    // elements on left side. Elements from low to\n    // i are smaller after every iteration\n    for (int j = low; j <= high - 1; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            swap(arr[i], arr[j]);\n        }\n    }\n    // move pivot after smaller elements and\n    // return its position\n    swap(arr[i + 1], arr[high]);\n    return i + 1;\n}\n// the QuickSort function implementation\nvoid quickSort(vector<int>& arr, int low, int high) {\n    if (low < high) {\n        // pi is the partition return index of pivot\n        int pi = partition(arr, low, high);\n        // recursion calls for smaller elements\n        // and greater or equals elements\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\nint main() {\n    vector<int> arr = {10, 7, 8, 9, 1, 5};\n    int n = arr.size();\n    quickSort(arr, 0, n - 1);\n    for (int i = 0; i < n; i++) {\n        cout << arr[i] << \" \";\n    }\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nint partition(vector<int>& arr, int low, int high) {\n\n    int pivot = arr[high];\n\n\n    int i = low - 1;\n\n\n\n    for (int j = low; j <= high - 1; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            swap(arr[i], arr[j]);\n        }\n    }\n\n\n    swap(arr[i + 1], arr[high]);\n    return i + 1;\n}\n\nvoid quickSort(vector<int>& arr, int low, int high) {\n    if (low < high) {\n\n        int pi = partition(arr, low, high);\n\n\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\nint main() {\n    vector<int> arr = {10, 7, 8, 9, 1, 5};\n    int n = arr.size();\n    quickSort(arr, 0, n - 1);\n    for (int i = 0; i < n; i++) {\n        cout << arr[i] << \" \";\n    }\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/quick-sort-algorithm/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <stdio.h>\nvoid swap(int* a, int* b);\n// partition function\nint partition(int arr[], int low, int high) {\n    // Choose the pivot\n    int pivot = arr[high];\n    // Index of smaller element and indicates\n    // the right position of pivot found so far\n    int i = low - 1;\n    // Traverse arr[low..high] and move all smaller\n    // elements to the left side. Elements from low to\n    // i are smaller after every iteration\n    for (int j = low; j <= high - 1; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n    }\n    // Move pivot after smaller elements and\n    // return its position\n    swap(&arr[i + 1], &arr[high]);\n    return i + 1;\n}\n// The QuickSort function implementation\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        // pi is the partition return index of pivot\n        int pi = partition(arr, low, high);\n        // recursion calls for smaller elements\n        // and greater or equals elements\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\nvoid swap(int* a, int* b) {\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\nint main() {\n    int arr[] = {10, 7, 8, 9, 1, 5};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    quickSort(arr, 0, n - 1);\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}",
    "code_without_comments": "#include <stdio.h>\nvoid swap(int* a, int* b);\n\nint partition(int arr[], int low, int high) {\n\n    int pivot = arr[high];\n\n\n    int i = low - 1;\n\n\n\n    for (int j = low; j <= high - 1; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n    }\n\n\n    swap(&arr[i + 1], &arr[high]);\n    return i + 1;\n}\n\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n\n        int pi = partition(arr, low, high);\n\n\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\nvoid swap(int* a, int* b) {\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\nint main() {\n    int arr[] = {10, 7, 8, 9, 1, 5};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    quickSort(arr, 0, n - 1);\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/quick-sort-algorithm/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "# partition function\ndef partition(arr, low, high):\n    # choose the pivot\n    pivot = arr[high]\n    # index of smaller element and indicates\n    # the right position of pivot found so far\n    i = low - 1\n    # traverse arr[low..high] and move all smaller\n    # elements to the left side. Elements from low to\n    # i are smaller after every iteration\n    for j in range(low, high):\n        if arr[j] < pivot:\n            i += 1\n            swap(arr, i, j)\n    # move pivot after smaller elements and\n    # return its position\n    swap(arr, i + 1, high)\n    return i + 1\n# swap function\ndef swap(arr, i, j):\n    arr[i], arr[j] = arr[j], arr[i]\n# the QuickSort function implementation\ndef quickSort(arr, low, high):\n    if low < high:\n        # pi is the partition return index of pivot\n        pi = partition(arr, low, high)\n        # recursion calls for smaller elements\n        # and greater or equals elements\n        quickSort(arr, low, pi - 1)\n        quickSort(arr, pi + 1, high)\nif __name__ == \"__main__\":\n    arr = [10, 7, 8, 9, 1, 5]\n    n = len(arr)\n    quickSort(arr, 0, n - 1)\n    for val in arr:\n        print(val, end=\" \")",
    "code_without_comments": "\ndef partition(arr, low, high):\n\n    pivot = arr[high]\n\n\n    i = low - 1\n\n\n\n    for j in range(low, high):\n        if arr[j] < pivot:\n            i += 1\n            swap(arr, i, j)\n\n\n    swap(arr, i + 1, high)\n    return i + 1\n\ndef swap(arr, i, j):\n    arr[i], arr[j] = arr[j], arr[i]\n\ndef quickSort(arr, low, high):\n    if low < high:\n\n        pi = partition(arr, low, high)\n\n\n        quickSort(arr, low, pi - 1)\n        quickSort(arr, pi + 1, high)\nif __name__ == \"__main__\":\n    arr = [10, 7, 8, 9, 1, 5]\n    n = len(arr)\n    quickSort(arr, 0, n - 1)\n    for val in arr:\n        print(val, end=\" \")",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/quick-sort-algorithm/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include<vector>\nusing namespace std;\n// To heapify a subtree rooted with node i\nvoid heapify(vector<int>& arr, int n, int i){\n    // Initialize largest as root\n    int largest = i;\n    // left index = 2*i + 1\n    int l = 2 * i + 1;\n    // right index = 2*i + 2\n    int r = 2 * i + 2;\n    // If left child is larger than root\n    if (l < n && arr[l] > arr[largest])\n        largest = l;\n    // If right child is larger than largest so far\n    if (r < n && arr[r] > arr[largest])\n        largest = r;\n    // If largest is not root\n    if (largest != i) {\n        swap(arr[i], arr[largest]);\n        // Recursively heapify the affected sub-tree\n        heapify(arr, n, largest);\n    }\n}\n// Main function to do heap sort\nvoid heapSort(vector<int>& arr){\n    int n = arr.size();\n    // Build heap (rearrange vector)\n    for (int i = n / 2 - 1; i >= 0; i--)\n        heapify(arr, n, i);\n    // One by one extract an element from heap\n    for (int i = n - 1; i > 0; i--) {\n        // Move current root to end\n        swap(arr[0], arr[i]);\n        // Call max heapify on the reduced heap\n        heapify(arr, i, 0);\n    }\n}\nint main(){\n    vector<int> arr = { 9, 4, 3, 8, 10, 2, 5 };\n    heapSort(arr);\n    for (int i = 0; i < arr.size(); ++i)\n        cout << arr[i] << \" \";\n}",
    "code_without_comments": "#include <iostream>\n#include<vector>\nusing namespace std;\n\nvoid heapify(vector<int>& arr, int n, int i){\n\n    int largest = i;\n\n    int l = 2 * i + 1;\n\n    int r = 2 * i + 2;\n\n    if (l < n && arr[l] > arr[largest])\n        largest = l;\n\n    if (r < n && arr[r] > arr[largest])\n        largest = r;\n\n    if (largest != i) {\n        swap(arr[i], arr[largest]);\n\n        heapify(arr, n, largest);\n    }\n}\n\nvoid heapSort(vector<int>& arr){\n    int n = arr.size();\n\n    for (int i = n / 2 - 1; i >= 0; i--)\n        heapify(arr, n, i);\n\n    for (int i = n - 1; i > 0; i--) {\n\n        swap(arr[0], arr[i]);\n\n        heapify(arr, i, 0);\n    }\n}\nint main(){\n    vector<int> arr = { 9, 4, 3, 8, 10, 2, 5 };\n    heapSort(arr);\n    for (int i = 0; i < arr.size(); ++i)\n        cout << arr[i] << \" \";\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/heap-sort/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <stdio.h>\n// To heapify a subtree rooted with node i\nvoid heapify(int arr[], int n, int i){\n    // Initialize largest as root\n    int largest = i;\n    // left index = 2*i + 1\n    int l = 2 * i + 1;\n    // right index = 2*i + 2\n    int r = 2 * i + 2;\n    // If left child is larger than root\n    if (l < n && arr[l] > arr[largest])\n        largest = l;\n    // If right child is larger than largest so far\n    if (r < n && arr[r] > arr[largest])\n        largest = r;\n    // If largest is not root\n    if (largest != i) {\n        int temp = arr[i];\n        arr[i] = arr[largest];\n        arr[largest] = temp;\n        // Recursively heapify the affected sub-tree\n        heapify(arr, n, largest);\n    }\n}\n// Main function to do heap sort\nvoid heapSort(int arr[], int n){\n    // Build heap (rearrange vector)\n    for (int i = n / 2 - 1; i >= 0; i--)\n        heapify(arr, n, i);\n    // One by one extract an element from heap\n    for (int i = n - 1; i > 0; i--) {\n        // Move current root to end\n        int temp = arr[0];\n        arr[0] = arr[i];\n        arr[i] = temp;\n        // Call max heapify on the reduced heap\n        heapify(arr, i, 0);\n    }\n}\nint main() {\n    int arr[] = { 9, 4, 3, 8, 10, 2, 5 };\n    int n = sizeof(arr) / sizeof(arr[0]);\n    heapSort(arr, n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d \", arr[i]);\n    return 0;\n}",
    "code_without_comments": "#include <stdio.h>\n\nvoid heapify(int arr[], int n, int i){\n\n    int largest = i;\n\n    int l = 2 * i + 1;\n\n    int r = 2 * i + 2;\n\n    if (l < n && arr[l] > arr[largest])\n        largest = l;\n\n    if (r < n && arr[r] > arr[largest])\n        largest = r;\n\n    if (largest != i) {\n        int temp = arr[i];\n        arr[i] = arr[largest];\n        arr[largest] = temp;\n\n        heapify(arr, n, largest);\n    }\n}\n\nvoid heapSort(int arr[], int n){\n\n    for (int i = n / 2 - 1; i >= 0; i--)\n        heapify(arr, n, i);\n\n    for (int i = n - 1; i > 0; i--) {\n\n        int temp = arr[0];\n        arr[0] = arr[i];\n        arr[i] = temp;\n\n        heapify(arr, i, 0);\n    }\n}\nint main() {\n    int arr[] = { 9, 4, 3, 8, 10, 2, 5 };\n    int n = sizeof(arr) / sizeof(arr[0]);\n    heapSort(arr, n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d \", arr[i]);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/heap-sort/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "# To heapify a subtree rooted with node i\ndef heapify(arr, n, i):\n    # Initialize largest as root\n    largest = i\n    # left index = 2*i + 1\n    l = 2 * i + 1\n    # right index = 2*i + 2\n    r = 2 * i + 2\n    # If left child is larger than root\n    if l < n and arr[l] > arr[largest]:\n        largest = l\n    # If right child is larger than largest so far\n    if r < n and arr[r] > arr[largest]:\n        largest = r\n    # If largest is not root\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]\n        # Recursively heapify the affected sub-tree\n        heapify(arr, n, largest)\n# Main function to do heap sort\ndef heapSort(arr):\n    n = len(arr)\n    # Build heap (rearrange vector)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n    # One by one extract an element from heap\n    for i in range(n - 1, 0, -1):\n        # Move current root to end\n        arr[0], arr[i] = arr[i], arr[0]\n        # Call max heapify on the reduced heap\n        heapify(arr, i, 0)\nif __name__ == \"__main__\":\n    arr = [9, 4, 3, 8, 10, 2, 5]\n    heapSort(arr)\n    for i in range(len(arr)):\n        print(arr[i], end=\" \")",
    "code_without_comments": "\ndef heapify(arr, n, i):\n\n    largest = i\n\n    l = 2 * i + 1\n\n    r = 2 * i + 2\n\n    if l < n and arr[l] > arr[largest]:\n        largest = l\n\n    if r < n and arr[r] > arr[largest]:\n        largest = r\n\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]\n\n        heapify(arr, n, largest)\n\ndef heapSort(arr):\n    n = len(arr)\n\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n\n    for i in range(n - 1, 0, -1):\n\n        arr[0], arr[i] = arr[i], arr[0]\n\n        heapify(arr, i, 0)\nif __name__ == \"__main__\":\n    arr = [9, 4, 3, 8, 10, 2, 5]\n    heapSort(arr)\n    for i in range(len(arr)):\n        print(arr[i], end=\" \")",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/heap-sort/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nvector<int> countsort(vector<int>& arr) {\n    int n = arr.size();\n    // find the maximum element\n    int maxval = 0;\n    for (int i = 0; i < n; i++)\n        maxval = max(maxval, arr[i]);\n    // create and initialize cntArr array\n    vector<int> cntArr(maxval + 1, 0);\n    // count frequency of each element\n    for (int i = 0; i < n; i++)\n        cntArr[arr[i]]++;\n    // compute prefix sum\n    for (int i = 1; i <= maxval; i++)\n        cntArr[i] += cntArr[i - 1];\n    // build output array\n    vector<int> ans(n);\n    for (int i = n - 1; i >= 0; i--) {\n        ans[cntArr[arr[i]] - 1] = arr[i];\n        cntArr[arr[i]]--;\n    }\n    return ans;\n}\nint main() {\n    vector<int> arr = {2,5,3,0,2,3,0,3};\n    vector<int> ans = countsort(arr);\n    for (int x : ans)\n        cout << x << \" \";\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nvector<int> countsort(vector<int>& arr) {\n    int n = arr.size();\n\n    int maxval = 0;\n    for (int i = 0; i < n; i++)\n        maxval = max(maxval, arr[i]);\n\n    vector<int> cntArr(maxval + 1, 0);\n\n    for (int i = 0; i < n; i++)\n        cntArr[arr[i]]++;\n\n    for (int i = 1; i <= maxval; i++)\n        cntArr[i] += cntArr[i - 1];\n\n    vector<int> ans(n);\n    for (int i = n - 1; i >= 0; i--) {\n        ans[cntArr[arr[i]] - 1] = arr[i];\n        cntArr[arr[i]]--;\n    }\n    return ans;\n}\nint main() {\n    vector<int> arr = {2,5,3,0,2,3,0,3};\n    vector<int> ans = countsort(arr);\n    for (int x : ans)\n        cout << x << \" \";\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/counting-sort/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <stdio.h>\n#include <stdlib.h>\nvoid countsort(int arr[], int n) {\n    int maxval = 0;\n    // Find the maximum element\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > maxval) {\n            maxval = arr[i];\n        }\n    }\n    // Create and initialize cntArr array\n    int* cntArr = (int*)calloc(maxval + 1, sizeof(int));\n    // Count frequency of each element\n    for (int i = 0; i < n; i++) {\n        cntArr[arr[i]]++;\n    }\n    // Compute prefix sum\n    for (int i = 1; i <= maxval; i++) {\n        cntArr[i] += cntArr[i - 1];\n    }\n    // Build output array\n    int* ans = (int*)malloc(n * sizeof(int));\n    for (int i = n - 1; i >= 0; i--) {\n        ans[cntArr[arr[i]] - 1] = arr[i];\n        cntArr[arr[i]]--;\n    }\n    // Copy sorted elements back to arr[]\n    for (int i = 0; i < n; i++) {\n        arr[i] = ans[i];\n    }\n    // Free dynamically allocated memory\n    free(cntArr);\n    free(ans);\n}\n// Driver code\nint main() {\n    int arr[] = {2, 5, 3, 0, 2, 3, 0, 3};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    // Sorting the array\n    countsort(arr, n);\n    // Printing the sorted array\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}",
    "code_without_comments": "#include <stdio.h>\n#include <stdlib.h>\nvoid countsort(int arr[], int n) {\n    int maxval = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > maxval) {\n            maxval = arr[i];\n        }\n    }\n\n    int* cntArr = (int*)calloc(maxval + 1, sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        cntArr[arr[i]]++;\n    }\n\n    for (int i = 1; i <= maxval; i++) {\n        cntArr[i] += cntArr[i - 1];\n    }\n\n    int* ans = (int*)malloc(n * sizeof(int));\n    for (int i = n - 1; i >= 0; i--) {\n        ans[cntArr[arr[i]] - 1] = arr[i];\n        cntArr[arr[i]]--;\n    }\n\n    for (int i = 0; i < n; i++) {\n        arr[i] = ans[i];\n    }\n\n    free(cntArr);\n    free(ans);\n}\n\nint main() {\n    int arr[] = {2, 5, 3, 0, 2, 3, 0, 3};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    countsort(arr, n);\n\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/counting-sort/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def count_sort(arr):\n    if not arr:\n        return []\n    n = len(arr)\n    maxval = max(arr)\n    # create and initialize cntArr\n    cntArr = [0] * (maxval + 1)\n    # count frequency of each element\n    for v in arr:\n        cntArr[v] += 1\n    # compute prefix sums\n    for i in range(1, maxval + 1):\n        cntArr[i] += cntArr[i - 1]\n    # build output array\n    ans = [0] * n\n    # iterate in reverse to keep it stable\n    for i in range(n - 1, -1, -1):\n        v = arr[i]\n        ans[cntArr[v] - 1] = v\n        cntArr[v] -= 1\n    return ans\nif __name__ == \"__main__\":\n    arr = [2, 5, 3, 0, 2, 3, 0, 3]\n    ans = count_sort(arr)\n    print(ans)",
    "code_without_comments": "def count_sort(arr):\n    if not arr:\n        return []\n    n = len(arr)\n    maxval = max(arr)\n\n    cntArr = [0] * (maxval + 1)\n\n    for v in arr:\n        cntArr[v] += 1\n\n    for i in range(1, maxval + 1):\n        cntArr[i] += cntArr[i - 1]\n\n    ans = [0] * n\n\n    for i in range(n - 1, -1, -1):\n        v = arr[i]\n        ans[cntArr[v] - 1] = v\n        cntArr[v] -= 1\n    return ans\nif __name__ == \"__main__\":\n    arr = [2, 5, 3, 0, 2, 3, 0, 3]\n    ans = count_sort(arr)\n    print(ans)",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/counting-sort/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "// C++ implementation of Radix Sort\n#include <iostream>\nusing namespace std;\n// A utility function to get maximum\n// value in arr[]\nint getMax(int arr[], int n)\n{\n    int mx = arr[0];\n    for (int i = 1; i < n; i++)\n        if (arr[i] > mx)\n            mx = arr[i];\n    return mx;\n}\n// A function to do counting sort of arr[]\n// according to the digit\n// represented by exp.\nvoid countSort(int arr[], int n, int exp)\n{\n    // Output array\n    int output[n];\n    int i, count[10] = { 0 };\n    // Store count of occurrences\n    // in count[]\n    for (i = 0; i < n; i++)\n        count[(arr[i] / exp) % 10]++;\n    // Change count[i] so that count[i]\n    // now contains actual position\n    // of this digit in output[]\n    for (i = 1; i < 10; i++)\n        count[i] += count[i - 1];\n    // Build the output array\n    for (i = n - 1; i >= 0; i--) {\n        output[count[(arr[i] / exp) % 10] - 1] = arr[i];\n        count[(arr[i] / exp) % 10]--;\n    }\n    // Copy the output array to arr[],\n    // so that arr[] now contains sorted\n    // numbers according to current digit\n    for (i = 0; i < n; i++)\n        arr[i] = output[i];\n}\n// The main function to that sorts arr[]\n// of size n using Radix Sort\nvoid radixsort(int arr[], int n)\n{\n    // Find the maximum number to\n    // know number of digits\n    int m = getMax(arr, n);\n    // Do counting sort for every digit.\n    // Note that instead of passing digit\n    // number, exp is passed. exp is 10^i\n    // where i is current digit number\n    for (int exp = 1; m / exp > 0; exp *= 10)\n        countSort(arr, n, exp);\n}\n// A utility function to print an array\nvoid print(int arr[], int n)\n{\n    for (int i = 0; i < n; i++)\n        cout << arr[i] << \" \";\n}\n// Driver Code\nint main()\n{\n    int arr[] = { 170, 45, 75, 90, 802, 24, 2, 66 };\n    int n = sizeof(arr) / sizeof(arr[0]);\n    // Function Call\n    radixsort(arr, n);\n    print(arr, n);\n    return 0;\n}",
    "code_without_comments": "\n#include <iostream>\nusing namespace std;\n\n\nint getMax(int arr[], int n)\n{\n    int mx = arr[0];\n    for (int i = 1; i < n; i++)\n        if (arr[i] > mx)\n            mx = arr[i];\n    return mx;\n}\n\n\n\nvoid countSort(int arr[], int n, int exp)\n{\n\n    int output[n];\n    int i, count[10] = { 0 };\n\n\n    for (i = 0; i < n; i++)\n        count[(arr[i] / exp) % 10]++;\n\n\n\n    for (i = 1; i < 10; i++)\n        count[i] += count[i - 1];\n\n    for (i = n - 1; i >= 0; i--) {\n        output[count[(arr[i] / exp) % 10] - 1] = arr[i];\n        count[(arr[i] / exp) % 10]--;\n    }\n\n\n\n    for (i = 0; i < n; i++)\n        arr[i] = output[i];\n}\n\n\nvoid radixsort(int arr[], int n)\n{\n\n\n    int m = getMax(arr, n);\n\n\n\n\n    for (int exp = 1; m / exp > 0; exp *= 10)\n        countSort(arr, n, exp);\n}\n\nvoid print(int arr[], int n)\n{\n    for (int i = 0; i < n; i++)\n        cout << arr[i] << \" \";\n}\n\nint main()\n{\n    int arr[] = { 170, 45, 75, 90, 802, 24, 2, 66 };\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    radixsort(arr, n);\n    print(arr, n);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/radix-sort/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <stdio.h>\n// A utility function to get the maximum\n// value in arr[]\nint getMax(int arr[], int n) {\n    int mx = arr[0];\n    for (int i = 1; i < n; i++)\n        if (arr[i] > mx)\n            mx = arr[i];\n    return mx;\n}\n// A function to do counting sort of arr[]\n// according to the digit represented by exp\nvoid countSort(int arr[], int n, int exp) {\n    int output[n]; // Output array\n    int count[10] = {0}; // Initialize count array as 0\n    // Store count of occurrences in count[]\n    for (int i = 0; i < n; i++)\n        count[(arr[i] / exp) % 10]++;\n    // Change count[i] so that count[i] now\n    // contains actual position of this digit\n    // in output[]\n    for (int i = 1; i < 10; i++)\n        count[i] += count[i - 1];\n    // Build the output array\n    for (int i = n - 1; i >= 0; i--) {\n        output[count[(arr[i] / exp) % 10] - 1] = arr[i];\n        count[(arr[i] / exp) % 10]--;\n    }\n    // Copy the output array to arr[],\n    // so that arr[] now contains sorted\n    // numbers according to current digit\n    for (int i = 0; i < n; i++)\n        arr[i] = output[i];\n}\n// The main function to sort arr[] of size\n// n using Radix Sort\nvoid radixSort(int arr[], int n) {\n    // Find the maximum number to know\n    // the number of digits\n    int m = getMax(arr, n);\n    // Do counting sort for every digit\n    // exp is 10^i where i is the current\n    // digit number\n    for (int exp = 1; m / exp > 0; exp *= 10)\n        countSort(arr, n, exp);\n}\n// A utility function to print an array\nvoid printArray(int arr[], int n) {\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n}\n// Driver code\nint main() {\n    int arr[] = {170, 45, 75, 90, 802, 24, 2, 66};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    // Function call\n    radixSort(arr, n);\n    printArray(arr, n);\n    return 0;\n}",
    "code_without_comments": "#include <stdio.h>\n\n\nint getMax(int arr[], int n) {\n    int mx = arr[0];\n    for (int i = 1; i < n; i++)\n        if (arr[i] > mx)\n            mx = arr[i];\n    return mx;\n}\n\n\nvoid countSort(int arr[], int n, int exp) {\n    int output[n];\n    int count[10] = {0};\n\n    for (int i = 0; i < n; i++)\n        count[(arr[i] / exp) % 10]++;\n\n\n\n    for (int i = 1; i < 10; i++)\n        count[i] += count[i - 1];\n\n    for (int i = n - 1; i >= 0; i--) {\n        output[count[(arr[i] / exp) % 10] - 1] = arr[i];\n        count[(arr[i] / exp) % 10]--;\n    }\n\n\n\n    for (int i = 0; i < n; i++)\n        arr[i] = output[i];\n}\n\n\nvoid radixSort(int arr[], int n) {\n\n\n    int m = getMax(arr, n);\n\n\n\n    for (int exp = 1; m / exp > 0; exp *= 10)\n        countSort(arr, n, exp);\n}\n\nvoid printArray(int arr[], int n) {\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n}\n\nint main() {\n    int arr[] = {170, 45, 75, 90, 802, 24, 2, 66};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    radixSort(arr, n);\n    printArray(arr, n);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/radix-sort/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "# Python program for implementation of Radix Sort\n# A function to do counting sort of arr[] according to\n# the digit represented by exp.\ndef countingSort(arr, exp1):\n    n = len(arr)\n    # The output array elements that will have sorted arr\n    output = [0] * (n)\n    # initialize count array as 0\n    count = [0] * (10)\n    # Store count of occurrences in count[]\n    for i in range(0, n):\n        index = arr[i] // exp1\n        count[index % 10] += 1\n    # Change count[i] so that count[i] now contains actual\n    # position of this digit in output array\n    for i in range(1, 10):\n        count[i] += count[i - 1]\n    # Build the output array\n    i = n - 1\n    while i >= 0:\n        index = arr[i] // exp1\n        output[count[index % 10] - 1] = arr[i]\n        count[index % 10] -= 1\n        i -= 1\n    # Copying the output array to arr[],\n    # so that arr now contains sorted numbers\n    i = 0\n    for i in range(0, len(arr)):\n        arr[i] = output[i]\n# Method to do Radix Sort\ndef radixSort(arr):\n    # Find the maximum number to know number of digits\n    max1 = max(arr)\n    # Do counting sort for every digit. Note that instead\n    # of passing digit number, exp is passed. exp is 10^i\n    # where i is current digit number\n    exp = 1\n    while max1 / exp >= 1:\n        countingSort(arr, exp)\n        exp *= 10\n# Driver code\narr = [170, 45, 75, 90, 802, 24, 2, 66]\n# Function Call\nradixSort(arr)\nfor i in range(len(arr)):\n    print(arr[i], end=\" \")\n# This code is contributed by Mohit Kumra\n# Edited by Patrick Gallagher",
    "code_without_comments": "\n\n\ndef countingSort(arr, exp1):\n    n = len(arr)\n\n    output = [0] * (n)\n\n    count = [0] * (10)\n\n    for i in range(0, n):\n        index = arr[i] // exp1\n        count[index % 10] += 1\n\n\n    for i in range(1, 10):\n        count[i] += count[i - 1]\n\n    i = n - 1\n    while i >= 0:\n        index = arr[i] // exp1\n        output[count[index % 10] - 1] = arr[i]\n        count[index % 10] -= 1\n        i -= 1\n\n\n    i = 0\n    for i in range(0, len(arr)):\n        arr[i] = output[i]\n\ndef radixSort(arr):\n\n    max1 = max(arr)\n\n\n\n    exp = 1\n    while max1 / exp >= 1:\n        countingSort(arr, exp)\n        exp *= 10\n\narr = [170, 45, 75, 90, 802, 24, 2, 66]\n\nradixSort(arr)\nfor i in range(len(arr)):\n    print(arr[i], end=\" \")\n\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/radix-sort/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nint binarySearch(vector<int> &arr, int x) {\n    int low = 0;\n    int high = arr.size() - 1;\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        // Check if x is present at mid\n        if (arr[mid] == x)\n            return mid;\n        // If x greater, ignore left half\n        if (arr[mid] < x)\n            low = mid + 1;\n        // If x is smaller, ignore right half\n        else\n            high = mid - 1;\n    }\n    // If we reach here, then element was not present\n    return -1;\n}\nint main() {\n    vector<int> arr = { 2, 3, 4, 10, 40 };\n    int x = 10;\n    int result = binarySearch(arr, x);\n    if(result == -1) cout << \"Element is not present in array\";\n    else cout << \"Element is present at index \" << result;\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nint binarySearch(vector<int> &arr, int x) {\n    int low = 0;\n    int high = arr.size() - 1;\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n\n        if (arr[mid] == x)\n            return mid;\n\n        if (arr[mid] < x)\n            low = mid + 1;\n\n        else\n            high = mid - 1;\n    }\n\n    return -1;\n}\nint main() {\n    vector<int> arr = { 2, 3, 4, 10, 40 };\n    int x = 10;\n    int result = binarySearch(arr, x);\n    if(result == -1) cout << \"Element is not present in array\";\n    else cout << \"Element is present at index \" << result;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/binary-search/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <stdio.h>\nint binarySearch(int arr[], int n, int x) {\n    int low = 0;\n    int high = n-1;\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        // Check if x is present at mid\n        if (arr[mid] == x)\n            return mid;\n        // If x greater, ignore left half\n        if (arr[mid] < x)\n            low = mid + 1;\n        // If x is smaller, ignore right half\n        else\n            high = mid - 1;\n    }\n    // If we reach here, then element was not present\n    return -1;\n}\nint main() {\n    int arr[] = { 2, 3, 4, 10, 40 };\n    int x = 10;\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int result = binarySearch(arr, n, x);\n    if(result == -1) printf(\"Element is not present in array\");\n    else printf(\"Element is present at index %d\",result);\n}",
    "code_without_comments": "#include <stdio.h>\nint binarySearch(int arr[], int n, int x) {\n    int low = 0;\n    int high = n-1;\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n\n        if (arr[mid] == x)\n            return mid;\n\n        if (arr[mid] < x)\n            low = mid + 1;\n\n        else\n            high = mid - 1;\n    }\n\n    return -1;\n}\nint main() {\n    int arr[] = { 2, 3, 4, 10, 40 };\n    int x = 10;\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int result = binarySearch(arr, n, x);\n    if(result == -1) printf(\"Element is not present in array\");\n    else printf(\"Element is present at index %d\",result);\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/binary-search/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def binarySearch(arr, x):\n    low = 0\n    high = len(arr) - 1\n    while low <= high:\n        mid = low + (high - low) // 2\n        # Check if x is present at mid\n        if arr[mid] == x:\n            return mid\n        # If x is greater, ignore left half\n        elif arr[mid] < x:\n            low = mid + 1\n        # If x is smaller, ignore right half\n        else:\n            high = mid - 1\n    # If we reach here, then the element\n    # was not present\n    return -1\nif __name__ == '__main__':\n    arr = [2, 3, 4, 10, 40]\n    x = 10\n    result = binarySearch(arr, x)\n    if result != -1:\n        print(\"Element is present at index\", result)\n    else:\n        print(\"Element is not present in array\")",
    "code_without_comments": "def binarySearch(arr, x):\n    low = 0\n    high = len(arr) - 1\n    while low <= high:\n        mid = low + (high - low) // 2\n\n        if arr[mid] == x:\n            return mid\n\n        elif arr[mid] < x:\n            low = mid + 1\n\n        else:\n            high = mid - 1\n\n\n    return -1\nif __name__ == '__main__':\n    arr = [2, 3, 4, 10, 40]\n    x = 10\n    result = binarySearch(arr, x)\n    if result != -1:\n        print(\"Element is present at index\", result)\n    else:\n        print(\"Element is not present in array\")",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/binary-search/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\n// A recursive binary search function. It returns\n// location of x in given array arr[low..high] is present,\n// otherwise -1\nint binarySearch(vector<int> &arr, int low, int high, int x) {\n    if (high >= low) {\n        int mid = low + (high - low) / 2;\n        // If the element is present at the middle\n        // itself\n        if (arr[mid] == x)\n            return mid;\n        // If element is smaller than mid, then\n        // it can only be present in left subarray\n        if (arr[mid] > x)\n            return binarySearch(arr, low, mid - 1, x);\n        // Else the element can only be present\n        // in right subarray\n        return binarySearch(arr, mid + 1, high, x);\n    }\n  return -1;\n}\nint main() {\n    vector<int> arr = { 2, 3, 4, 10, 40 };\n    int query = 10;\n    int n = arr.size();\n    int result = binarySearch(arr, 0, n - 1, query);\n    if (result == -1) cout << \"Element is not present in array\";\n    else cout << \"Element is present at index \" << result;\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n\n\nint binarySearch(vector<int> &arr, int low, int high, int x) {\n    if (high >= low) {\n        int mid = low + (high - low) / 2;\n\n\n        if (arr[mid] == x)\n            return mid;\n\n\n        if (arr[mid] > x)\n            return binarySearch(arr, low, mid - 1, x);\n\n\n        return binarySearch(arr, mid + 1, high, x);\n    }\n  return -1;\n}\nint main() {\n    vector<int> arr = { 2, 3, 4, 10, 40 };\n    int query = 10;\n    int n = arr.size();\n    int result = binarySearch(arr, 0, n - 1, query);\n    if (result == -1) cout << \"Element is not present in array\";\n    else cout << \"Element is present at index \" << result;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/binary-search/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <stdio.h>\n// A recursive binary search function. It returns\n// location of x in given array arr[low..high] is present,\n// otherwise -1\nint binarySearch(int arr[], int low, int high, int x) {\n    if (high >= low) {\n        int mid = low + (high - low) / 2;\n        // If the element is present at the middle\n        // itself\n        if (arr[mid] == x)\n            return mid;\n        // If element is smaller than mid, then\n        // it can only be present in left subarray\n        if (arr[mid] > x)\n            return binarySearch(arr, low, mid - 1, x);\n        // Else the element can only be present\n        // in right subarray\n        return binarySearch(arr, mid + 1, high, x);\n    }\n    // We reach here when element is not\n    // present in array\n    return -1;\n}\nint main()\n{\n    int arr[] = { 2, 3, 4, 10, 40 };\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int x = 10;\n    int result = binarySearch(arr, 0, n - 1, x);\n    if (result == -1) printf(\"Element is not present in array\");\n    else printf(\"Element is present at index %d\", result);\n    return 0;\n}",
    "code_without_comments": "#include <stdio.h>\n\n\n\nint binarySearch(int arr[], int low, int high, int x) {\n    if (high >= low) {\n        int mid = low + (high - low) / 2;\n\n\n        if (arr[mid] == x)\n            return mid;\n\n\n        if (arr[mid] > x)\n            return binarySearch(arr, low, mid - 1, x);\n\n\n        return binarySearch(arr, mid + 1, high, x);\n    }\n\n\n    return -1;\n}\nint main()\n{\n    int arr[] = { 2, 3, 4, 10, 40 };\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int x = 10;\n    int result = binarySearch(arr, 0, n - 1, x);\n    if (result == -1) printf(\"Element is not present in array\");\n    else printf(\"Element is present at index %d\", result);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/binary-search/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "# A recursive binary search function. It returns\n# location of x in given array arr[low..high] is present,\n# otherwise -1\ndef binarySearch(arr, low, high, x):\n    # Check base case\n    if high >= low:\n        mid = low + (high - low) // 2\n        # If element is present at the middle itself\n        if arr[mid] == x:\n            return mid\n        # If element is smaller than mid, then it\n        # can only be present in left subarray\n        elif arr[mid] > x:\n            return binarySearch(arr, low, mid-1, x)\n        # Else the element can only be present\n        # in right subarray\n        else:\n            return binarySearch(arr, mid + 1, high, x)\n    # Element is not present in the array\n    else:\n        return -1\nif __name__ == '__main__':\n    arr = [2, 3, 4, 10, 40]\n    x = 10\n    result = binarySearch(arr, 0, len(arr)-1, x)\n    if result != -1:\n        print(\"Element is present at index\", result)\n    else:\n        print(\"Element is not present in array\")",
    "code_without_comments": "\n\n\ndef binarySearch(arr, low, high, x):\n\n    if high >= low:\n        mid = low + (high - low) // 2\n\n        if arr[mid] == x:\n            return mid\n\n\n        elif arr[mid] > x:\n            return binarySearch(arr, low, mid-1, x)\n\n\n        else:\n            return binarySearch(arr, mid + 1, high, x)\n\n    else:\n        return -1\nif __name__ == '__main__':\n    arr = [2, 3, 4, 10, 40]\n    x = 10\n    result = binarySearch(arr, 0, len(arr)-1, x)\n    if result != -1:\n        print(\"Element is present at index\", result)\n    else:\n        print(\"Element is not present in array\")",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/binary-search/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nint search(vector<int>& arr, int x) {\n    // Iterate over the array in order to\n    // find the key x\n    for (int i = 0; i < arr.size(); i++)\n        if (arr[i] == x)\n            return i;\n    return -1;\n}\nint main() {\n    vector<int> arr = {2, 3, 4, 10, 40};\n    int x = 10;\n    int res = search(arr, x);\n    if (res == -1)\n       cout << \"Element is not present in the array\";\n    else\n       cout << \"Element is present at index \" << res;\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nint search(vector<int>& arr, int x) {\n\n\n    for (int i = 0; i < arr.size(); i++)\n        if (arr[i] == x)\n            return i;\n    return -1;\n}\nint main() {\n    vector<int> arr = {2, 3, 4, 10, 40};\n    int x = 10;\n    int res = search(arr, x);\n    if (res == -1)\n       cout << \"Element is not present in the array\";\n    else\n       cout << \"Element is present at index \" << res;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/linear-search/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <stdio.h>\nint search(int arr[], int n, int x) {\n    // Iterate over the array in order to\n    // find the key x\n    for (int i = 0; i < n; i++)\n        if (arr[i] == x)\n            return i;\n    return -1;\n}\n// Driver code\nint main(void) {\n    int arr[] = { 2, 3, 4, 10, 40 };\n    int x = 10;\n    int n = sizeof(arr) / sizeof(arr[0]);\n    // Function call\n    int result = search(arr, n, x);\n    (result == -1)\n        ? printf(\"Element is not present in array\")\n        : printf(\"Element is present at index %d\", result);\n    return 0;\n}",
    "code_without_comments": "#include <stdio.h>\nint search(int arr[], int n, int x) {\n\n\n    for (int i = 0; i < n; i++)\n        if (arr[i] == x)\n            return i;\n    return -1;\n}\n\nint main(void) {\n    int arr[] = { 2, 3, 4, 10, 40 };\n    int x = 10;\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    int result = search(arr, n, x);\n    (result == -1)\n        ? printf(\"Element is not present in array\")\n        : printf(\"Element is present at index %d\", result);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/linear-search/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def search(arr, x):\n    n = len(arr)\n    # Iterate over the array in order to\n    # find the key x\n    for i in range(0, n):\n        if (arr[i] == x):\n            return i\n    return -1\nif __name__ == \"__main__\":\n    arr = [2, 3, 4, 10, 40]\n    x = 10\n    result = search(arr, x)\n    if(result == -1):\n        print(\"Element is not present in array\")\n    else:\n        print(\"Element is present at index\", result)",
    "code_without_comments": "def search(arr, x):\n    n = len(arr)\n\n\n    for i in range(0, n):\n        if (arr[i] == x):\n            return i\n    return -1\nif __name__ == \"__main__\":\n    arr = [2, 3, 4, 10, 40]\n    x = 10\n    result = search(arr, x)\n    if(result == -1):\n        print(\"Element is not present in array\")\n    else:\n        print(\"Element is present at index\", result)",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/linear-search/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nint findMinIndex(vector<int>& arr) {\n    int low = 0, high = arr.size() - 1;\n    int minIndex = -1;\n    while (low <= high) {\n        // divide the range into three parts\n        int mid1 = low + (high - low) / 3;\n        int mid2 = high - (high - low) / 3;\n        // if both mid1 and mid2 point to equal\n        // values narrow the search\n        if (arr[mid1] == arr[mid2]) {\n            // Move towards the center\n            low = mid1 + 1;\n            high = mid2 - 1;\n            // tentatively store mid1 as\n            // potential minimum\n            minIndex = mid1;\n        }\n        // if arr[mid1] < arr[mid2], the minimum lies in the\n        // left part (including mid1)\n        else if (arr[mid1] < arr[mid2]) {\n            high = mid2 - 1;\n            // update with better candidate\n            minIndex = mid1;\n        }\n        // is arr[mid1] > arr[mid2], the minimum lies in the\n        // right part (including mid2)\n        else {\n            low = mid1 + 1;\n            // update with better candidate\n            minIndex = mid2;\n        }\n    }\n    return minIndex;\n}\nint main() {\n    vector<int> arr = {9, 7, 1, 2, 3, 6, 10};\n    int idx = findMinIndex(arr);\n    cout << idx << endl;\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nint findMinIndex(vector<int>& arr) {\n    int low = 0, high = arr.size() - 1;\n    int minIndex = -1;\n    while (low <= high) {\n\n        int mid1 = low + (high - low) / 3;\n        int mid2 = high - (high - low) / 3;\n\n\n        if (arr[mid1] == arr[mid2]) {\n\n            low = mid1 + 1;\n            high = mid2 - 1;\n\n\n            minIndex = mid1;\n        }\n\n\n        else if (arr[mid1] < arr[mid2]) {\n            high = mid2 - 1;\n\n            minIndex = mid1;\n        }\n\n\n        else {\n            low = mid1 + 1;\n\n            minIndex = mid2;\n        }\n    }\n    return minIndex;\n}\nint main() {\n    vector<int> arr = {9, 7, 1, 2, 3, 6, 10};\n    int idx = findMinIndex(arr);\n    cout << idx << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/ternary-search/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <stdio.h>\n// Function to find the index of the minimum element\nint findMinIndex(int arr[], int n) {\n    int low = 0, high = n - 1;\n    int minIndex = -1;\n    while (low <= high) {\n        // divide the range into three parts\n        int mid1 = low + (high - low) / 3;\n        int mid2 = high - (high - low) / 3;\n        // if both mid1 and mid2 point to equal\n        // values narrow the search\n        if (arr[mid1] == arr[mid2]) {\n            // Move towards the center\n            low = mid1 + 1;\n            high = mid2 - 1;\n            // tentatively store mid1 as\n            // potential minimum\n            minIndex = mid1;\n        }\n        // if arr[mid1] < arr[mid2], the minimum lies in the\n        // left part (including mid1)\n        else if (arr[mid1] < arr[mid2]) {\n            high = mid2 - 1;\n            // update with better candidate\n            minIndex = mid1;\n        }\n        // is arr[mid1] > arr[mid2], the minimum lies in the\n        // right part (including mid2)\n        else {\n            low = mid1 + 1;\n            // update with better candidate\n            minIndex = mid2;\n        }\n    }\n    return minIndex;\n}\nint main() {\n    int arr[] = {9, 7, 1, 2, 3, 6, 10};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int idx = findMinIndex(arr, n);\n    printf(\"%d\\n\", idx);\n    return 0;\n}",
    "code_without_comments": "#include <stdio.h>\n\nint findMinIndex(int arr[], int n) {\n    int low = 0, high = n - 1;\n    int minIndex = -1;\n    while (low <= high) {\n\n        int mid1 = low + (high - low) / 3;\n        int mid2 = high - (high - low) / 3;\n\n\n        if (arr[mid1] == arr[mid2]) {\n\n            low = mid1 + 1;\n            high = mid2 - 1;\n\n\n            minIndex = mid1;\n        }\n\n\n        else if (arr[mid1] < arr[mid2]) {\n            high = mid2 - 1;\n\n            minIndex = mid1;\n        }\n\n\n        else {\n            low = mid1 + 1;\n\n            minIndex = mid2;\n        }\n    }\n    return minIndex;\n}\nint main() {\n    int arr[] = {9, 7, 1, 2, 3, 6, 10};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int idx = findMinIndex(arr, n);\n    printf(\"%d\\n\", idx);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/ternary-search/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def findMinIndex(arr):\n    low = 0\n    high = len(arr) - 1\n    minIndex = -1\n    while low <= high:\n        # divide the range into three parts\n        mid1 = low + (high - low) // 3\n        mid2 = high - (high - low) // 3\n        # if both mid1 and mid2 point to equal\n        # values narrow the search\n        if arr[mid1] == arr[mid2]:\n            # Move towards the center\n            low = mid1 + 1\n            high = mid2 - 1\n            # tentatively store mid1 as\n            # potential minimum\n            minIndex = mid1\n        # if arr[mid1] < arr[mid2], the minimum lies in the\n        # left part (including mid1)\n        elif arr[mid1] < arr[mid2]:\n            high = mid2 - 1\n            # update with better candidate\n            minIndex = mid1\n        # is arr[mid1] > arr[mid2], the minimum lies in the\n        # right part (including mid2)\n        else:\n            low = mid1 + 1\n            # update with better candidate\n            minIndex = mid2\n    return minIndex\ndef main():\n    arr = [9, 7, 1, 2, 3, 6, 10]\n    idx = findMinIndex(arr)\n    print(idx)",
    "code_without_comments": "def findMinIndex(arr):\n    low = 0\n    high = len(arr) - 1\n    minIndex = -1\n    while low <= high:\n\n        mid1 = low + (high - low) // 3\n        mid2 = high - (high - low) // 3\n\n\n        if arr[mid1] == arr[mid2]:\n\n            low = mid1 + 1\n            high = mid2 - 1\n\n\n            minIndex = mid1\n\n\n        elif arr[mid1] < arr[mid2]:\n            high = mid2 - 1\n\n            minIndex = mid1\n\n\n        else:\n            low = mid1 + 1\n\n            minIndex = mid2\n    return minIndex\ndef main():\n    arr = [9, 7, 1, 2, 3, 6, 10]\n    idx = findMinIndex(arr)\n    print(idx)",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/ternary-search/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n//Driver Code Ends\n// BFS for single connected component\nvector<int> bfs(vector<vector<int>>& adj) {\n    int V = adj.size();\n    vector<bool> visited(V, false);\n    vector<int> res;\n    queue<int> q;\n    int src = 0;\n    visited[src] = true;\n    q.push(src);\n    while (!q.empty()) {\n        int curr = q.front();\n        q.pop();\n        res.push_back(curr);\n        // visit all the unvisited\n        // neighbours of current node\n        for (int x : adj[curr]) {\n            if (!visited[x]) {\n                visited[x] = true;\n                q.push(x);\n            }\n        }\n    }\n    return res;\n}\n//Driver Code Starts\nvoid addEdge(vector<vector<int>>& adj, int u, int v) {\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n}\nint main() {\n    int V = 5;\n    vector<vector<int>> adj(V);\n    // creating adjacency list\n    addEdge(adj, 1, 2);\n    addEdge(adj, 1, 0);\n    addEdge(adj, 2, 0);\n    addEdge(adj, 2, 3);\n    addEdge(adj, 2, 4);\n    vector<int> res = bfs(adj);\n    for (int i : res)\n        cout << i << \" \";\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n\nvector<int> bfs(vector<vector<int>>& adj) {\n    int V = adj.size();\n    vector<bool> visited(V, false);\n    vector<int> res;\n    queue<int> q;\n    int src = 0;\n    visited[src] = true;\n    q.push(src);\n    while (!q.empty()) {\n        int curr = q.front();\n        q.pop();\n        res.push_back(curr);\n\n\n        for (int x : adj[curr]) {\n            if (!visited[x]) {\n                visited[x] = true;\n                q.push(x);\n            }\n        }\n    }\n    return res;\n}\n\nvoid addEdge(vector<vector<int>>& adj, int u, int v) {\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n}\nint main() {\n    int V = 5;\n    vector<vector<int>> adj(V);\n\n    addEdge(adj, 1, 2);\n    addEdge(adj, 1, 0);\n    addEdge(adj, 2, 0);\n    addEdge(adj, 2, 3);\n    addEdge(adj, 2, 4);\n    vector<int> res = bfs(adj);\n    for (int i : res)\n        cout << i << \" \";\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <stdio.h>\n#define V 5\n#define MAXQ 100\n//Driver Code Ends\n// BFS for single connected component\nvoid bfs(int adj[V][V], int res[V], int *resSize) {\n    int visited[V] = {0};\n    int q[MAXQ];\n    int front = 0, rear = 0;\n    int src = 0;\n    visited[src] = 1;\n    q[rear++] = src;\n    while (front < rear) {\n        int curr = q[front++];\n        res[(*resSize)++] = curr;\n        // visit all the unvisited\n        // neighbours of current node\n        for (int x = 0; x < V; x++) {\n            if (adj[curr][x] && !visited[x]) {\n                visited[x] = 1;\n                q[rear++] = x;\n            }\n        }\n    }\n}\n//Driver Code Starts\nvoid addEdge(int adj[V][V], int u, int v) {\n    adj[u][v] = 1;\n    adj[v][u] = 1;  // undirected\n}\nint main() {\n    int adj[V][V] = {0};\n    // creating adjacency list\n    addEdge(adj, 1, 2);\n    addEdge(adj, 1, 0);\n    addEdge(adj, 2, 0);\n    addEdge(adj, 2, 3);\n    addEdge(adj, 2, 4);\n    int res[V];\n    int resSize = 0;\n    bfs(adj, res, &resSize);\n    for (int i = 0; i < resSize; i++)\n        printf(\"%d \", res[i]);\n    return 0;\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <stdio.h>\n#define V 5\n#define MAXQ 100\n\n\nvoid bfs(int adj[V][V], int res[V], int *resSize) {\n    int visited[V] = {0};\n    int q[MAXQ];\n    int front = 0, rear = 0;\n    int src = 0;\n    visited[src] = 1;\n    q[rear++] = src;\n    while (front < rear) {\n        int curr = q[front++];\n        res[(*resSize)++] = curr;\n\n\n        for (int x = 0; x < V; x++) {\n            if (adj[curr][x] && !visited[x]) {\n                visited[x] = 1;\n                q[rear++] = x;\n            }\n        }\n    }\n}\n\nvoid addEdge(int adj[V][V], int u, int v) {\n    adj[u][v] = 1;\n    adj[v][u] = 1;\n}\nint main() {\n    int adj[V][V] = {0};\n\n    addEdge(adj, 1, 2);\n    addEdge(adj, 1, 0);\n    addEdge(adj, 2, 0);\n    addEdge(adj, 2, 3);\n    addEdge(adj, 2, 4);\n    int res[V];\n    int resSize = 0;\n    bfs(adj, res, &resSize);\n    for (int i = 0; i < resSize; i++)\n        printf(\"%d \", res[i]);\n    return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#Driver Code Starts\nfrom collections import deque\n#Driver Code Ends\n# BFS for single connected component\ndef bfs(adj):\n    V = len(adj)\n    visited = [False] * V\n    res = []\n    src = 0\n    q = deque()\n    visited[src] = True\n    q.append(src)\n    while q:\n        curr = q.popleft()\n        res.append(curr)\n        # visit all the unvisited\n        # neighbours of current node\n        for x in adj[curr]:\n            if not visited[x]:\n                visited[x] = True\n                q.append(x)\n    return res\n#Driver Code Starts\ndef addEdge(adj, u, v):\n    adj[u].append(v)\n    adj[v].append(u)\nif __name__ == \"__main__\":\n    V = 5\n    adj = []\n    # creating adjacency list\n    for i in range(V):\n        adj.append([])\n    addEdge(adj, 1, 2)\n    addEdge(adj, 1, 0)\n    addEdge(adj, 2, 0)\n    addEdge(adj, 2, 3)\n    addEdge(adj, 2, 4)\n    res = bfs(adj)\n    for node in res:\n        print(node, end=\" \")\n#Driver Code Ends",
    "code_without_comments": "\nfrom collections import deque\n\n\ndef bfs(adj):\n    V = len(adj)\n    visited = [False] * V\n    res = []\n    src = 0\n    q = deque()\n    visited[src] = True\n    q.append(src)\n    while q:\n        curr = q.popleft()\n        res.append(curr)\n\n\n        for x in adj[curr]:\n            if not visited[x]:\n                visited[x] = True\n                q.append(x)\n    return res\n\ndef addEdge(adj, u, v):\n    adj[u].append(v)\n    adj[v].append(u)\nif __name__ == \"__main__\":\n    V = 5\n    adj = []\n\n    for i in range(V):\n        adj.append([])\n    addEdge(adj, 1, 2)\n    addEdge(adj, 1, 0)\n    addEdge(adj, 2, 0)\n    addEdge(adj, 2, 3)\n    addEdge(adj, 2, 4)\n    res = bfs(adj)\n    for node in res:\n        print(node, end=\" \")\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n//Driver Code Ends\n// BFS for a single connected component\nvoid bfsConnected(vector<vector<int>>& adj, int src, vector<bool>& visited, vector<int>& res) {\n    queue<int> q;\n    visited[src] = true;\n    q.push(src);\n    while (!q.empty()) {\n        int curr = q.front();\n        q.pop();\n        res.push_back(curr);\n        // visit all the unvisited\n        // neighbours of current node\n        for (int x : adj[curr]) {\n            if (!visited[x]) {\n                visited[x] = true;\n                q.push(x);\n            }\n        }\n    }\n}\n// BFS for all components (handles disconnected graphs)\nvector<int> bfs(vector<vector<int>>& adj) {\n    int V = adj.size();\n    vector<bool> visited(V, false);\n    vector<int> res;\n    for (int i = 0; i < V; i++) {\n        if (!visited[i])\n            bfsConnected(adj, i, visited, res);\n    }\n    return res;\n}\n//Driver Code Starts\nvoid addEdge(vector<vector<int>>& adj, int u, int v) {\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n}\nint main() {\n    int V = 6;\n    vector<vector<int>> adj(V);\n    // creating adjacency list\n    addEdge(adj, 1, 2);\n    addEdge(adj, 2, 0);\n    addEdge(adj, 0, 3);\n    addEdge(adj, 4, 5);\n    vector<int> res = bfs(adj);\n    for (int i : res)\n        cout << i << \" \";\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n\nvoid bfsConnected(vector<vector<int>>& adj, int src, vector<bool>& visited, vector<int>& res) {\n    queue<int> q;\n    visited[src] = true;\n    q.push(src);\n    while (!q.empty()) {\n        int curr = q.front();\n        q.pop();\n        res.push_back(curr);\n\n\n        for (int x : adj[curr]) {\n            if (!visited[x]) {\n                visited[x] = true;\n                q.push(x);\n            }\n        }\n    }\n}\n\nvector<int> bfs(vector<vector<int>>& adj) {\n    int V = adj.size();\n    vector<bool> visited(V, false);\n    vector<int> res;\n    for (int i = 0; i < V; i++) {\n        if (!visited[i])\n            bfsConnected(adj, i, visited, res);\n    }\n    return res;\n}\n\nvoid addEdge(vector<vector<int>>& adj, int u, int v) {\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n}\nint main() {\n    int V = 6;\n    vector<vector<int>> adj(V);\n\n    addEdge(adj, 1, 2);\n    addEdge(adj, 2, 0);\n    addEdge(adj, 0, 3);\n    addEdge(adj, 4, 5);\n    vector<int> res = bfs(adj);\n    for (int i : res)\n        cout << i << \" \";\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <stdio.h>\n#define V 6\n#define MAXQ 100\n//Driver Code Ends\n// BFS for a single connected component\nvoid bfsConnected(int adj[V][V], int src, int visited[V], int res[V], int *resSize) {\n    int q[MAXQ];\n    int front = 0, rear = 0;\n    visited[src] = 1;\n    q[rear++] = src;\n    while (front < rear) {\n        int curr = q[front++];\n        res[(*resSize)++] = curr;\n        // visit all the unvisited\n        // neighbours of current node\n        for (int x = 0; x < V; x++) {\n            if (adj[curr][x] && !visited[x]) {\n                visited[x] = 1;\n                q[rear++] = x;\n            }\n        }\n    }\n}\n// BFS for all components (handles disconnected graphs)\nvoid bfs(int adj[V][V], int res[V], int *resSize) {\n    int visited[V] = {0};\n    for (int i = 0; i < V; i++) {\n        if (!visited[i])\n            bfsConnected(adj, i, visited, res, resSize);\n    }\n}\n//Driver Code Starts\nvoid addEdge(int adj[V][V], int u, int v) {\n    adj[u][v] = 1;\n    adj[v][u] = 1;\n}\nint main() {\n    int adj[V][V] = {0};\n    addEdge(adj, 1, 2);\n    addEdge(adj, 2, 0);\n    addEdge(adj, 0, 3);\n    addEdge(adj, 4, 5);\n    int res[V];\n    int resSize = 0;\n    bfs(adj, res, &resSize);\n    for (int i = 0; i < resSize; i++)\n        printf(\"%d \", res[i]);\n    return 0;\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <stdio.h>\n#define V 6\n#define MAXQ 100\n\n\nvoid bfsConnected(int adj[V][V], int src, int visited[V], int res[V], int *resSize) {\n    int q[MAXQ];\n    int front = 0, rear = 0;\n    visited[src] = 1;\n    q[rear++] = src;\n    while (front < rear) {\n        int curr = q[front++];\n        res[(*resSize)++] = curr;\n\n\n        for (int x = 0; x < V; x++) {\n            if (adj[curr][x] && !visited[x]) {\n                visited[x] = 1;\n                q[rear++] = x;\n            }\n        }\n    }\n}\n\nvoid bfs(int adj[V][V], int res[V], int *resSize) {\n    int visited[V] = {0};\n    for (int i = 0; i < V; i++) {\n        if (!visited[i])\n            bfsConnected(adj, i, visited, res, resSize);\n    }\n}\n\nvoid addEdge(int adj[V][V], int u, int v) {\n    adj[u][v] = 1;\n    adj[v][u] = 1;\n}\nint main() {\n    int adj[V][V] = {0};\n    addEdge(adj, 1, 2);\n    addEdge(adj, 2, 0);\n    addEdge(adj, 0, 3);\n    addEdge(adj, 4, 5);\n    int res[V];\n    int resSize = 0;\n    bfs(adj, res, &resSize);\n    for (int i = 0; i < resSize; i++)\n        printf(\"%d \", res[i]);\n    return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#Driver Code Starts\nfrom collections import deque\n#Driver Code Ends\n# BFS for a single connected component\ndef bfsConnected(adj, src, visited, res):\n    q = deque()\n    visited[src] = True\n    q.append(src)\n    while q:\n        curr = q.popleft()\n        res.append(curr)\n        # visit all the unvisited\n        # neighbours of current node\n        for x in adj[curr]:\n            if not visited[x]:\n                visited[x] = True\n                q.append(x)\n# BFS for all components (handles disconnected graphs)\ndef bfs(adj):\n    V = len(adj)\n    visited = [False] * V\n    res = []\n    for i in range(V):\n        if not visited[i]:\n            bfsConnected(adj, i, visited, res)\n    return res\n#Driver Code Starts\ndef addEdge(adj, u, v):\n    adj[u].append(v)\n    adj[v].append(u)\nif __name__ == \"__main__\":\n    V = 6\n    adj = []\n    # creating adjacency list\n    for i in range(V):\n        adj.append([])\n    addEdge(adj, 1, 2)\n    addEdge(adj, 2, 0)\n    addEdge(adj, 0, 3)\n    addEdge(adj, 4, 5)\n    res = bfs(adj)\n    for node in res:\n        print(node, end=\" \")\n#Driver Code Ends",
    "code_without_comments": "\nfrom collections import deque\n\n\ndef bfsConnected(adj, src, visited, res):\n    q = deque()\n    visited[src] = True\n    q.append(src)\n    while q:\n        curr = q.popleft()\n        res.append(curr)\n\n\n        for x in adj[curr]:\n            if not visited[x]:\n                visited[x] = True\n                q.append(x)\n\ndef bfs(adj):\n    V = len(adj)\n    visited = [False] * V\n    res = []\n    for i in range(V):\n        if not visited[i]:\n            bfsConnected(adj, i, visited, res)\n    return res\n\ndef addEdge(adj, u, v):\n    adj[u].append(v)\n    adj[v].append(u)\nif __name__ == \"__main__\":\n    V = 6\n    adj = []\n\n    for i in range(V):\n        adj.append([])\n    addEdge(adj, 1, 2)\n    addEdge(adj, 2, 0)\n    addEdge(adj, 0, 3)\n    addEdge(adj, 4, 5)\n    res = bfs(adj)\n    for node in res:\n        print(node, end=\" \")\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <iostream>\n#include <vector>\nusing namespace std;\n//Driver Code Ends\nvoid dfsRec(vector<vector<int>> &adj,\nvector<bool> &visited, int s, vector<int> &res) {\n    visited[s] = true;\n    res.push_back(s);\n    // Recursively visit all adjacent vertices\n    // that are not visited yet\n    for (int i : adj[s])\n        if (visited[i] == false)\n            dfsRec(adj, visited, i, res);\n}\nvector<int> dfs(vector<vector<int>> &adj) {\n    vector<bool> visited(adj.size(), false);\n    vector<int> res;\n    dfsRec(adj, visited, 0, res);\n    return res;\n}\n//Driver Code Starts\nvoid addEdge(vector<vector<int>>& adj, int u, int v) {\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n}\nint main() {\n    int V = 5;\n    vector<vector<int>> adj(V);\n    // creating adjacency list\n    addEdge(adj, 1, 2);\n    addEdge(adj, 1, 0);\n    addEdge(adj, 2, 0);\n    addEdge(adj, 2, 3);\n    addEdge(adj, 2, 4);\n    // Perform DFS starting from the source vertex 0\n    vector<int> res = dfs(adj);\n    for (int i = 0; i < V; i++)\n        cout << res[i] << \" \";\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid dfsRec(vector<vector<int>> &adj,\nvector<bool> &visited, int s, vector<int> &res) {\n    visited[s] = true;\n    res.push_back(s);\n\n\n    for (int i : adj[s])\n        if (visited[i] == false)\n            dfsRec(adj, visited, i, res);\n}\nvector<int> dfs(vector<vector<int>> &adj) {\n    vector<bool> visited(adj.size(), false);\n    vector<int> res;\n    dfsRec(adj, visited, 0, res);\n    return res;\n}\n\nvoid addEdge(vector<vector<int>>& adj, int u, int v) {\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n}\nint main() {\n    int V = 5;\n    vector<vector<int>> adj(V);\n\n    addEdge(adj, 1, 2);\n    addEdge(adj, 1, 0);\n    addEdge(adj, 2, 0);\n    addEdge(adj, 2, 3);\n    addEdge(adj, 2, 4);\n\n    vector<int> res = dfs(adj);\n    for (int i = 0; i < V; i++)\n        cout << res[i] << \" \";\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <stdio.h>\n#define V 5\n//Driver Code Ends\nvoid dfsRec(int adj[V][V], int visited[V], int s, int res[V], int *idx) {\n    visited[s] = 1;\n    res[(*idx)++] = s;\n    // Recursively visit all adjacent vertices\n    // that are not visited yet\n    for (int i = 0; i < V; i++) {\n        if (adj[s][i] && visited[i] == 0)\n            dfsRec(adj, visited, i, res, idx);\n    }\n}\nvoid dfs(int adj[V][V], int res[V]) {\n    int visited[V] = {0};\n    int idx = 0;\n    dfsRec(adj, visited, 0, res, &idx);\n}\n//Driver Code Starts\nvoid addEdge(int adj[V][V], int u, int v) {\n    adj[u][v] = 1;\n    adj[v][u] = 1;  // undirected\n}\nint main() {\n    int adj[V][V] = {0};\n    // creating adjacency list\n    addEdge(adj, 1, 2);\n    addEdge(adj, 1, 0);\n    addEdge(adj, 2, 0);\n    addEdge(adj, 2, 3);\n    addEdge(adj, 2, 4);\n    int res[V];\n    // Perform DFS starting from the source vertex 0\n    dfs(adj, res);\n    for (int i = 0; i < V; i++)\n        printf(\"%d \", res[i]);\n    return 0;\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <stdio.h>\n#define V 5\n\nvoid dfsRec(int adj[V][V], int visited[V], int s, int res[V], int *idx) {\n    visited[s] = 1;\n    res[(*idx)++] = s;\n\n\n    for (int i = 0; i < V; i++) {\n        if (adj[s][i] && visited[i] == 0)\n            dfsRec(adj, visited, i, res, idx);\n    }\n}\nvoid dfs(int adj[V][V], int res[V]) {\n    int visited[V] = {0};\n    int idx = 0;\n    dfsRec(adj, visited, 0, res, &idx);\n}\n\nvoid addEdge(int adj[V][V], int u, int v) {\n    adj[u][v] = 1;\n    adj[v][u] = 1;\n}\nint main() {\n    int adj[V][V] = {0};\n\n    addEdge(adj, 1, 2);\n    addEdge(adj, 1, 0);\n    addEdge(adj, 2, 0);\n    addEdge(adj, 2, 3);\n    addEdge(adj, 2, 4);\n    int res[V];\n\n    dfs(adj, res);\n    for (int i = 0; i < V; i++)\n        printf(\"%d \", res[i]);\n    return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "def dfsRec(adj, visited, s, res):\n    visited[s] = True\n    res.append(s)\n    # Recursively visit all adjacent vertices\n    # that are not visited yet\n    for i in adj[s]:\n        if not visited[i]:\n            dfsRec(adj, visited, i, res)\ndef dfs(adj):\n    visited = [False] * len(adj)\n    res = []\n    dfsRec(adj, visited, 0, res)\n    return res\n#Driver Code Starts\ndef addEdge(adj, u, v):\n    adj[u].append(v)\n    adj[v].append(u)\nif __name__ == \"__main__\":\n    V = 5\n    adj = []\n    # creating adjacency list\n    for i in range(V):\n        adj.append([])\n    addEdge(adj, 1, 2)\n    addEdge(adj, 1, 0)\n    addEdge(adj, 2, 0)\n    addEdge(adj, 2, 3)\n    addEdge(adj, 2, 4)\n    # Perform DFS starting from vertex 0\n    res = dfs(adj)\n    for node in res:\n        print(node, end=\" \")\n#Driver Code Ends",
    "code_without_comments": "def dfsRec(adj, visited, s, res):\n    visited[s] = True\n    res.append(s)\n\n\n    for i in adj[s]:\n        if not visited[i]:\n            dfsRec(adj, visited, i, res)\ndef dfs(adj):\n    visited = [False] * len(adj)\n    res = []\n    dfsRec(adj, visited, 0, res)\n    return res\n\ndef addEdge(adj, u, v):\n    adj[u].append(v)\n    adj[v].append(u)\nif __name__ == \"__main__\":\n    V = 5\n    adj = []\n\n    for i in range(V):\n        adj.append([])\n    addEdge(adj, 1, 2)\n    addEdge(adj, 1, 0)\n    addEdge(adj, 2, 0)\n    addEdge(adj, 2, 3)\n    addEdge(adj, 2, 4)\n\n    res = dfs(adj)\n    for node in res:\n        print(node, end=\" \")\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <iostream>\n#include <vector>\nusing namespace std;\n//Driver Code Ends\nvoid dfsRec(vector<vector<int>> &adj,\nvector<bool> &visited, int s, vector<int> &res) {\n    visited[s] = true;\n    res.push_back(s);\n    // Recursively visit all adjacent\n    // vertices that are not visited yet\n    for (int i : adj[s])\n        if (visited[i] == false)\n            dfsRec(adj, visited, i, res);\n}\nvector<int> dfs(vector<vector<int>> &adj) {\n    vector<bool> visited(adj.size(), false);\n    vector<int> res;\n    // Loop through all vertices\n    // to handle disconnected graph\n    for (int i = 0; i < adj.size(); i++) {\n        if (visited[i] == false) {\n            dfsRec(adj, visited, i, res);\n        }\n    }\n    return res;\n}\n//Driver Code Starts\nvoid addEdge(vector<vector<int>>& adj, int u, int v) {\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n}\nint main() {\n    int V = 6;\n    vector<vector<int>> adj(V);\n    // creating adjacency list\n    addEdge(adj, 1, 2);\n    addEdge(adj, 0, 3);\n    addEdge(adj, 2, 0);\n    addEdge(adj, 5, 4);\n    vector<int> res = dfs(adj);\n    for (auto it : res)\n        cout << it << \" \";\n    return 0;\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid dfsRec(vector<vector<int>> &adj,\nvector<bool> &visited, int s, vector<int> &res) {\n    visited[s] = true;\n    res.push_back(s);\n\n\n    for (int i : adj[s])\n        if (visited[i] == false)\n            dfsRec(adj, visited, i, res);\n}\nvector<int> dfs(vector<vector<int>> &adj) {\n    vector<bool> visited(adj.size(), false);\n    vector<int> res;\n\n\n    for (int i = 0; i < adj.size(); i++) {\n        if (visited[i] == false) {\n            dfsRec(adj, visited, i, res);\n        }\n    }\n    return res;\n}\n\nvoid addEdge(vector<vector<int>>& adj, int u, int v) {\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n}\nint main() {\n    int V = 6;\n    vector<vector<int>> adj(V);\n\n    addEdge(adj, 1, 2);\n    addEdge(adj, 0, 3);\n    addEdge(adj, 2, 0);\n    addEdge(adj, 5, 4);\n    vector<int> res = dfs(adj);\n    for (auto it : res)\n        cout << it << \" \";\n    return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <stdio.h>\n#define V 6\n//Driver Code Ends\nvoid dfsRec(int adj[V][V], int visited[V], int s, int res[V], int *idx) {\n    visited[s] = 1;\n    res[(*idx)++] = s;\n    // Recursively visit all adjacent\n    // vertices that are not visited yet\n    for (int i = 0; i < V; i++)\n        if (adj[s][i] && visited[i] == 0)\n            dfsRec(adj, visited, i, res, idx);\n}\nvoid dfs(int adj[V][V], int res[V], int *resSize) {\n    int visited[V] = {0};\n    int idx = 0;\n    // Loop through all vertices\n    // to handle disconnected graph\n    for (int i = 0; i < V; i++) {\n        if (visited[i] == 0) {\n            dfsRec(adj, visited, i, res, &idx);\n        }\n    }\n    *resSize = idx;\n}\n//Driver Code Starts\nvoid addEdge(int adj[V][V], int u, int v) {\n    adj[u][v] = 1;\n    adj[v][u] = 1;  // undirected\n}\nint main() {\n    int adj[V][V] = {0};\n    addEdge(adj, 1, 2);\n    addEdge(adj, 2, 0);\n    addEdge(adj, 0, 3);\n    addEdge(adj, 4, 5);\n    // Perform DFS\n    int res[V];\n    int resSize = 0;\n    dfs(adj, res, &resSize);\n    for (int i = 0; i < resSize; i++)\n        printf(\"%d \", res[i]);\n    return 0;\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <stdio.h>\n#define V 6\n\nvoid dfsRec(int adj[V][V], int visited[V], int s, int res[V], int *idx) {\n    visited[s] = 1;\n    res[(*idx)++] = s;\n\n\n    for (int i = 0; i < V; i++)\n        if (adj[s][i] && visited[i] == 0)\n            dfsRec(adj, visited, i, res, idx);\n}\nvoid dfs(int adj[V][V], int res[V], int *resSize) {\n    int visited[V] = {0};\n    int idx = 0;\n\n\n    for (int i = 0; i < V; i++) {\n        if (visited[i] == 0) {\n            dfsRec(adj, visited, i, res, &idx);\n        }\n    }\n    *resSize = idx;\n}\n\nvoid addEdge(int adj[V][V], int u, int v) {\n    adj[u][v] = 1;\n    adj[v][u] = 1;\n}\nint main() {\n    int adj[V][V] = {0};\n    addEdge(adj, 1, 2);\n    addEdge(adj, 2, 0);\n    addEdge(adj, 0, 3);\n    addEdge(adj, 4, 5);\n\n    int res[V];\n    int resSize = 0;\n    dfs(adj, res, &resSize);\n    for (int i = 0; i < resSize; i++)\n        printf(\"%d \", res[i]);\n    return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#Driver Code Starts\nfrom collections import defaultdict\n#Driver Code Ends\ndef dfsRec(adj, visited, s, res):\n    visited[s] = True\n    res.append(s)\n    # Recursively visit all adjacent\n    # vertices that are not visited yet\n    for i in adj[s]:\n        if not visited[i]:\n            dfsRec(adj, visited, i, res)\ndef dfs(adj):\n    visited = [False] * len(adj)\n    res = []\n    # Loop through all vertices to\n    # handle disconnected graph\n    for i in range(len(adj)):\n        if not visited[i]:\n            dfsRec(adj, visited, i, res)\n    return res\n#Driver Code Starts\ndef addEdge(adj, u, v):\n    adj[u].append(v)\n    adj[v].append(u)\nif __name__ == \"__main__\":\n    V = 6\n    adj = []\n    # creating adjacency list\n    for i in range(V):\n        adj.append([])\n    addEdge(adj, 1, 2)\n    addEdge(adj, 2, 0)\n    addEdge(adj, 0, 3)\n    addEdge(adj, 5, 4)\n    # Perform DFS\n    res = dfs(adj)\n    print(*res)\n#Driver Code Ends",
    "code_without_comments": "\nfrom collections import defaultdict\n\ndef dfsRec(adj, visited, s, res):\n    visited[s] = True\n    res.append(s)\n\n\n    for i in adj[s]:\n        if not visited[i]:\n            dfsRec(adj, visited, i, res)\ndef dfs(adj):\n    visited = [False] * len(adj)\n    res = []\n\n\n    for i in range(len(adj)):\n        if not visited[i]:\n            dfsRec(adj, visited, i, res)\n    return res\n\ndef addEdge(adj, u, v):\n    adj[u].append(v)\n    adj[v].append(u)\nif __name__ == \"__main__\":\n    V = 6\n    adj = []\n\n    for i in range(V):\n        adj.append([])\n    addEdge(adj, 1, 2)\n    addEdge(adj, 2, 0)\n    addEdge(adj, 0, 3)\n    addEdge(adj, 5, 4)\n\n    res = dfs(adj)\n    print(*res)\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n//Driver Code Ends\nvector<int> dijkstra(vector<vector<pair<int,int>>>& adj, int src) {\n    int V = adj.size();\n    // Min-heap (priority queue) storing pairs of (distance, node)\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    vector<int> dist(V, INT_MAX);\n    // Distance from source to itself is 0\n    dist[src] = 0;\n    pq.emplace(0, src);\n    // Process the queue until all reachable vertices are finalized\n    while (!pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        int d = top.first;\n        int u = top.second;\n        // If this distance not the latest shortest one, skip it\n        if (d > dist[u])\n            continue;\n        // Explore all neighbors of the current vertex\n        for (auto &p : adj[u]) {\n            int v = p.first;\n            int w = p.second;\n            // If we found a shorter path to v through u, update it\n            if (dist[u] + w < dist[v]) {\n                dist[v] = dist[u] + w;\n                pq.emplace(dist[v], v);\n            }\n        }\n    }\n    // Return the final shortest distances from the source\n    return dist;\n}\n//Driver Code Starts\nint main() {\n    int src = 0;\n    vector<vector<pair<int,int>>> adj(5);\n    adj[0] = {{1,4}, {2,8}};\n    adj[1] = {{0,4}, {4,6}, {2,3}};\n    adj[2] = {{0,8}, {3,2}, {1,3}};\n    adj[3] = {{2,2}, {4,10}};\n    adj[4] = {{1,6}, {3,10}};\n    vector<int> result = dijkstra(adj, src);\n    for (int d : result)\n        cout << d << \" \";\n    cout << \"\n\";\n    return 0;\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nvector<int> dijkstra(vector<vector<pair<int,int>>>& adj, int src) {\n    int V = adj.size();\n\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    vector<int> dist(V, INT_MAX);\n\n    dist[src] = 0;\n    pq.emplace(0, src);\n\n    while (!pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        int d = top.first;\n        int u = top.second;\n\n        if (d > dist[u])\n            continue;\n\n        for (auto &p : adj[u]) {\n            int v = p.first;\n            int w = p.second;\n\n            if (dist[u] + w < dist[v]) {\n                dist[v] = dist[u] + w;\n                pq.emplace(dist[v], v);\n            }\n        }\n    }\n\n    return dist;\n}\n\nint main() {\n    int src = 0;\n    vector<vector<pair<int,int>>> adj(5);\n    adj[0] = {{1,4}, {2,8}};\n    adj[1] = {{0,4}, {4,6}, {2,3}};\n    adj[2] = {{0,8}, {3,2}, {1,3}};\n    adj[3] = {{2,2}, {4,10}};\n    adj[4] = {{1,6}, {3,10}};\n    vector<int> result = dijkstra(adj, src);\n    for (int d : result)\n        cout << d << \" \";\n    cout << \"\n\";\n    return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/",
    "complexity_weight": 1.0
  }
]