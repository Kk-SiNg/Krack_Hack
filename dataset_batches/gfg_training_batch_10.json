[
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nstring getLongestPal(string s) {\n    int n = s.size();\n    vector<vector<bool>> dp(n, vector<bool>(n, false));\n    // dp[i][j] if the substring  from [i to j]\n    // is a palindrome or not\n    int start = 0, maxLen = 1;\n    // all substrings of length 1 are palindromes\n    for (int i = 0; i < n; ++i) dp[i][i] = true;\n    // check for substrings of length 2\n    for (int i = 0; i < n - 1; ++i) {\n        if (s[i] == s[i+1]) {\n            dp[i][i+1] = true;\n              if(maxLen==1){\n                    start = i;\n                    maxLen = 2;\n                }\n        }\n    }\n    // check for substrings of length 3 and more\n    for (int len = 3; len <= n; ++len) {\n        for (int i = 0; i <= n - len; ++i) {\n            int j = i + len - 1;\n            // if s[i] == s[j] then check for\n            //  i [i+1  --- j-1] j\n            if (s[i] == s[j] && dp[i+1][j-1]) {\n                dp[i][j] = true;\n                if(len>maxLen){\n                    start = i;\n                    maxLen = len;\n                }\n            }\n        }\n    }\n    return s.substr(start, maxLen);\n}\nint main() {\n    string s = \"forgeeksskeegfor\";\n    cout << getLongestPal(s) << endl;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nstring getLongestPal(string s) {\n    int n = s.size();\n    vector<vector<bool>> dp(n, vector<bool>(n, false));\n\n\n    int start = 0, maxLen = 1;\n\n    for (int i = 0; i < n; ++i) dp[i][i] = true;\n\n    for (int i = 0; i < n - 1; ++i) {\n        if (s[i] == s[i+1]) {\n            dp[i][i+1] = true;\n              if(maxLen==1){\n                    start = i;\n                    maxLen = 2;\n                }\n        }\n    }\n\n    for (int len = 3; len <= n; ++len) {\n        for (int i = 0; i <= n - len; ++i) {\n            int j = i + len - 1;\n\n\n            if (s[i] == s[j] && dp[i+1][j-1]) {\n                dp[i][j] = true;\n                if(len>maxLen){\n                    start = i;\n                    maxLen = len;\n                }\n            }\n        }\n    }\n    return s.substr(start, maxLen);\n}\nint main() {\n    string s = \"forgeeksskeegfor\";\n    cout << getLongestPal(s) << endl;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/longest-palindrome-substring-set-1/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def getLongestPal(s):\n    n = len(s)\n    dp = [[False] * n for _ in range(n)]\n    # dp[i][j] if the substring from [i to j] is a palindrome or not\n    start = 0\n    maxLen = 1\n    # all substrings of length 1 are palindromes\n    for i in range(n):\n        dp[i][i] = True\n    # check for substrings of length 2\n    for i in range(n - 1):\n        if s[i] == s[i + 1]:\n            dp[i][i + 1] = True\n            if maxLen == 1:\n                start = i\n                maxLen = 2\n    # check for substrings of length 3 and more\n    for length in range(3, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            # if s[i] == s[j] then check for [i+1 .. j-1]\n            if s[i] == s[j] and dp[i + 1][j - 1]:\n                dp[i][j] = True\n                if length > maxLen:\n                    start = i\n                    maxLen = length\n    return s[start:start + maxLen]\nif __name__ == \"__main__\":\n    s = \"forgeeksskeegfor\"\n    print(getLongestPal(s))",
    "code_without_comments": "def getLongestPal(s):\n    n = len(s)\n    dp = [[False] * n for _ in range(n)]\n\n    start = 0\n    maxLen = 1\n\n    for i in range(n):\n        dp[i][i] = True\n\n    for i in range(n - 1):\n        if s[i] == s[i + 1]:\n            dp[i][i + 1] = True\n            if maxLen == 1:\n                start = i\n                maxLen = 2\n\n    for length in range(3, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n\n            if s[i] == s[j] and dp[i + 1][j - 1]:\n                dp[i][j] = True\n                if length > maxLen:\n                    start = i\n                    maxLen = length\n    return s[start:start + maxLen]\nif __name__ == \"__main__\":\n    s = \"forgeeksskeegfor\"\n    print(getLongestPal(s))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/longest-palindrome-substring-set-1/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\nusing namespace std;\nstring getLongestPal(string &s) {\n    int n = s.length();\n    int start = 0, maxLen = 1;\n    for (int i = 0; i < n; i++) {\n        // this runs two times for both odd and even\n        // length palindromes.\n        // j = 0 means odd and j = 1 means even length\n        for (int j = 0; j <= 1; j++) {\n            int low = i;\n            int high = i + j;\n            // expand substring while it is a palindrome\n            // and in bounds\n            while (low >= 0 && high < n && s[low] == s[high])\n            {\n                int currLen = high - low + 1;\n                if (currLen > maxLen) {\n                    start = low;\n                    maxLen = currLen;\n                }\n                low--;\n                high++;\n            }\n        }\n    }\n    return s.substr(start, maxLen);\n}\nint main() {\n    string s = \"forgeeksskeegfor\";\n    cout << getLongestPal(s) << endl;\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\nusing namespace std;\nstring getLongestPal(string &s) {\n    int n = s.length();\n    int start = 0, maxLen = 1;\n    for (int i = 0; i < n; i++) {\n\n\n\n        for (int j = 0; j <= 1; j++) {\n            int low = i;\n            int high = i + j;\n\n\n            while (low >= 0 && high < n && s[low] == s[high])\n            {\n                int currLen = high - low + 1;\n                if (currLen > maxLen) {\n                    start = low;\n                    maxLen = currLen;\n                }\n                low--;\n                high++;\n            }\n        }\n    }\n    return s.substr(start, maxLen);\n}\nint main() {\n    string s = \"forgeeksskeegfor\";\n    cout << getLongestPal(s) << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/longest-palindrome-substring-set-1/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def getLongestPal(s):\n    n = len(s)\n    start, maxLen = 0, 1\n    for i in range(n):\n        # this runs two times for both odd and even\n        # length palindromes.\n        # j = 0 means odd and j = 1 means even length\n        for j in range(2):\n            low, high = i, i + j\n            # expand substring while it is a palindrome\n            # and in bounds\n            while low >= 0 and high < n and s[low] == s[high]:\n                currLen = high - low + 1\n                if currLen > maxLen:\n                    start = low\n                    maxLen = currLen\n                low -= 1\n                high += 1\n    return s[start:start + maxLen]\nif __name__ == \"__main__\":\n    s = \"forgeeksskeegfor\"\n    print(getLongestPal(s))",
    "code_without_comments": "def getLongestPal(s):\n    n = len(s)\n    start, maxLen = 0, 1\n    for i in range(n):\n\n\n\n        for j in range(2):\n            low, high = i, i + j\n\n\n            while low >= 0 and high < n and s[low] == s[high]:\n                currLen = high - low + 1\n                if currLen > maxLen:\n                    start = low\n                    maxLen = currLen\n                low -= 1\n                high += 1\n    return s[start:start + maxLen]\nif __name__ == \"__main__\":\n    s = \"forgeeksskeegfor\"\n    print(getLongestPal(s))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/longest-palindrome-substring-set-1/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\nclass manacher {\npublic:\n    // p[i] stores the radius of the palindrome\n    // centered at position i in ms\n    vector<int> p;\n    // transformed string with sentinels\n    // and separators\n    string ms;\n    manacher(string &s) {\n        // left sentinel to avoid bounds check\n        ms = \"@\";\n        for (char c : s) {\n            // insert '#' between every character\n            ms += \"#\" + string(1, c);\n        }\n        // right sentinel\n        ms += \"#$\";\n        runManacher();\n    }\n    void runManacher() {\n        int n = ms.size();\n        p.assign(n, 0);\n        int l = 0, r = 0;\n        for (int i = 1; i < n - 1; ++i) {\n            // initialize p[i] based on its mirror\n            // and current [l, r] range\n            if(r + l - i >= 0 && r + l - i < n)\n                p[i] = max(0, min(r - i, p[r + l - i]));\n            // try expanding around center i\n            while (ms[i + 1 + p[i]] == ms[i - 1 - p[i]]) {\n                ++p[i];\n            }\n            // update [l, r] if the new palindrome goes\n            // beyond current right boundary\n            if (i + p[i] > r) {\n                l = i - p[i];\n                r = i + p[i];\n            }\n        }\n    }\n    // return the radius of the longest palindrome\n    // centered at original index 'cen'\n    int getLongest(int cen, int odd) {\n        int pos = 2 * cen + 2 + !odd;\n        return p[pos];\n    }\n    // checks whether the substring\n    // s[l..r] is a palindrome\n    bool check(int l, int r) {\n        int res = getLongest((r + l) / 2, (r - l + 1) % 2);\n        return (r - l + 1) <= res;\n    }\n};\n// finds and returns the longest palindromic substring in s\nstring getLongestPal(string &s) {\n    int n = s.size(), maxLen = 1, start = 0;\n    manacher M(s);\n    for (int i = 0; i < n; ++i) {\n        int oddLen = M.getLongest(i, 1);\n        if (oddLen > maxLen) {\n            // update start for odd-length palindrome\n            start = i - (oddLen - 1) / 2;\n        }\n        int evenLen = M.getLongest(i, 0);\n        if (evenLen > maxLen) {\n            // update start for even-length palindrome\n            start = i - (evenLen - 1) / 2;\n        }\n        maxLen = max(maxLen, max(oddLen, evenLen));\n    }\n    return s.substr(start, maxLen);\n}\nint main() {\n    string s = \"forgeeksskeegfor\";\n    cout << getLongestPal(s) << endl;\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\nclass manacher {\npublic:\n\n\n    vector<int> p;\n\n\n    string ms;\n    manacher(string &s) {\n\n        ms = \"@\";\n        for (char c : s) {\n\n            ms += \"#\" + string(1, c);\n        }\n\n        ms += \"#$\";\n        runManacher();\n    }\n    void runManacher() {\n        int n = ms.size();\n        p.assign(n, 0);\n        int l = 0, r = 0;\n        for (int i = 1; i < n - 1; ++i) {\n\n\n            if(r + l - i >= 0 && r + l - i < n)\n                p[i] = max(0, min(r - i, p[r + l - i]));\n\n            while (ms[i + 1 + p[i]] == ms[i - 1 - p[i]]) {\n                ++p[i];\n            }\n\n\n            if (i + p[i] > r) {\n                l = i - p[i];\n                r = i + p[i];\n            }\n        }\n    }\n\n\n    int getLongest(int cen, int odd) {\n        int pos = 2 * cen + 2 + !odd;\n        return p[pos];\n    }\n\n\n    bool check(int l, int r) {\n        int res = getLongest((r + l) / 2, (r - l + 1) % 2);\n        return (r - l + 1) <= res;\n    }\n};\n\nstring getLongestPal(string &s) {\n    int n = s.size(), maxLen = 1, start = 0;\n    manacher M(s);\n    for (int i = 0; i < n; ++i) {\n        int oddLen = M.getLongest(i, 1);\n        if (oddLen > maxLen) {\n\n            start = i - (oddLen - 1) / 2;\n        }\n        int evenLen = M.getLongest(i, 0);\n        if (evenLen > maxLen) {\n\n            start = i - (evenLen - 1) / 2;\n        }\n        maxLen = max(maxLen, max(oddLen, evenLen));\n    }\n    return s.substr(start, maxLen);\n}\nint main() {\n    string s = \"forgeeksskeegfor\";\n    cout << getLongestPal(s) << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/longest-palindrome-substring-set-1/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "class manacher:\n    # p[i] stores the radius of the palindrome\n    # centered at position i in ms\n    def __init__(self, s):\n        # transformed string with sentinels\n        # and separators\n        self.ms = \"@\"\n        for c in s:\n            self.ms += \"#\" + c\n        self.ms += \"#$\"\n        self.p = [0] * len(self.ms)\n        self.runManacher()\n    def runManacher(self):\n        n = len(self.ms)\n        l = r = 0\n        for i in range(1, n - 1):\n            mirror = l + r - i\n            if 0 <= mirror < n:\n                self.p[i] = max(0, min(r - i, self.p[mirror]))\n            else:\n                self.p[i] = 0\n            # try expanding around center i\n            while (i + 1 + self.p[i] < n and\n                   i - 1 - self.p[i] >= 0 and\n                   self.ms[i + 1 + self.p[i]] == self.ms[i - 1 - self.p[i]]):\n                self.p[i] += 1\n            # update [l, r] if the new palindrome goes\n            # beyond current right boundary\n            if i + self.p[i] > r:\n                l = i - self.p[i]\n                r = i + self.p[i]\n    # return the radius of the longest palindrome\n    # centered at original index 'cen'\n    def getLongest(self, cen, odd):\n        pos = 2 * cen + 2 + (0 if odd else 1)\n        return self.p[pos]\n    # checks whether the substring\n    # s[l..r] is a palindrome\n    def check(self, l, r):\n        length = r - l + 1\n        return length <= self.getLongest((l + r) // 2, length % 2)\n# finds and returns the longest\n# palindromic substring in s\ndef getLongestPal(s):\n    n = len(s)\n    maxLen = 1\n    start = 0\n    M = manacher(s)\n    for i in range(n):\n        oddLen = M.getLongest(i, 1)\n        if oddLen > maxLen:\n            # update start for odd-length palindrome\n            start = i - (oddLen - 1) // 2\n        evenLen = M.getLongest(i, 0)\n        if evenLen > maxLen:\n            # update start for even-length palindrome\n            start = i - (evenLen - 1) // 2\n        maxLen = max(maxLen, max(oddLen, evenLen))\n    return s[start:start + maxLen]\nif __name__ == \"__main__\":\n    s = \"forgeeksskeegfor\"\n    print(getLongestPal(s))",
    "code_without_comments": "class manacher:\n\n\n    def __init__(self, s):\n\n\n        self.ms = \"@\"\n        for c in s:\n            self.ms += \"#\" + c\n        self.ms += \"#$\"\n        self.p = [0] * len(self.ms)\n        self.runManacher()\n    def runManacher(self):\n        n = len(self.ms)\n        l = r = 0\n        for i in range(1, n - 1):\n            mirror = l + r - i\n            if 0 <= mirror < n:\n                self.p[i] = max(0, min(r - i, self.p[mirror]))\n            else:\n                self.p[i] = 0\n\n            while (i + 1 + self.p[i] < n and\n                   i - 1 - self.p[i] >= 0 and\n                   self.ms[i + 1 + self.p[i]] == self.ms[i - 1 - self.p[i]]):\n                self.p[i] += 1\n\n\n            if i + self.p[i] > r:\n                l = i - self.p[i]\n                r = i + self.p[i]\n\n    # centered at original index 'cen'\n    def getLongest(self, cen, odd):\n        pos = 2 * cen + 2 + (0 if odd else 1)\n        return self.p[pos]\n\n\n    def check(self, l, r):\n        length = r - l + 1\n        return length <= self.getLongest((l + r) // 2, length % 2)\n\n\ndef getLongestPal(s):\n    n = len(s)\n    maxLen = 1\n    start = 0\n    M = manacher(s)\n    for i in range(n):\n        oddLen = M.getLongest(i, 1)\n        if oddLen > maxLen:\n\n            start = i - (oddLen - 1) // 2\n        evenLen = M.getLongest(i, 0)\n        if evenLen > maxLen:\n\n            start = i - (evenLen - 1) // 2\n        maxLen = max(maxLen, max(oddLen, evenLen))\n    return s[start:start + maxLen]\nif __name__ == \"__main__\":\n    s = \"forgeeksskeegfor\"\n    print(getLongestPal(s))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/longest-palindrome-substring-set-1/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "// C++ program to find the longest common prefix\n// using Sorting\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n// Function to find the longest common prefix\nstring longestCommonPrefix(vector<string>& arr) {\n    // Sort the vector of strings\n    sort(arr.begin(), arr.end());\n    // Compare the first and last strings\n    // in the sorted list\n    string first = arr.front();\n    string last = arr.back();\n    int minLength = min(first.size(), last.size());\n    int i = 0;\n    // Find the common prefix between the first\n    // and last strings\n    while (i < minLength && first[i] == last[i]) {\n        i++;\n    }\n    // Return the common prefix\n    return first.substr(0, i);\n}\nint main() {\n    vector<string> arr = {\"geeksforgeeks\", \"geeks\",\n                           \"geek\", \"geezer\"};\n    cout << longestCommonPrefix(arr) << endl;\n    return 0;\n}",
    "code_without_comments": "\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstring longestCommonPrefix(vector<string>& arr) {\n\n    sort(arr.begin(), arr.end());\n\n\n    string first = arr.front();\n    string last = arr.back();\n    int minLength = min(first.size(), last.size());\n    int i = 0;\n\n\n    while (i < minLength && first[i] == last[i]) {\n        i++;\n    }\n\n    return first.substr(0, i);\n}\nint main() {\n    vector<string> arr = {\"geeksforgeeks\", \"geeks\",\n                           \"geek\", \"geezer\"};\n    cout << longestCommonPrefix(arr) << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/longest-common-prefix-using-sorting/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "# Python program to find the longest common prefix\n# using Sorting\ndef longestCommonPrefix(arr):\n    # Sort the list of strings\n    arr.sort()\n    # Get the first and last strings after sorting\n    first = arr[0]\n    last = arr[-1]\n    minLength = min(len(first), len(last))\n    i = 0\n    # Find the common prefix between the first\n    # and last strings\n    while i < minLength and first[i] == last[i]:\n        i += 1\n    # Return the common prefix\n    return first[:i]\nif __name__ == \"__main__\":\n    arr = [\"geeksforgeeks\", \"geeks\", \"geek\", \"geezer\"]\n    print( longestCommonPrefix(arr))",
    "code_without_comments": "\n\ndef longestCommonPrefix(arr):\n\n    arr.sort()\n\n    first = arr[0]\n    last = arr[-1]\n    minLength = min(len(first), len(last))\n    i = 0\n\n\n    while i < minLength and first[i] == last[i]:\n        i += 1\n\n    return first[:i]\nif __name__ == \"__main__\":\n    arr = [\"geeksforgeeks\", \"geeks\", \"geek\", \"geezer\"]\n    print( longestCommonPrefix(arr))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/longest-common-prefix-using-sorting/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <iostream>\n#include <string>\nusing namespace std;\n//Driver Code Ends\nbool wildCardRec(string& txt, string& pat, int n, int m) {\n    // Empty pattern can match with a empty text only\n    if (m == 0)\n        return (n == 0);\n    // Empty text can match with a pattern consisting\n    // of '*' only.\n    if (n == 0) {\n        for (int i = 0; i < m; i++)\n            if (pat[i] != '*')\n                return false;\n        return true;\n    }\n    // Either the characters match or pattern has '?'\n    // move to the next in both text and pattern\n    if (txt[n - 1] == pat[m - 1] || pat[m - 1] == '?')\n        return wildCardRec(txt, pat, n - 1, m - 1);\n    // if the current character of pattern is '*'\n    // first case: It matches with zero character\n    // second case: It matches with one or more characters\n    if (pat[m - 1] == '*')\n        return wildCardRec(txt, pat, n, m - 1) ||\n               wildCardRec(txt, pat, n - 1, m);\n    return false;\n}\nbool wildCard(string &txt, string &pat) {\n    int n = txt.size();\n    int m = pat.size();\n    return wildCardRec(txt, pat, n, m);\n}\n//Driver Code Starts\nint main() {\n    string txt= \"abcde\";\n    string pat = \"a?c*\";\n    cout << (wildCard(txt, pat) ? \"true\" : \"false\");\n    return 0;\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <iostream>\n#include <string>\nusing namespace std;\n\nbool wildCardRec(string& txt, string& pat, int n, int m) {\n\n    if (m == 0)\n        return (n == 0);\n\n\n    if (n == 0) {\n        for (int i = 0; i < m; i++)\n            if (pat[i] != '*')\n                return false;\n        return true;\n    }\n\n\n    if (txt[n - 1] == pat[m - 1] || pat[m - 1] == '?')\n        return wildCardRec(txt, pat, n - 1, m - 1);\n\n\n\n    if (pat[m - 1] == '*')\n        return wildCardRec(txt, pat, n, m - 1) ||\n               wildCardRec(txt, pat, n - 1, m);\n    return false;\n}\nbool wildCard(string &txt, string &pat) {\n    int n = txt.size();\n    int m = pat.size();\n    return wildCardRec(txt, pat, n, m);\n}\n\nint main() {\n    string txt= \"abcde\";\n    string pat = \"a?c*\";\n    cout << (wildCard(txt, pat) ? \"true\" : \"false\");\n    return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/wildcard-pattern-matching/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def wildCardRec(txt, pat, n, m):\n    # Empty pattern can match with an empty text only\n    if m == 0:\n        return n == 0\n    # Empty text can match with a pattern consisting\n    # of '*' only.\n    if n == 0:\n        for i in range(m):\n            if pat[i] != '*':\n                return False\n        return True\n    # Either the characters match or pattern has '?'\n    # move to the next in both text and pattern\n    if txt[n - 1] == pat[m - 1] or pat[m - 1] == '?':\n        return wildCardRec(txt, pat, n - 1, m - 1)\n    # if the current character of pattern is '*'\n    # first case: It matches with zero character\n    # second case: It matches with one or more characters\n    if pat[m - 1] == '*':\n        return wildCardRec(txt, pat, n, m-1) or \\\n               wildCardRec(txt, pat, n-1, m)\n    return False\ndef wildCard(txt, pat):\n    n = len(txt)\n    m = len(pat)\n    return wildCardRec(txt, pat, n, m)\nif __name__ == \"__main__\":\n#Driver Code Starts\n    txt = \"abcde\"\n    pat = \"a?c*\"\n    print(\"true\" if wildCard(txt, pat) else \"false\")\n#Driver Code Ends",
    "code_without_comments": "def wildCardRec(txt, pat, n, m):\n\n    if m == 0:\n        return n == 0\n\n    # of '*' only.\n    if n == 0:\n        for i in range(m):\n            if pat[i] != '*':\n                return False\n        return True\n    # Either the characters match or pattern has '?'\n\n    if txt[n - 1] == pat[m - 1] or pat[m - 1] == '?':\n        return wildCardRec(txt, pat, n - 1, m - 1)\n    # if the current character of pattern is '*'\n\n\n    if pat[m - 1] == '*':\n        return wildCardRec(txt, pat, n, m-1) or \\\n               wildCardRec(txt, pat, n-1, m)\n    return False\ndef wildCard(txt, pat):\n    n = len(txt)\n    m = len(pat)\n    return wildCardRec(txt, pat, n, m)\nif __name__ == \"__main__\":\n\n    txt = \"abcde\"\n    pat = \"a?c*\"\n    print(\"true\" if wildCard(txt, pat) else \"false\")\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/wildcard-pattern-matching/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n//Driver Code Ends\nbool wildCardRec(string& txt, string& pat,\n                    int n, int m, vector<vector<int>> &dp) {\n    // Empty pattern can match with a empty text only\n    if (m == 0)\n        return (n == 0);\n    // If result for this sub problem has been\n    // already computed, return it\n    if(dp[n][m] != -1)\n        return dp[n][m];\n    // Empty text can match with a pattern consisting\n    // of '*' only.\n    if (n == 0) {\n        for (int i = 0; i < m; i++)\n            if (pat[i] != '*')\n                return dp[n][m] = false;\n        return dp[n][m] = true;\n    }\n    // Either the characters match or pattern has '?'\n    // move to the next in both text and pattern\n    if (txt[n - 1] == pat[m - 1] || pat[m - 1] == '?')\n        return dp[n][m] =\n                    wildCardRec(txt, pat, n - 1, m - 1, dp);\n    // if the current character of pattern is '*'\n    // first case: It matches with zero character\n    // second case: It matches with one or more characters\n    if (pat[m - 1] == '*')\n        return dp[n][m] =\n                        wildCardRec(txt, pat, n, m - 1, dp) ||\n                        wildCardRec(txt, pat, n - 1, m, dp);\n    return dp[n][m] = false;\n}\nbool wildCard(string &txt, string &pat) {\n    int n = txt.size();\n    int m = pat.size();\n    vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\n    return wildCardRec(txt, pat, n, m, dp);\n}\n//Driver Code Starts\nint main() {\n    string txt= \"abcde\";\n    string pat = \"a?c*\";\n    cout << (wildCard(txt, pat) ? \"true\" : \"false\");\n    return 0;\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool wildCardRec(string& txt, string& pat,\n                    int n, int m, vector<vector<int>> &dp) {\n\n    if (m == 0)\n        return (n == 0);\n\n\n    if(dp[n][m] != -1)\n        return dp[n][m];\n\n\n    if (n == 0) {\n        for (int i = 0; i < m; i++)\n            if (pat[i] != '*')\n                return dp[n][m] = false;\n        return dp[n][m] = true;\n    }\n\n\n    if (txt[n - 1] == pat[m - 1] || pat[m - 1] == '?')\n        return dp[n][m] =\n                    wildCardRec(txt, pat, n - 1, m - 1, dp);\n\n\n\n    if (pat[m - 1] == '*')\n        return dp[n][m] =\n                        wildCardRec(txt, pat, n, m - 1, dp) ||\n                        wildCardRec(txt, pat, n - 1, m, dp);\n    return dp[n][m] = false;\n}\nbool wildCard(string &txt, string &pat) {\n    int n = txt.size();\n    int m = pat.size();\n    vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\n    return wildCardRec(txt, pat, n, m, dp);\n}\n\nint main() {\n    string txt= \"abcde\";\n    string pat = \"a?c*\";\n    cout << (wildCard(txt, pat) ? \"true\" : \"false\");\n    return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/wildcard-pattern-matching/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def wildCardRec(txt, pat, n, m, dp):\n    # Empty pattern can match with an empty text only\n    if m == 0:\n        return n == 0\n    # If result for this subproblem has been\n    # already computed, return it\n    if dp[n][m] != -1:\n        return dp[n][m]\n    # Empty text can match with a pattern consisting\n    # of '*' only.\n    if n == 0:\n        for i in range(m):\n            if pat[i] != '*':\n                dp[n][m] = False\n                return False\n        dp[n][m] = True\n        return True\n    # Either the characters match or pattern has '?'\n    # move to the next in both text and pattern\n    if txt[n - 1] == pat[m - 1] or pat[m - 1] == '?':\n        dp[n][m] = wildCardRec(txt, pat, n - 1, m - 1, dp)\n        return dp[n][m]\n    # if the current character of pattern is '*'\n    # first case: It matches with zero character\n    # second case: It matches with one or more characters\n    if pat[m - 1] == '*':\n        dp[n][m] = wildCardRec(txt, pat, n, m - 1, dp) \\\n        or wildCardRec(txt, pat, n - 1, m, dp)\n        return dp[n][m]\n    dp[n][m] = False\n    return False\ndef wildCard(txt, pat):\n    n = len(txt)\n    m = len(pat)\n    dp = [[-1 for _ in range(m + 1)] for _ in range(n + 1)]\n    return wildCardRec(txt, pat, n, m, dp)\nif __name__ == \"__main__\":\n#Driver Code Starts\n    txt = \"abcde\"\n    pat = \"a?c*\"\n    print(\"true\" if wildCard(txt, pat) else \"false\")\n#Driver Code Ends",
    "code_without_comments": "def wildCardRec(txt, pat, n, m, dp):\n\n    if m == 0:\n        return n == 0\n\n\n    if dp[n][m] != -1:\n        return dp[n][m]\n\n    # of '*' only.\n    if n == 0:\n        for i in range(m):\n            if pat[i] != '*':\n                dp[n][m] = False\n                return False\n        dp[n][m] = True\n        return True\n    # Either the characters match or pattern has '?'\n\n    if txt[n - 1] == pat[m - 1] or pat[m - 1] == '?':\n        dp[n][m] = wildCardRec(txt, pat, n - 1, m - 1, dp)\n        return dp[n][m]\n    # if the current character of pattern is '*'\n\n\n    if pat[m - 1] == '*':\n        dp[n][m] = wildCardRec(txt, pat, n, m - 1, dp) \\\n        or wildCardRec(txt, pat, n - 1, m, dp)\n        return dp[n][m]\n    dp[n][m] = False\n    return False\ndef wildCard(txt, pat):\n    n = len(txt)\n    m = len(pat)\n    dp = [[-1 for _ in range(m + 1)] for _ in range(n + 1)]\n    return wildCardRec(txt, pat, n, m, dp)\nif __name__ == \"__main__\":\n\n    txt = \"abcde\"\n    pat = \"a?c*\"\n    print(\"true\" if wildCard(txt, pat) else \"false\")\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/wildcard-pattern-matching/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n//Driver Code Ends\nbool wildCard(string &txt, string &pat) {\n    int n = txt.size();\n    int m = pat.size();\n    vector<vector<bool>> dp(n + 1, vector<bool>(m + 1, false));\n    // empty text and pattern\n    dp[0][0] = true;\n    // if pattern is empty,\n    // text has to be empty in order to match\n    for (int i = 0; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            // empty text matches with strng of '*'s\n            if (i == 0) {\n                dp[i][j] = ((j > 0) ? dp[i][j - 1] : true) && (pat[j - 1] == '*');\n            }\n            // if char at both index matches\n            else if (pat[j - 1] == '?' || txt[i - 1] == pat[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            }\n            else if (pat[j - 1] == '*') {\n                dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\n            }\n        }\n    }\n    return dp[n][m];\n}\n//Driver Code Starts\nint main() {\n    string txt = \"abcde\";\n    string pat = \"a?c*\";\n    bool match = wildCard(txt, pat);\n    cout << (match ? \"true\" : \"false\");\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nbool wildCard(string &txt, string &pat) {\n    int n = txt.size();\n    int m = pat.size();\n    vector<vector<bool>> dp(n + 1, vector<bool>(m + 1, false));\n\n    dp[0][0] = true;\n\n\n    for (int i = 0; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n\n            if (i == 0) {\n                dp[i][j] = ((j > 0) ? dp[i][j - 1] : true) && (pat[j - 1] == '*');\n            }\n\n            else if (pat[j - 1] == '?' || txt[i - 1] == pat[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            }\n            else if (pat[j - 1] == '*') {\n                dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\n            }\n        }\n    }\n    return dp[n][m];\n}\n\nint main() {\n    string txt = \"abcde\";\n    string pat = \"a?c*\";\n    bool match = wildCard(txt, pat);\n    cout << (match ? \"true\" : \"false\");\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/wildcard-pattern-matching/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def wildCard(txt, pat):\n    n = len(txt)\n    m = len(pat)\n    dp = [[False] * (m + 1) for _ in range(n + 1)]\n    # empty text and pattern\n    dp[0][0] = True\n    # if pattern is empty,\n    # text has to be empty in order to match\n    for i in range(n + 1):\n        for j in range(1, m + 1):\n            # empty text matches with strng of '*'s\n            if i == 0:\n                dp[i][j] = ((j > 0 and dp[i][j - 1]) or j == 0) \\\n                                            and (pat[j - 1] == '*')\n            # if char at both index matches\n            elif pat[j - 1] == '?' or txt[i - 1] == pat[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            elif pat[j - 1] == '*':\n                dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n    return dp[n][m]\nif __name__ == \"__main__\":\n#Driver Code Starts\n    txt = \"abcde\"\n    pat = \"a?c*\"\n    match = wildCard(txt, pat)\n    print(\"true\" if match else \"false\")\n#Driver Code Ends",
    "code_without_comments": "def wildCard(txt, pat):\n    n = len(txt)\n    m = len(pat)\n    dp = [[False] * (m + 1) for _ in range(n + 1)]\n\n    dp[0][0] = True\n\n\n    for i in range(n + 1):\n        for j in range(1, m + 1):\n            # empty text matches with strng of '*'s\n            if i == 0:\n                dp[i][j] = ((j > 0 and dp[i][j - 1]) or j == 0) \\\n                                            and (pat[j - 1] == '*')\n\n            elif pat[j - 1] == '?' or txt[i - 1] == pat[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            elif pat[j - 1] == '*':\n                dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n    return dp[n][m]\nif __name__ == \"__main__\":\n\n    txt = \"abcde\"\n    pat = \"a?c*\"\n    match = wildCard(txt, pat)\n    print(\"true\" if match else \"false\")\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/wildcard-pattern-matching/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n//Driver Code Ends\nbool wildCard(string &txt, string &pat) {\n    int n = txt.size();\n    int m = pat.size();\n    vector<bool> prev(m + 1, false);\n    for (int i = 0; i <= n; i++) {\n        vector<bool> curr(m + 1, false);\n        // empty text and pattern\n        if (i == 0) curr[0] = true;\n        for (int j = 1; j <= m; j++) {\n            // empty text matches with strng of '*'s\n            if (i == 0) {\n                curr[j] = ((j > 0) ? (curr[j - 1]) : true)\n                                        && (pat[j - 1] == '*');\n            }\n            // if char at both index matches\n            else if (pat[j - 1] == '?' || txt[i - 1] == pat[j - 1]) {\n                curr[j] = prev[j - 1];\n            }\n            else if (pat[j - 1] == '*') {\n                curr[j] = prev[j] || curr[j - 1];\n            }\n        }\n        prev = curr;\n    }\n    return prev[m];\n}\n//Driver Code Starts\nint main() {\n    string txt = \"abcde\";\n    string pat = \"a?c*\";\n    bool match = wildCard(txt, pat);\n    cout << (match ? \"true\" : \"false\");\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nbool wildCard(string &txt, string &pat) {\n    int n = txt.size();\n    int m = pat.size();\n    vector<bool> prev(m + 1, false);\n    for (int i = 0; i <= n; i++) {\n        vector<bool> curr(m + 1, false);\n\n        if (i == 0) curr[0] = true;\n        for (int j = 1; j <= m; j++) {\n\n            if (i == 0) {\n                curr[j] = ((j > 0) ? (curr[j - 1]) : true)\n                                        && (pat[j - 1] == '*');\n            }\n\n            else if (pat[j - 1] == '?' || txt[i - 1] == pat[j - 1]) {\n                curr[j] = prev[j - 1];\n            }\n            else if (pat[j - 1] == '*') {\n                curr[j] = prev[j] || curr[j - 1];\n            }\n        }\n        prev = curr;\n    }\n    return prev[m];\n}\n\nint main() {\n    string txt = \"abcde\";\n    string pat = \"a?c*\";\n    bool match = wildCard(txt, pat);\n    cout << (match ? \"true\" : \"false\");\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/wildcard-pattern-matching/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def wildCard(txt, pat):\n    n = len(txt)\n    m = len(pat)\n    prev = [False] * (m + 1)\n    for i in range(n + 1):\n        curr = [False] * (m + 1)\n        # empty text and pattern\n        if i == 0:\n            curr[0] = True\n        for j in range(1, m + 1):\n            # empty text matches with strng of '*'s\n            if i == 0:\n                curr[j] = ((j > 0 and curr[j - 1]) or j == 0) \\\n                                        and (pat[j - 1] == '*')\n            # if char at both index matches\n            elif pat[j - 1] == '?' or txt[i - 1] == pat[j - 1]:\n                curr[j] = prev[j - 1]\n            elif pat[j - 1] == '*':\n                curr[j] = prev[j] or curr[j - 1]\n        prev = curr\n    return prev[m]\nif __name__ == \"__main__\":\n#Driver Code Starts\n    txt = \"abcde\"\n    pat = \"a?c*\"\n    match = wildCard(txt, pat)\n    print(\"true\" if match else \"false\")\n#Driver Code Ends",
    "code_without_comments": "def wildCard(txt, pat):\n    n = len(txt)\n    m = len(pat)\n    prev = [False] * (m + 1)\n    for i in range(n + 1):\n        curr = [False] * (m + 1)\n\n        if i == 0:\n            curr[0] = True\n        for j in range(1, m + 1):\n            # empty text matches with strng of '*'s\n            if i == 0:\n                curr[j] = ((j > 0 and curr[j - 1]) or j == 0) \\\n                                        and (pat[j - 1] == '*')\n\n            elif pat[j - 1] == '?' or txt[i - 1] == pat[j - 1]:\n                curr[j] = prev[j - 1]\n            elif pat[j - 1] == '*':\n                curr[j] = prev[j] or curr[j - 1]\n        prev = curr\n    return prev[m]\nif __name__ == \"__main__\":\n\n    txt = \"abcde\"\n    pat = \"a?c*\"\n    match = wildCard(txt, pat)\n    print(\"true\" if match else \"false\")\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/wildcard-pattern-matching/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <iostream>\nusing namespace std;\n//Driver Code Ends\nbool wildCard(string &txt, string &pat) {\n    int n = txt.length();\n    int m = pat.length();\n    int i = 0, j = 0, startIndex = -1, match = 0;\n    while (i < n) {\n        // Characters match or '?' in\n        // pattern matches any character.\n        if (j < m && (pat[j] == '?' || pat[j] == txt[i])) {\n            i++;\n            j++;\n        }\n        else if (j < m && pat[j] == '*') {\n            // Wildcard character '*', mark the current\n            // position in the pattern and the text as a\n            // proper match.\n            startIndex = j;\n            match = i;\n            j++;\n        }\n        else if (startIndex != -1) {\n            // No match, but a previous wildcard was found.\n            // Backtrack to the last '*' character position\n            // and try for a different match.\n            j = startIndex + 1;\n            match++;\n            i = match;\n        }\n        else {\n            // If none of the above cases comply, the\n            // pattern does not match.\n            return false;\n        }\n    }\n    // Consume remaining '*'\n    // characters in given pattern.\n    while (j < m && pat[j] == '*') {\n        j++;\n    }\n    // If we have reached the end of both the pattern and\n    // the text, the pattern matches the text.\n    return j == m;\n}\n//Driver Code Starts\nint main() {\n    string txt = \"abcde\";\n    string pat = \"a?c*\";\n    cout << (wildCard(txt, pat) ? \"true\" : \"false\");\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <iostream>\nusing namespace std;\n\nbool wildCard(string &txt, string &pat) {\n    int n = txt.length();\n    int m = pat.length();\n    int i = 0, j = 0, startIndex = -1, match = 0;\n    while (i < n) {\n\n\n        if (j < m && (pat[j] == '?' || pat[j] == txt[i])) {\n            i++;\n            j++;\n        }\n        else if (j < m && pat[j] == '*') {\n\n\n\n            startIndex = j;\n            match = i;\n            j++;\n        }\n        else if (startIndex != -1) {\n\n\n\n            j = startIndex + 1;\n            match++;\n            i = match;\n        }\n        else {\n\n\n            return false;\n        }\n    }\n\n\n    while (j < m && pat[j] == '*') {\n        j++;\n    }\n\n\n    return j == m;\n}\n\nint main() {\n    string txt = \"abcde\";\n    string pat = \"a?c*\";\n    cout << (wildCard(txt, pat) ? \"true\" : \"false\");\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/wildcard-pattern-matching/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def wildCard(txt, pat):\n    n = len(txt)\n    m = len(pat)\n    i = 0\n    j = 0\n    startIndex = -1\n    match = 0\n    while i < n:\n        # Characters match or '?' in\n        # pattern matches any character.\n        if j < m and (pat[j] == '?' or pat[j] == txt[i]):\n            i += 1\n            j += 1\n        elif j < m and pat[j] == '*':\n            # Wildcard character '*', mark the current\n            # position in the pattern and the text as a\n            # proper match.\n            startIndex = j\n            match = i\n            j += 1\n        elif startIndex != -1:\n            # No match, but a previous wildcard was found.\n            # Backtrack to the last '*' character position\n            # and try for a different match.\n            j = startIndex + 1\n            match += 1\n            i = match\n        else:\n            # If none of the above cases comply, the\n            # pattern does not match.\n            return False\n    # Consume remaining '*'\n    # characters in given pattern.\n    while j < m and pat[j] == '*':\n        j += 1\n    # If we have reached the end of both the pattern and\n    # the text, the pattern matches the text.\n    return j == m\nif __name__ == \"__main__\":\n#Driver Code Starts\n    txt = \"abcde\"\n    pat = \"a?c*\"\n    print(\"true\" if wildCard(txt, pat) else \"false\")\n#Driver Code Ends",
    "code_without_comments": "def wildCard(txt, pat):\n    n = len(txt)\n    m = len(pat)\n    i = 0\n    j = 0\n    startIndex = -1\n    match = 0\n    while i < n:\n        # Characters match or '?' in\n\n        if j < m and (pat[j] == '?' or pat[j] == txt[i]):\n            i += 1\n            j += 1\n        elif j < m and pat[j] == '*':\n            # Wildcard character '*', mark the current\n\n\n            startIndex = j\n            match = i\n            j += 1\n        elif startIndex != -1:\n\n            # Backtrack to the last '*' character position\n\n            j = startIndex + 1\n            match += 1\n            i = match\n        else:\n\n\n            return False\n    # Consume remaining '*'\n\n    while j < m and pat[j] == '*':\n        j += 1\n\n\n    return j == m\nif __name__ == \"__main__\":\n\n    txt = \"abcde\"\n    pat = \"a?c*\"\n    print(\"true\" if wildCard(txt, pat) else \"false\")\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/wildcard-pattern-matching/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nvector<int> nextLargerElement(vector<int> &arr) {\n    int n = arr.size();\n    vector<int> res(n, -1);\n    // iterate through each element in the array\n    for (int i = 0; i < n; i++) {\n        // check for the next greater element\n        // in the rest of the array\n        for (int j = i + 1; j < n; j++) {\n            if (arr[j] > arr[i]) {\n                res[i] = arr[j];\n                break;\n            }\n        }\n    }\n    return res;\n}\nint main() {\n    vector<int> arr = {6, 8, 0, 1, 3};\n    vector<int> res = nextLargerElement(arr);\n    for (int x : res) {\n        cout << x << \" \";\n    }\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nvector<int> nextLargerElement(vector<int> &arr) {\n    int n = arr.size();\n    vector<int> res(n, -1);\n\n    for (int i = 0; i < n; i++) {\n\n\n        for (int j = i + 1; j < n; j++) {\n            if (arr[j] > arr[i]) {\n                res[i] = arr[j];\n                break;\n            }\n        }\n    }\n    return res;\n}\nint main() {\n    vector<int> arr = {6, 8, 0, 1, 3};\n    vector<int> res = nextLargerElement(arr);\n    for (int x : res) {\n        cout << x << \" \";\n    }\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/next-greater-element/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def nextLargerElement(arr):\n    n = len(arr)\n    res = [-1] * n\n    # Iterate through each element in the array\n    for i in range(n):\n        # Check for the next greater element\n        # in the rest of the array\n        for j in range(i + 1, n):\n            if arr[j] > arr[i]:\n                res[i] = arr[j]\n                break\n    return res\nif __name__ == \"__main__\":\n    arr = [6, 8, 0, 1, 3]\n    res = nextLargerElement(arr)\n    print(\" \".join(map(str, res)))",
    "code_without_comments": "def nextLargerElement(arr):\n    n = len(arr)\n    res = [-1] * n\n\n    for i in range(n):\n\n\n        for j in range(i + 1, n):\n            if arr[j] > arr[i]:\n                res[i] = arr[j]\n                break\n    return res\nif __name__ == \"__main__\":\n    arr = [6, 8, 0, 1, 3]\n    res = nextLargerElement(arr)\n    print(\" \".join(map(str, res)))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/next-greater-element/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\nvector<int> nextLargerElement(vector<int> &arr) {\n    int n = arr.size();\n    vector<int> res(n, -1);\n    stack<int> stk;\n    for (int i = n - 1; i >= 0; i--) {\n        // Pop elements from the stack that are less\n        // than or equal to the current element\n        while (!stk.empty() && stk.top() <= arr[i]) {\n            stk.pop();\n        }\n        // If the stack is not empty, the top element\n        // is the next greater element\n        if (!stk.empty()) {\n            res[i] = stk.top();\n        }\n        // Push the current element onto the stack\n        stk.push(arr[i]);\n    }\n    return res;\n}\nint main() {\n    vector<int> arr = {6, 8, 0, 1, 3};\n    vector<int> res = nextLargerElement(arr);\n    for (int x : res) {\n        cout << x << \" \";\n    }\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\nvector<int> nextLargerElement(vector<int> &arr) {\n    int n = arr.size();\n    vector<int> res(n, -1);\n    stack<int> stk;\n    for (int i = n - 1; i >= 0; i--) {\n\n\n        while (!stk.empty() && stk.top() <= arr[i]) {\n            stk.pop();\n        }\n\n\n        if (!stk.empty()) {\n            res[i] = stk.top();\n        }\n\n        stk.push(arr[i]);\n    }\n    return res;\n}\nint main() {\n    vector<int> arr = {6, 8, 0, 1, 3};\n    vector<int> res = nextLargerElement(arr);\n    for (int x : res) {\n        cout << x << \" \";\n    }\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/next-greater-element/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def nextLargerElement(arr):\n    n = len(arr)\n    res = [-1] * n\n    stk = []\n    # Traverse the array from right to left\n    for i in range(n - 1, -1, -1):\n        # Pop elements from the stack that are less\n        # than or equal to the current element\n        while stk and arr[stk[-1]] <= arr[i]:\n            stk.pop()\n        # If the stack is not empty, the element at the\n        # top of the stack is the next greater element\n        if stk:\n            res[i] = arr[stk[-1]]\n        # Push the current index onto the stack\n        stk.append(i)\n    return res\nif __name__ == \"__main__\":\n    arr = [6, 8, 0, 1, 3]\n    res = nextLargerElement(arr)\n    print(\" \".join(map(str, res)))",
    "code_without_comments": "def nextLargerElement(arr):\n    n = len(arr)\n    res = [-1] * n\n    stk = []\n\n    for i in range(n - 1, -1, -1):\n\n\n        while stk and arr[stk[-1]] <= arr[i]:\n            stk.pop()\n\n\n        if stk:\n            res[i] = arr[stk[-1]]\n\n        stk.append(i)\n    return res\nif __name__ == \"__main__\":\n    arr = [6, 8, 0, 1, 3]\n    res = nextLargerElement(arr)\n    print(\" \".join(map(str, res)))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/next-greater-element/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nvector<int> calculateSpan(vector<int>& arr) {\n    int n = arr.size();\n    vector<int> span(n, 1);\n    // Calculate span for each day\n    for (int i = 1; i < n; i++) {\n        // Traverse left while the next element\n        // on the left is smaller than arr[i]\n        for (int j = i - 1; (j >= 0)\n                      && (arr[i] >= arr[j]); j--) {\n            span[i]++;\n        }\n    }\n    return span;\n}\nint main() {\n    vector<int> arr = {10, 4, 5, 90, 120, 80};\n    vector<int> span = calculateSpan(arr);\n    for (int x : span) {\n        cout << x << \" \";\n    }\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nvector<int> calculateSpan(vector<int>& arr) {\n    int n = arr.size();\n    vector<int> span(n, 1);\n\n    for (int i = 1; i < n; i++) {\n\n\n        for (int j = i - 1; (j >= 0)\n                      && (arr[i] >= arr[j]); j--) {\n            span[i]++;\n        }\n    }\n    return span;\n}\nint main() {\n    vector<int> arr = {10, 4, 5, 90, 120, 80};\n    vector<int> span = calculateSpan(arr);\n    for (int x : span) {\n        cout << x << \" \";\n    }\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/the-stock-span-problem/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def calculateSpan(arr):\n    n = len(arr)\n    span = [1] * n\n    # Calculate span for each day\n    for i in range(1, n):\n        # Traverse left while arr[i] >= arr[j]\n        j = i - 1\n        while j >= 0 and arr[i] >= arr[j]:\n            span[i] += 1\n            j -= 1\n    return span\nif __name__ == \"__main__\":\n    arr = [10, 4, 5, 90, 120, 80]\n    span = calculateSpan(arr)\n    print(' '.join(map(str, span)))",
    "code_without_comments": "def calculateSpan(arr):\n    n = len(arr)\n    span = [1] * n\n\n    for i in range(1, n):\n\n        j = i - 1\n        while j >= 0 and arr[i] >= arr[j]:\n            span[i] += 1\n            j -= 1\n    return span\nif __name__ == \"__main__\":\n    arr = [10, 4, 5, 90, 120, 80]\n    span = calculateSpan(arr)\n    print(' '.join(map(str, span)))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/the-stock-span-problem/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\nvector<int> calculateSpan(vector<int>& arr) {\n    int n = arr.size();\n    vector<int> span(n);\n    stack<int> st;\n    // Process each day's price\n    for (int i = 0; i < n; i++) {\n        // Remove elements from the stack while the current\n        // price is greater than or equal to stack's top price\n        while (!st.empty() && arr[st.top()] <= arr[i]) {\n            st.pop();\n        }\n        // If stack is empty, all elements to the left are smaller\n        // Else, top of the stack is the last greater element's index\n        if (st.empty()) {\n            span[i] = (i + 1);\n        }\n        else {\n            span[i] = (i - st.top());\n        }\n        // Push the current index to the stack\n        st.push(i);\n    }\n    return span;\n}\nint main() {\n    vector<int> arr = {10, 4, 5, 90, 120, 80};\n    vector<int> span = calculateSpan(arr);\n     for (int x : span) {\n        cout << x << \" \";\n    }\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\nvector<int> calculateSpan(vector<int>& arr) {\n    int n = arr.size();\n    vector<int> span(n);\n    stack<int> st;\n\n    for (int i = 0; i < n; i++) {\n\n\n        while (!st.empty() && arr[st.top()] <= arr[i]) {\n            st.pop();\n        }\n\n\n        if (st.empty()) {\n            span[i] = (i + 1);\n        }\n        else {\n            span[i] = (i - st.top());\n        }\n\n        st.push(i);\n    }\n    return span;\n}\nint main() {\n    vector<int> arr = {10, 4, 5, 90, 120, 80};\n    vector<int> span = calculateSpan(arr);\n     for (int x : span) {\n        cout << x << \" \";\n    }\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/the-stock-span-problem/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def calculateSpan(arr):\n    n = len(arr)\n    span = [0] * n\n    st = []\n    # Process each day's price\n    for i in range(n):\n        # Remove elements from the stack while the current\n        # price is greater than or equal to stack's top price\n        while st and arr[st[-1]] <= arr[i]:\n            st.pop()\n        # If stack is empty, all elements to the left are smaller\n        # Else, top of the stack is the last greater element's index\n        if not st:\n            span[i] = (i + 1)\n        else:\n            span[i] = (i - st[-1])\n        # Push the current index to the stack\n        st.append(i)\n    return span\nif __name__ == \"__main__\":\n    arr = [10, 4, 5, 90, 120, 80]\n    span = calculateSpan(arr)\n    for x in span:\n        print(x, end=\" \")",
    "code_without_comments": "def calculateSpan(arr):\n    n = len(arr)\n    span = [0] * n\n    st = []\n    # Process each day's price\n    for i in range(n):\n\n        # price is greater than or equal to stack's top price\n        while st and arr[st[-1]] <= arr[i]:\n            st.pop()\n\n        # Else, top of the stack is the last greater element's index\n        if not st:\n            span[i] = (i + 1)\n        else:\n            span[i] = (i - st[-1])\n\n        st.append(i)\n    return span\nif __name__ == \"__main__\":\n    arr = [10, 4, 5, 90, 120, 80]\n    span = calculateSpan(arr)\n    for x in span:\n        print(x, end=\" \")",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/the-stock-span-problem/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include<vector>\nusing namespace std;\nint getMaxArea(vector<int> &arr){\n    int res = 0, n = arr.size();\n    // Consider every bar one by one\n    for(int i = 0; i < n; i++){\n        int curr = arr[i];\n        // Traverse left while we have a greater height bar\n        for(int j = i-1; j>=0 && arr[j] >= arr[i]; j--)\n             curr += arr[i];\n        // Traverse right while we have a greater height bar\n        for(int j = i+1; j<n && arr[j] >= arr[i]; j++)\n            curr += arr[i];\n        res = max(res, curr);\n    }\n    return res;\n}\nint main() {\n    vector<int> arr =  {60, 20, 50, 40, 10, 50, 60};\n    cout << getMaxArea(arr);\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include<vector>\nusing namespace std;\nint getMaxArea(vector<int> &arr){\n    int res = 0, n = arr.size();\n\n    for(int i = 0; i < n; i++){\n        int curr = arr[i];\n\n        for(int j = i-1; j>=0 && arr[j] >= arr[i]; j--)\n             curr += arr[i];\n\n        for(int j = i+1; j<n && arr[j] >= arr[i]; j++)\n            curr += arr[i];\n        res = max(res, curr);\n    }\n    return res;\n}\nint main() {\n    vector<int> arr =  {60, 20, 50, 40, 10, 50, 60};\n    cout << getMaxArea(arr);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/largest-rectangle-under-histogram/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <stdio.h>\nint getMaxArea(int arr[],int n) {\n    int res = 0;\n    // Consider every bar one by one\n    for (int i = 0; i < n; i++) {\n        int curr = arr[i];\n        // Traverse left while we have a greater height bar\n        for (int j = i - 1; j >= 0 && arr[j] >= arr[i]; j--) {\n            curr += arr[i];\n        }\n        // Traverse right while we have a greater height bar\n        for (int j = i + 1; j < n && arr[j] >= arr[i]; j++) {\n            curr += arr[i];\n        }\n        if (curr > res) {\n            res = curr;\n        }\n    }\n    return res;\n}\nint main() {\n    int arr[] = {60, 20, 50, 40, 10, 50, 60};\n     int n = sizeof(arr) / sizeof(arr[0]);\n    printf(\"%d\\n\", getMaxArea(arr,n));\n    return 0;\n}",
    "code_without_comments": "#include <stdio.h>\nint getMaxArea(int arr[],int n) {\n    int res = 0;\n\n    for (int i = 0; i < n; i++) {\n        int curr = arr[i];\n\n        for (int j = i - 1; j >= 0 && arr[j] >= arr[i]; j--) {\n            curr += arr[i];\n        }\n\n        for (int j = i + 1; j < n && arr[j] >= arr[i]; j++) {\n            curr += arr[i];\n        }\n        if (curr > res) {\n            res = curr;\n        }\n    }\n    return res;\n}\nint main() {\n    int arr[] = {60, 20, 50, 40, 10, 50, 60};\n     int n = sizeof(arr) / sizeof(arr[0]);\n    printf(\"%d\\n\", getMaxArea(arr,n));\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/largest-rectangle-under-histogram/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def getMaxArea(arr):\n    res = 0\n    n = len(arr)\n    for i in range(n):\n        curr = arr[i]\n        # Traverse left while we have a greater height bar\n        j = i - 1\n        while j >= 0 and arr[j] >= arr[i]:\n            curr += arr[i]\n            j -= 1\n        # Traverse right while we have a greater height bar\n        j = i + 1\n        while j < n and arr[j] >= arr[i]:\n            curr += arr[i]\n            j += 1\n        res = max(res, curr)\n    return res\nif __name__ == \"__main__\":\n    arr = [60, 20, 50, 40, 10, 50, 60]\n    print(getMaxArea(arr))",
    "code_without_comments": "def getMaxArea(arr):\n    res = 0\n    n = len(arr)\n    for i in range(n):\n        curr = arr[i]\n\n        j = i - 1\n        while j >= 0 and arr[j] >= arr[i]:\n            curr += arr[i]\n            j -= 1\n\n        j = i + 1\n        while j < n and arr[j] >= arr[i]:\n            curr += arr[i]\n            j += 1\n        res = max(res, curr)\n    return res\nif __name__ == \"__main__\":\n    arr = [60, 20, 50, 40, 10, 50, 60]\n    print(getMaxArea(arr))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/largest-rectangle-under-histogram/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include<stack>\n#include<vector>\nusing namespace std;\n// Function to find next smaller for every element\nvector<int> nextSmaller(vector<int>& arr) {\n    int n = arr.size();\n    vector<int> nextS(n, n);\n    stack<int> st;\n    for (int i = 0; i < n; ++i) {\n        while (!st.empty() && arr[i] < arr[st.top()]) {\n            // Setting the index of the next smaller element\n            // for the top of the stack\n            nextS[st.top()] = i;\n            st.pop();\n        }\n        st.push(i);\n    }\n    return nextS;\n}\n// Function to find previous smaller for every element\nvector<int> prevSmaller(vector<int>& arr) {\n    int n = arr.size();\n    vector<int> prevS(n, -1);\n    stack<int> st;\n    for (int i = 0; i < n; ++i) {\n        while (!st.empty() && arr[i] < arr[st.top()]) {\n            // Setting the index of the previous smaller element\n            //  for the top of the stack\n            st.pop();\n        }\n        if (!st.empty()) {\n            prevS[i] = st.top();\n        }\n        st.push(i);\n    }\n    return prevS;\n}\n// Function to calculate the maximum rectangular\n// area in the Histogram\nint getMaxArea(vector<int>& arr) {\n    vector<int> prevS = prevSmaller(arr);\n    vector<int> nextS = nextSmaller(arr);\n    int maxArea = 0;\n    // Calculate the area for each Histogram bar\n    for (int i = 0; i < arr.size(); ++i) {\n        int width = nextS[i] - prevS[i] - 1;\n        int area = arr[i] * width;\n        maxArea = max(maxArea, area);\n    }\n    return maxArea;\n}\nint main() {\n    vector<int> arr = {60, 20, 50, 40, 10, 50, 60};\n    cout << getMaxArea(arr) << endl;\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include<stack>\n#include<vector>\nusing namespace std;\n\nvector<int> nextSmaller(vector<int>& arr) {\n    int n = arr.size();\n    vector<int> nextS(n, n);\n    stack<int> st;\n    for (int i = 0; i < n; ++i) {\n        while (!st.empty() && arr[i] < arr[st.top()]) {\n\n\n            nextS[st.top()] = i;\n            st.pop();\n        }\n        st.push(i);\n    }\n    return nextS;\n}\n\nvector<int> prevSmaller(vector<int>& arr) {\n    int n = arr.size();\n    vector<int> prevS(n, -1);\n    stack<int> st;\n    for (int i = 0; i < n; ++i) {\n        while (!st.empty() && arr[i] < arr[st.top()]) {\n\n\n            st.pop();\n        }\n        if (!st.empty()) {\n            prevS[i] = st.top();\n        }\n        st.push(i);\n    }\n    return prevS;\n}\n\n\nint getMaxArea(vector<int>& arr) {\n    vector<int> prevS = prevSmaller(arr);\n    vector<int> nextS = nextSmaller(arr);\n    int maxArea = 0;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        int width = nextS[i] - prevS[i] - 1;\n        int area = arr[i] * width;\n        maxArea = max(maxArea, area);\n    }\n    return maxArea;\n}\nint main() {\n    vector<int> arr = {60, 20, 50, 40, 10, 50, 60};\n    cout << getMaxArea(arr) << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/largest-rectangle-under-histogram/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <stdio.h>\n#include <stdlib.h>\n// Stack structure\nstruct Stack {\n    int top;\n    int capacity;\n    int* items;\n};\n// Function to create an empty stack with dynamic memory allocation\nstruct Stack* createStack(int capacity) {\n    struct Stack* stack =\n                (struct Stack*)malloc(sizeof(struct Stack));\n    stack->capacity = capacity;\n    stack->top = -1;\n    stack->items = (int*)malloc(stack->capacity * sizeof(int));\n    return stack;\n}\n// Function to check if the stack is empty\nint isEmpty(struct Stack* stack) {\n    return stack->top == -1;\n}\n// Function to push an element onto the stack\nvoid push(struct Stack* stack, int value) {\n    if (stack->top == stack->capacity - 1) {\n        printf(\"Stack overflow\\n\");\n        return;\n    }\n    stack->items[++(stack->top)] = value;\n}\n// Function to pop an element from the stack\nint pop(struct Stack* stack) {\n    if (isEmpty(stack)) {\n        printf(\"Stack underflow\\n\");\n        return -1;\n    }\n    return stack->items[(stack->top)--];\n}\n// Function to get the top element of the stack\nint peek(struct Stack* stack) {\n    if (!isEmpty(stack)) {\n        return stack->items[stack->top];\n    }\n    return -1;\n}\n// Function to find the next smaller element for every element\nvoid nextSmaller(int arr[], int n, int nextS[]) {\n    struct Stack* stack = createStack(n);\n    for (int i = 0; i < n; i++) {\n        nextS[i] = n;\n    }\n    for (int i = 0; i < n; i++) {\n        while (!isEmpty(stack) && arr[i] < arr[peek(stack)]) {\n            nextS[peek(stack)] = i;\n            pop(stack);\n        }\n        push(stack, i);\n    }\n}\n// Function to find the previous smaller element for every element\nvoid prevSmaller(int arr[], int n, int prevS[]) {\n    struct Stack* stack = createStack(n);\n    for (int i = 0; i < n; i++) {\n        prevS[i] = -1;\n    }\n    for (int i = 0; i < n; i++) {\n        while (!isEmpty(stack) && arr[i] < arr[peek(stack)]) {\n            pop(stack);\n        }\n        if (!isEmpty(stack)) {\n            prevS[i] = peek(stack);\n        }\n        push(stack, i);\n    }\n}\n// Function to calculate the maximum rectangular\n// area in the Histogram\nint getMaxArea(int arr[],int n) {\n    int* prevS = (int*)malloc(n * sizeof(int));\n    int* nextS = (int*)malloc(n * sizeof(int));\n    int maxArea = 0;\n    // Find previous and next smaller elements\n    prevSmaller(arr, n, prevS);\n    nextSmaller(arr, n, nextS);\n    // Calculate the area for each arrogram bar\n    for (int i = 0; i < n; i++) {\n        int width = nextS[i] - prevS[i] - 1;\n        int area = arr[i] * width;\n        if (area > maxArea) {\n            maxArea = area;\n        }\n    }\n    return maxArea;\n}\n// Driver code\nint main() {\n    int arr[] = {60, 20, 50, 40, 10, 50, 60};\n       int n = sizeof(arr) / sizeof(arr[0]);\n    printf(\"%d\\n\", getMaxArea(arr,n));\n    return 0;\n}",
    "code_without_comments": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Stack {\n    int top;\n    int capacity;\n    int* items;\n};\n\nstruct Stack* createStack(int capacity) {\n    struct Stack* stack =\n                (struct Stack*)malloc(sizeof(struct Stack));\n    stack->capacity = capacity;\n    stack->top = -1;\n    stack->items = (int*)malloc(stack->capacity * sizeof(int));\n    return stack;\n}\n\nint isEmpty(struct Stack* stack) {\n    return stack->top == -1;\n}\n\nvoid push(struct Stack* stack, int value) {\n    if (stack->top == stack->capacity - 1) {\n        printf(\"Stack overflow\\n\");\n        return;\n    }\n    stack->items[++(stack->top)] = value;\n}\n\nint pop(struct Stack* stack) {\n    if (isEmpty(stack)) {\n        printf(\"Stack underflow\\n\");\n        return -1;\n    }\n    return stack->items[(stack->top)--];\n}\n\nint peek(struct Stack* stack) {\n    if (!isEmpty(stack)) {\n        return stack->items[stack->top];\n    }\n    return -1;\n}\n\nvoid nextSmaller(int arr[], int n, int nextS[]) {\n    struct Stack* stack = createStack(n);\n    for (int i = 0; i < n; i++) {\n        nextS[i] = n;\n    }\n    for (int i = 0; i < n; i++) {\n        while (!isEmpty(stack) && arr[i] < arr[peek(stack)]) {\n            nextS[peek(stack)] = i;\n            pop(stack);\n        }\n        push(stack, i);\n    }\n}\n\nvoid prevSmaller(int arr[], int n, int prevS[]) {\n    struct Stack* stack = createStack(n);\n    for (int i = 0; i < n; i++) {\n        prevS[i] = -1;\n    }\n    for (int i = 0; i < n; i++) {\n        while (!isEmpty(stack) && arr[i] < arr[peek(stack)]) {\n            pop(stack);\n        }\n        if (!isEmpty(stack)) {\n            prevS[i] = peek(stack);\n        }\n        push(stack, i);\n    }\n}\n\n\nint getMaxArea(int arr[],int n) {\n    int* prevS = (int*)malloc(n * sizeof(int));\n    int* nextS = (int*)malloc(n * sizeof(int));\n    int maxArea = 0;\n\n    prevSmaller(arr, n, prevS);\n    nextSmaller(arr, n, nextS);\n\n    for (int i = 0; i < n; i++) {\n        int width = nextS[i] - prevS[i] - 1;\n        int area = arr[i] * width;\n        if (area > maxArea) {\n            maxArea = area;\n        }\n    }\n    return maxArea;\n}\n\nint main() {\n    int arr[] = {60, 20, 50, 40, 10, 50, 60};\n       int n = sizeof(arr) / sizeof(arr[0]);\n    printf(\"%d\\n\", getMaxArea(arr,n));\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/largest-rectangle-under-histogram/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "# Function to find next smaller for every element\ndef nextSmaller(arr):\n    n = len(arr)\n    nextS = [n] * n\n    st = []\n    for i in range(n):\n        while st and arr[i] < arr[st[-1]]:\n            # Setting the index of the next smaller element\n            # for the top of the stack\n            nextS[st.pop()] = i\n        st.append(i)\n    return nextS\n# Function to find previous smaller for every element\ndef prevSmaller(arr):\n    n = len(arr)\n    prevS = [-1] * n\n    st = []\n    for i in range(n):\n        while st and arr[i] < arr[st[-1]]:\n            st.pop()\n        if st:\n            prevS[i] = st[-1]\n        st.append(i)\n    return prevS\n# Function to calculate the maximum rectangular\n# area in the Histogram\ndef getMaxArea(arr):\n    prevS = prevSmaller(arr)\n    nextS = nextSmaller(arr)\n    maxArea = 0\n    # Calculate the area for each arrogram bar\n    for i in range(len(arr)):\n        width = nextS[i] - prevS[i] - 1\n        area = arr[i] * width\n        maxArea = max(maxArea, area)\n    return maxArea\nif __name__ == \"__main__\":\n    arr = [60, 20, 50, 40, 10, 50, 60]\n    print(getMaxArea(arr))",
    "code_without_comments": "\ndef nextSmaller(arr):\n    n = len(arr)\n    nextS = [n] * n\n    st = []\n    for i in range(n):\n        while st and arr[i] < arr[st[-1]]:\n\n\n            nextS[st.pop()] = i\n        st.append(i)\n    return nextS\n\ndef prevSmaller(arr):\n    n = len(arr)\n    prevS = [-1] * n\n    st = []\n    for i in range(n):\n        while st and arr[i] < arr[st[-1]]:\n            st.pop()\n        if st:\n            prevS[i] = st[-1]\n        st.append(i)\n    return prevS\n\n\ndef getMaxArea(arr):\n    prevS = prevSmaller(arr)\n    nextS = nextSmaller(arr)\n    maxArea = 0\n\n    for i in range(len(arr)):\n        width = nextS[i] - prevS[i] - 1\n        area = arr[i] * width\n        maxArea = max(maxArea, area)\n    return maxArea\nif __name__ == \"__main__\":\n    arr = [60, 20, 50, 40, 10, 50, 60]\n    print(getMaxArea(arr))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/largest-rectangle-under-histogram/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include<stack>\n#include<vector>\nusing namespace std;\nint getMaxArea(vector<int>& arr) {\n    int n = arr.size();\n    stack<int> st;\n    int res = 0;\n    int tp, curr;\n    for (int i = 0; i < n; i++) {\n        while (!st.empty() && arr[st.top()] >= arr[i]) {\n            // The popped item is to be considered as the\n            // smallest element of the Histogram\n            tp = st.top();\n            st.pop();\n            // For the popped item previous smaller element is\n            // just below it in the stack (or current stack top)\n            // and next smaller element is i\n            int width = st.empty() ? i : i - st.top() - 1;\n            res = max(res,  arr[tp] * width);\n        }\n        st.push(i);\n    }\n    // For the remaining items in the stack, next smaller does\n    // not exist. Previous smaller is the item just below in\n    // stack.\n    while (!st.empty()) {\n        tp = st.top(); st.pop();\n        curr = arr[tp] * (st.empty() ? n : n - st.top() - 1);\n        res = max(res, curr);\n    }\n    return res;\n}\nint main() {\n    vector<int> arr = {60, 20, 50, 40, 10, 50, 60};\n    cout << getMaxArea(arr);\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include<stack>\n#include<vector>\nusing namespace std;\nint getMaxArea(vector<int>& arr) {\n    int n = arr.size();\n    stack<int> st;\n    int res = 0;\n    int tp, curr;\n    for (int i = 0; i < n; i++) {\n        while (!st.empty() && arr[st.top()] >= arr[i]) {\n\n\n            tp = st.top();\n            st.pop();\n\n\n\n            int width = st.empty() ? i : i - st.top() - 1;\n            res = max(res,  arr[tp] * width);\n        }\n        st.push(i);\n    }\n\n\n\n    while (!st.empty()) {\n        tp = st.top(); st.pop();\n        curr = arr[tp] * (st.empty() ? n : n - st.top() - 1);\n        res = max(res, curr);\n    }\n    return res;\n}\nint main() {\n    vector<int> arr = {60, 20, 50, 40, 10, 50, 60};\n    cout << getMaxArea(arr);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/largest-rectangle-under-histogram/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <stdio.h>\n#include <stdlib.h>\n// Stack structure\nstruct Stack {\n    int top;\n    int capacity;\n    int* array;\n};\n// Function to create a stack\nstruct Stack* createStack(int capacity) {\n    struct Stack* stack = (struct Stack*)\n                                malloc(sizeof(struct Stack));\n    stack->capacity = capacity;\n    stack->top = -1;\n    stack->array = (int*)malloc(stack->capacity * sizeof(int));\n    return stack;\n}\nint isEmpty(struct Stack* stack) {\n    return stack->top == -1;\n}\nvoid push(struct Stack* stack, int item) {\n    stack->array[++stack->top] = item;\n}\nint pop(struct Stack* stack) {\n    return stack->array[stack->top--];\n}\nint peek(struct Stack* stack) {\n    return stack->array[stack->top];\n}\n// Function to calculate the maximum rectangular area\nint getMaxArea(int arr[],int n) {\n    struct Stack* st = createStack(n);\n    int res = 0, tp, curr;\n    // Traverse all bars of the arrogram\n    for (int i = 0; i < n; i++) {\n        // Process the stack while the current element\n        // is smaller than the element corresponding to\n        // the top of the stack\n        while (!isEmpty(st) && arr[peek(st)] >= arr[i]) {\n            tp = pop(st);\n            // Calculate width and update result\n            int width = isEmpty(st) ? i : i - peek(st) - 1;\n            res = (res > arr[tp] * width) ? res : arr[tp] * width;\n        }\n        push(st, i);\n    }\n    // Process remaining elements in the stack\n    while (!isEmpty(st)) {\n        tp = pop(st);\n        curr = arr[tp] * (isEmpty(st) ? n : n - peek(st) - 1);\n        res = (res > curr) ? res : curr;\n    }\n    return res;\n}\nint main() {\n    int arr[] = {60, 20, 50, 40, 10, 50, 60};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    printf(\"%d\\n\", getMaxArea(arr,n));\n    return 0;\n}",
    "code_without_comments": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Stack {\n    int top;\n    int capacity;\n    int* array;\n};\n\nstruct Stack* createStack(int capacity) {\n    struct Stack* stack = (struct Stack*)\n                                malloc(sizeof(struct Stack));\n    stack->capacity = capacity;\n    stack->top = -1;\n    stack->array = (int*)malloc(stack->capacity * sizeof(int));\n    return stack;\n}\nint isEmpty(struct Stack* stack) {\n    return stack->top == -1;\n}\nvoid push(struct Stack* stack, int item) {\n    stack->array[++stack->top] = item;\n}\nint pop(struct Stack* stack) {\n    return stack->array[stack->top--];\n}\nint peek(struct Stack* stack) {\n    return stack->array[stack->top];\n}\n\nint getMaxArea(int arr[],int n) {\n    struct Stack* st = createStack(n);\n    int res = 0, tp, curr;\n\n    for (int i = 0; i < n; i++) {\n\n\n\n        while (!isEmpty(st) && arr[peek(st)] >= arr[i]) {\n            tp = pop(st);\n\n            int width = isEmpty(st) ? i : i - peek(st) - 1;\n            res = (res > arr[tp] * width) ? res : arr[tp] * width;\n        }\n        push(st, i);\n    }\n\n    while (!isEmpty(st)) {\n        tp = pop(st);\n        curr = arr[tp] * (isEmpty(st) ? n : n - peek(st) - 1);\n        res = (res > curr) ? res : curr;\n    }\n    return res;\n}\nint main() {\n    int arr[] = {60, 20, 50, 40, 10, 50, 60};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    printf(\"%d\\n\", getMaxArea(arr,n));\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/largest-rectangle-under-histogram/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def getMaxArea(arr):\n    n = len(arr)\n    st = []\n    res = 0\n    for i in range(n):\n        # Process the stack while the current element\n        # is smaller than the element corresponding to\n        # the top of the stack\n        while st and arr[st[-1]] >= arr[i]:\n            # The popped item is to be considered as the\n            # smallest element of the Histogram\n            tp = st.pop()\n            # For the popped item, the previous smaller\n            # element is just below it in the stack (or\n            # the current stack top) and the next smaller\n            # element is i\n            width = i if not st else i - st[-1] - 1\n            # Update the result if needed\n            res = max(res, arr[tp] * width)\n        st.append(i)\n    # For the remaining items in the stack, next smaller does\n    # not exist. Previous smaller is the item just below in\n    # the stack.\n    while st:\n        tp = st.pop()\n        width = n if not st else n - st[-1] - 1\n        res = max(res, arr[tp] * width)\n    return res\nif __name__ == \"__main__\":\n    arr = [60, 20, 50, 40, 10, 50, 60]\n    print(getMaxArea(arr))",
    "code_without_comments": "def getMaxArea(arr):\n    n = len(arr)\n    st = []\n    res = 0\n    for i in range(n):\n\n\n\n        while st and arr[st[-1]] >= arr[i]:\n\n\n            tp = st.pop()\n\n\n\n\n            width = i if not st else i - st[-1] - 1\n\n            res = max(res, arr[tp] * width)\n        st.append(i)\n\n\n\n    while st:\n        tp = st.pop()\n        width = n if not st else n - st[-1] - 1\n        res = max(res, arr[tp] * width)\n    return res\nif __name__ == \"__main__\":\n    arr = [60, 20, 50, 40, 10, 50, 60]\n    print(getMaxArea(arr))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/largest-rectangle-under-histogram/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <stack>\nusing namespace std;\nclass myQueue {\n    stack<int> s1, s2;\npublic:\n    // Enqueue operation (costly)\n    void enqueue(int x) {\n        // Move all elements from s1 to s2\n        while (!s1.empty()) {\n            s2.push(s1.top());\n            s1.pop();\n        }\n        // Push the new item into s1\n        s1.push(x);\n        // Push everything back to s1\n        while (!s2.empty()) {\n            s1.push(s2.top());\n            s2.pop();\n        }\n    }\n    // Dequeue operation\n    void dequeue() {\n        if (s1.empty()) {\n            // Queue underflow\n            return;\n        }\n        s1.pop();\n    }\n    // Front operation\n    int front() {\n        if (s1.empty()) {\n            // Queue empty\n            return -1;\n        }\n        return s1.top();\n    }\n    // Size operation\n    int size() {\n        return s1.size();\n    }\n};\n// Driver code\nint main() {\n    myQueue q;\n    q.enqueue(1);\n    q.enqueue(2);\n    q.enqueue(3);\n    cout << \"Front: \" << q.front() << '\\n';\n    cout << \"Size: \" << q.size() << '\\n';\n    q.dequeue();\n    cout << \"Front: \" << q.front() << '\\n';\n    cout << \"Size: \" << q.size() << '\\n';\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <stack>\nusing namespace std;\nclass myQueue {\n    stack<int> s1, s2;\npublic:\n\n    void enqueue(int x) {\n\n        while (!s1.empty()) {\n            s2.push(s1.top());\n            s1.pop();\n        }\n\n        s1.push(x);\n\n        while (!s2.empty()) {\n            s1.push(s2.top());\n            s2.pop();\n        }\n    }\n\n    void dequeue() {\n        if (s1.empty()) {\n\n            return;\n        }\n        s1.pop();\n    }\n\n    int front() {\n        if (s1.empty()) {\n\n            return -1;\n        }\n        return s1.top();\n    }\n\n    int size() {\n        return s1.size();\n    }\n};\n\nint main() {\n    myQueue q;\n    q.enqueue(1);\n    q.enqueue(2);\n    q.enqueue(3);\n    cout << \"Front: \" << q.front() << '\\n';\n    cout << \"Size: \" << q.size() << '\\n';\n    q.dequeue();\n    cout << \"Front: \" << q.front() << '\\n';\n    cout << \"Size: \" << q.size() << '\\n';\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/queue-using-stacks/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "class myQueue:\n    def __init__(self):\n        self.s1 = []\n        self.s2 = []\n    # Enqueue operation (costly)\n    def enqueue(self, x):\n        # Move all elements from s1 to s2\n        while self.s1:\n            self.s2.append(self.s1.pop())\n        # Push the new item into s1\n        self.s1.append(x)\n        # Move everything back to s1\n        while self.s2:\n            self.s1.append(self.s2.pop())\n    # Dequeue operation\n    def dequeue(self):\n        if not self.s1:\n            # Queue underflow\n            return\n        self.s1.pop()\n    # Front operation\n    def front(self):\n        if not self.s1:\n            return -1\n        return self.s1[-1]\n    # Size operation\n    def size(self):\n        return len(self.s1)\nif __name__ == \"__main__\":\n    q = myQueue()\n    q.enqueue(1)\n    q.enqueue(2)\n    q.enqueue(3)\n    print(\"Front:\", q.front())\n    print(\"Size:\", q.size())\n    q.dequeue()\n    print(\"Front:\", q.front())\n    print(\"Size:\", q.size())",
    "code_without_comments": "class myQueue:\n    def __init__(self):\n        self.s1 = []\n        self.s2 = []\n\n    def enqueue(self, x):\n\n        while self.s1:\n            self.s2.append(self.s1.pop())\n\n        self.s1.append(x)\n\n        while self.s2:\n            self.s1.append(self.s2.pop())\n\n    def dequeue(self):\n        if not self.s1:\n\n            return\n        self.s1.pop()\n\n    def front(self):\n        if not self.s1:\n            return -1\n        return self.s1[-1]\n\n    def size(self):\n        return len(self.s1)\nif __name__ == \"__main__\":\n    q = myQueue()\n    q.enqueue(1)\n    q.enqueue(2)\n    q.enqueue(3)\n    print(\"Front:\", q.front())\n    print(\"Size:\", q.size())\n    q.dequeue()\n    print(\"Front:\", q.front())\n    print(\"Size:\", q.size())",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/queue-using-stacks/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <stack>\nusing namespace std;\nclass myQueue {\n    stack<int> s1, s2;\npublic:\n    // Enqueue operation (O(1))\n    void enqueue(int x) {\n        s1.push(x);\n    }\n    // Dequeue operation\n    void dequeue() {\n        // If both stacks are empty  queue underflow\n        if (s1.empty() && s2.empty()) return;\n        // If s2 is empty, move all elements from s1\n        if (s2.empty()) {\n            while (!s1.empty()) {\n                s2.push(s1.top());\n                s1.pop();\n            }\n        }\n        s2.pop();\n    }\n    // Return the front element without removing it\n    int front() {\n        if (!s2.empty()) return s2.top();\n        if (!s1.empty()) {\n            // Move all elements to s2 to access front\n            while (!s1.empty()) {\n                s2.push(s1.top());\n                s1.pop();\n            }\n            int x = s2.top();\n            return x;\n        }\n        // Queue empty\n        return -1;\n    }\n    // Return the current size of the queue\n    int size() {\n        return s1.size() + s2.size();\n    }\n};\nint main() {\n    myQueue q;\n    q.enqueue(1);\n    q.enqueue(2);\n    q.enqueue(3);\n    cout << \"Front: \" << q.front() << \"\\n\";\n    cout << \"Size: \" << q.size() << \"\\n\";\n    q.dequeue();\n    cout << \"Front: \" << q.front() << \"\\n\";\n    cout << \"Size: \" << q.size() << \"\\n\";\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <stack>\nusing namespace std;\nclass myQueue {\n    stack<int> s1, s2;\npublic:\n\n    void enqueue(int x) {\n        s1.push(x);\n    }\n\n    void dequeue() {\n\n        if (s1.empty() && s2.empty()) return;\n\n        if (s2.empty()) {\n            while (!s1.empty()) {\n                s2.push(s1.top());\n                s1.pop();\n            }\n        }\n        s2.pop();\n    }\n\n    int front() {\n        if (!s2.empty()) return s2.top();\n        if (!s1.empty()) {\n\n            while (!s1.empty()) {\n                s2.push(s1.top());\n                s1.pop();\n            }\n            int x = s2.top();\n            return x;\n        }\n\n        return -1;\n    }\n\n    int size() {\n        return s1.size() + s2.size();\n    }\n};\nint main() {\n    myQueue q;\n    q.enqueue(1);\n    q.enqueue(2);\n    q.enqueue(3);\n    cout << \"Front: \" << q.front() << \"\\n\";\n    cout << \"Size: \" << q.size() << \"\\n\";\n    q.dequeue();\n    cout << \"Front: \" << q.front() << \"\\n\";\n    cout << \"Size: \" << q.size() << \"\\n\";\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/queue-using-stacks/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "class myQueue:\n    def __init__(self):\n        self.s1 = []\n        self.s2 = []\n    # Enqueue an item to the queue\n    def enqueue(self, x):\n        self.s1.append(x)\n    # Dequeue an item from the queue\n    def dequeue(self):\n        if not self.s1 and not self.s2:\n            # Queue underflow\n            return\n        if not self.s2:\n            while self.s1:\n                self.s2.append(self.s1.pop())\n        self.s2.pop()\n    # Return the front element without removing it\n    def front(self):\n        if self.s2:\n            return self.s2[-1]\n        if self.s1:\n            # Move all elements to s2 to access front\n            while self.s1:\n                self.s2.append(self.s1.pop())\n            return self.s2[-1]\n            # Queue empty\n        return -1\n    # Return the size of the queue\n    def size(self):\n        return len(self.s1) + len(self.s2)\nif __name__ == \"__main__\":\n    q = myQueue()\n    q.enqueue(1)\n    q.enqueue(2)\n    q.enqueue(3)\n    print(\"Front:\", q.front())\n    print(\"Size:\", q.size())\n    q.dequeue()\n    print(\"Front:\", q.front())\n    print(\"Size:\", q.size())",
    "code_without_comments": "class myQueue:\n    def __init__(self):\n        self.s1 = []\n        self.s2 = []\n\n    def enqueue(self, x):\n        self.s1.append(x)\n\n    def dequeue(self):\n        if not self.s1 and not self.s2:\n\n            return\n        if not self.s2:\n            while self.s1:\n                self.s2.append(self.s1.pop())\n        self.s2.pop()\n\n    def front(self):\n        if self.s2:\n            return self.s2[-1]\n        if self.s1:\n\n            while self.s1:\n                self.s2.append(self.s1.pop())\n            return self.s2[-1]\n\n        return -1\n\n    def size(self):\n        return len(self.s1) + len(self.s2)\nif __name__ == \"__main__\":\n    q = myQueue()\n    q.enqueue(1)\n    q.enqueue(2)\n    q.enqueue(3)\n    print(\"Front:\", q.front())\n    print(\"Size:\", q.size())\n    q.dequeue()\n    print(\"Front:\", q.front())\n    print(\"Size:\", q.size())",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/queue-using-stacks/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <stack>\nusing namespace std;\nclass myQueue {\nprivate:\n     // single stack for queue elements\n    stack<int> s;\npublic:\n    // Enqueue an item to the queue\n    void enqueue(int x) {\n        s.push(x);\n    }\n    // Dequeue an item from the queue\n    void dequeue() {\n        if (s.empty()) {\n            cout << \"Queue Underflow\\n\";\n            return;\n        }\n        int x = s.top();\n        s.pop();\n        // If this is the last element (bottom), return it\n        if (s.empty())\n            return;\n        // Recursive call to pop remaining elements\n        dequeue();\n        // Push current element back\n        s.push(x);\n        return;\n    }\n    // Return the front element without removing it\n    int front() {\n        if (s.empty()) {\n            cout << \"Queue is empty\\n\";\n            return -1;\n        }\n        int x = s.top();\n        s.pop();\n        if (s.empty()) {\n            s.push(x);\n            return x;\n        }\n        int item = front();\n        s.push(x);\n        return item;\n    }\n    // Return the current size of the queue\n    int size() {\n        return s.size();\n    }\n};\nint main() {\n    myQueue q;\n    q.enqueue(1);\n    q.enqueue(2);\n    q.enqueue(3);\n    cout << \"Front: \" << q.front() << endl;\n    cout << \"Size: \" << q.size() << endl;\n    q.dequeue();\n    cout << \"Front: \" << q.front() << endl;\n    cout << \"Size: \" << q.size() << endl;\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <stack>\nusing namespace std;\nclass myQueue {\nprivate:\n\n    stack<int> s;\npublic:\n\n    void enqueue(int x) {\n        s.push(x);\n    }\n\n    void dequeue() {\n        if (s.empty()) {\n            cout << \"Queue Underflow\\n\";\n            return;\n        }\n        int x = s.top();\n        s.pop();\n\n        if (s.empty())\n            return;\n\n        dequeue();\n\n        s.push(x);\n        return;\n    }\n\n    int front() {\n        if (s.empty()) {\n            cout << \"Queue is empty\\n\";\n            return -1;\n        }\n        int x = s.top();\n        s.pop();\n        if (s.empty()) {\n            s.push(x);\n            return x;\n        }\n        int item = front();\n        s.push(x);\n        return item;\n    }\n\n    int size() {\n        return s.size();\n    }\n};\nint main() {\n    myQueue q;\n    q.enqueue(1);\n    q.enqueue(2);\n    q.enqueue(3);\n    cout << \"Front: \" << q.front() << endl;\n    cout << \"Size: \" << q.size() << endl;\n    q.dequeue();\n    cout << \"Front: \" << q.front() << endl;\n    cout << \"Size: \" << q.size() << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/queue-using-stacks/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "class myQueue:\n    def __init__(self):\n        self.s = []\n    # Enqueue an item to the queue\n    def enqueue(self, x):\n        self.s.append(x)\n    # Dequeue an item from the queue\n    def dequeue(self):\n        if not self.s:\n            print(\"Queue Underflow\")\n            return\n        x = self.s.pop()\n        if not self.s:\n            return\n        # Recursive call\n        self.dequeue()\n        # Push current element back\n        self.s.append(x)\n        return\n    # Return the front element without removing it\n    def front(self):\n        if not self.s:\n            print(\"Queue is empty\")\n            return -1\n        x = self.s.pop()\n        if not self.s:\n            self.s.append(x)\n            return x\n            # recursive call\n        item = self.front()\n        self.s.append(x)\n        return item\n    # Return the current size of the queue\n    def size(self):\n        return len(self.s)\nif __name__ == \"__main__\":\n    q = myQueue()\n    q.enqueue(1)\n    q.enqueue(2)\n    q.enqueue(3)\n    print(\"Front:\", q.front())\n    print(\"Size:\", q.size())\n    q.dequeue()\n    print(\"Front:\", q.front())\n    print(\"Size:\", q.size())",
    "code_without_comments": "class myQueue:\n    def __init__(self):\n        self.s = []\n\n    def enqueue(self, x):\n        self.s.append(x)\n\n    def dequeue(self):\n        if not self.s:\n            print(\"Queue Underflow\")\n            return\n        x = self.s.pop()\n        if not self.s:\n            return\n\n        self.dequeue()\n\n        self.s.append(x)\n        return\n\n    def front(self):\n        if not self.s:\n            print(\"Queue is empty\")\n            return -1\n        x = self.s.pop()\n        if not self.s:\n            self.s.append(x)\n            return x\n\n        item = self.front()\n        self.s.append(x)\n        return item\n\n    def size(self):\n        return len(self.s)\nif __name__ == \"__main__\":\n    q = myQueue()\n    q.enqueue(1)\n    q.enqueue(2)\n    q.enqueue(3)\n    print(\"Front:\", q.front())\n    print(\"Size:\", q.size())\n    q.dequeue()\n    print(\"Front:\", q.front())\n    print(\"Size:\", q.size())",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/queue-using-stacks/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\n// Method to find the maximum for each\n// and every contiguous subarray of size k.\nvector<int> maxOfSubarrays(vector<int>& arr, int k) {\n    int n = arr.size();\n    // to store the results\n    vector<int> res;\n    for (int i = 0; i <= n - k; i++) {\n        // Find maximum of subarray beginning\n        // with arr[i]\n        int max = arr[i];\n        for (int j = 1; j < k; j++) {\n            if (arr[i + j] > max)\n                max = arr[i + j];\n        }\n        res.push_back(max);\n    }\n    return res;\n}\nint main() {\n    vector<int> arr = { 1, 2, 3, 1, 4, 5, 2, 3, 6 };\n    int k = 3;\n    vector<int> res = maxOfSubarrays(arr, k);\n    for (int maxVal : res) {\n        cout << maxVal << \" \";\n    }\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nvector<int> maxOfSubarrays(vector<int>& arr, int k) {\n    int n = arr.size();\n\n    vector<int> res;\n    for (int i = 0; i <= n - k; i++) {\n\n\n        int max = arr[i];\n        for (int j = 1; j < k; j++) {\n            if (arr[i + j] > max)\n                max = arr[i + j];\n        }\n        res.push_back(max);\n    }\n    return res;\n}\nint main() {\n    vector<int> arr = { 1, 2, 3, 1, 4, 5, 2, 3, 6 };\n    int k = 3;\n    vector<int> res = maxOfSubarrays(arr, k);\n    for (int maxVal : res) {\n        cout << maxVal << \" \";\n    }\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/sliding-window-maximum-maximum-of-all-subarrays-of-size-k/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "# Method to find the maximum for each\n# and every contiguous subarray of size k.\ndef maxOfSubarrays(arr, k):\n    n = len(arr)\n    # to store the results\n    res = []\n    for i in range(0, n - k + 1):\n        # Find maximum of subarray beginning\n        # with arr[i]\n        max = arr[i]\n        for j in range(1, k):\n            if arr[i + j] > max:\n                max = arr[i + j]\n        res.append(max)\n    return res\nif __name__ == \"__main__\":\n    arr = [ 1, 2, 3, 1, 4, 5, 2, 3, 6 ]\n    k = 3\n    res = maxOfSubarrays(arr, k)\n    for maxVal in res:\n        print(maxVal, end=\" \")",
    "code_without_comments": "\n\ndef maxOfSubarrays(arr, k):\n    n = len(arr)\n\n    res = []\n    for i in range(0, n - k + 1):\n\n\n        max = arr[i]\n        for j in range(1, k):\n            if arr[i + j] > max:\n                max = arr[i + j]\n        res.append(max)\n    return res\nif __name__ == \"__main__\":\n    arr = [ 1, 2, 3, 1, 4, 5, 2, 3, 6 ]\n    k = 3\n    res = maxOfSubarrays(arr, k)\n    for maxVal in res:\n        print(maxVal, end=\" \")",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/sliding-window-maximum-maximum-of-all-subarrays-of-size-k/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <bits/stdc++.h>\nusing namespace std;\n// Method to find the maximum for each\n// and every contiguous subarray of size k.\nvector<int> maxOfSubarrays(const vector<int>& arr, int k) {\n    int n = arr.size();\n    // to store the results\n    vector<int> res;\n    // to store the max value\n    priority_queue<pair<int, int> > heap;\n    // Initialize the heap with the first k elements\n    for (int i = 0; i < k; i++)\n        heap.push({ arr[i], i });\n    // The maximum element in the first window\n    res.push_back(heap.top().first);\n    // Process the remaining elements\n    for (int i = k; i < arr.size(); i++) {\n        // Add the current element to the heap\n        heap.push({ arr[i], i });\n        // Remove elements that are outside the current\n        // window\n        while (heap.top().second <= i - k)\n            heap.pop();\n        // The maximum element in the current window\n        res.push_back(heap.top().first);\n    }\n    return res;\n}\nint main() {\n    vector<int> arr = { 1, 2, 3, 1, 4, 5, 2, 3, 6 };\n    int k = 3;\n    vector<int> res = maxOfSubarrays(arr, k);\n    for (int maxVal : res) {\n        cout << maxVal << \" \";\n    }\n    return 0;\n}",
    "code_without_comments": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nvector<int> maxOfSubarrays(const vector<int>& arr, int k) {\n    int n = arr.size();\n\n    vector<int> res;\n\n    priority_queue<pair<int, int> > heap;\n\n    for (int i = 0; i < k; i++)\n        heap.push({ arr[i], i });\n\n    res.push_back(heap.top().first);\n\n    for (int i = k; i < arr.size(); i++) {\n\n        heap.push({ arr[i], i });\n\n\n        while (heap.top().second <= i - k)\n            heap.pop();\n\n        res.push_back(heap.top().first);\n    }\n    return res;\n}\nint main() {\n    vector<int> arr = { 1, 2, 3, 1, 4, 5, 2, 3, 6 };\n    int k = 3;\n    vector<int> res = maxOfSubarrays(arr, k);\n    for (int maxVal : res) {\n        cout << maxVal << \" \";\n    }\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/sliding-window-maximum-maximum-of-all-subarrays-of-size-k/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "import heapq\n# Method to find the maximum for each\n# and every contiguous subarray of size k.\ndef maxOfSubarrays(arr, k):\n    n = len(arr)\n    # to store the results\n    res = []\n    # to store the max value\n    heap = []\n    # Initialize the heap with the first k elements\n    for i in range(0, k):\n        heapq.heappush(heap, (-arr[i], i))\n    # The maximum element in the first window\n    res.append(-heap[0][0])\n    # Process the remaining elements\n    for i in range(k, len(arr)):\n        # Add the current element to the heap\n        heapq.heappush(heap, (-arr[i], i))\n        # Remove elements that are outside the current\n        # window\n        while heap[0][1] <= i - k:\n            heapq.heappop(heap)\n        # The maximum element in the current window\n        res.append(-heap[0][0])\n    return res\nif __name__ == \"__main__\":\n    arr = [ 1, 2, 3, 1, 4, 5, 2, 3, 6 ]\n    k = 3\n    res = maxOfSubarrays(arr, k)\n    for maxVal in res:\n        print(maxVal, end=\" \")",
    "code_without_comments": "import heapq\n\n\ndef maxOfSubarrays(arr, k):\n    n = len(arr)\n\n    res = []\n\n    heap = []\n\n    for i in range(0, k):\n        heapq.heappush(heap, (-arr[i], i))\n\n    res.append(-heap[0][0])\n\n    for i in range(k, len(arr)):\n\n        heapq.heappush(heap, (-arr[i], i))\n\n\n        while heap[0][1] <= i - k:\n            heapq.heappop(heap)\n\n        res.append(-heap[0][0])\n    return res\nif __name__ == \"__main__\":\n    arr = [ 1, 2, 3, 1, 4, 5, 2, 3, 6 ]\n    k = 3\n    res = maxOfSubarrays(arr, k)\n    for maxVal in res:\n        print(maxVal, end=\" \")",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/sliding-window-maximum-maximum-of-all-subarrays-of-size-k/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <bits/stdc++.h>\nusing namespace std;\n// Method to find the maximum for each\n// and every contiguous subarray of size k.\nvector<int> maxOfSubarrays(vector<int>& arr, int k) {\n    // to store the results\n    vector<int> res;\n    // create deque to store max values\n    deque<int> dq(k);\n    // Process first k (or first window) elements of array\n    for (int i = 0; i < k; ++i) {\n        // For every element, the previous smaller elements\n        // are useless so remove them from dq\n        while (!dq.empty() && arr[i] >= arr[dq.back()]) {\n            // Remove from rear\n            dq.pop_back();\n        }\n        // Add new element at rear of queue\n        dq.push_back(i);\n    }\n    // Process rest of the elements, i.e., from arr[k] to arr[n-1]\n    for (int i = k; i < arr.size(); ++i) {\n        // The element at the front of the queue is the largest\n        // element of previous window, so store it\n        res.push_back(arr[dq.front()]);\n        // Remove the elements which are out of this window\n        while (!dq.empty() && dq.front() <= i - k) {\n            // Remove from front of queue\n            dq.pop_front();\n        }\n        // Remove all elements smaller than the currently being\n        // added element (remove useless elements)\n        while (!dq.empty() && arr[i] >= arr[dq.back()]) {\n            dq.pop_back();\n        }\n        // Add current element at the rear of dq\n        dq.push_back(i);\n    }\n    // store the maximum element of last window\n    res.push_back(arr[dq.front()]);\n    return res;\n}\nint main() {\n    vector<int> arr = {1, 3, 2, 1, 7, 3};\n    int k = 3;\n    vector<int> res = maxOfSubarrays(arr, k);\n    for (int maxVal : res) {\n        cout << maxVal << \" \";\n    }\n    return 0;\n}",
    "code_without_comments": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nvector<int> maxOfSubarrays(vector<int>& arr, int k) {\n\n    vector<int> res;\n\n    deque<int> dq(k);\n\n    for (int i = 0; i < k; ++i) {\n\n\n        while (!dq.empty() && arr[i] >= arr[dq.back()]) {\n\n            dq.pop_back();\n        }\n\n        dq.push_back(i);\n    }\n\n    for (int i = k; i < arr.size(); ++i) {\n\n\n        res.push_back(arr[dq.front()]);\n\n        while (!dq.empty() && dq.front() <= i - k) {\n\n            dq.pop_front();\n        }\n\n\n        while (!dq.empty() && arr[i] >= arr[dq.back()]) {\n            dq.pop_back();\n        }\n\n        dq.push_back(i);\n    }\n\n    res.push_back(arr[dq.front()]);\n    return res;\n}\nint main() {\n    vector<int> arr = {1, 3, 2, 1, 7, 3};\n    int k = 3;\n    vector<int> res = maxOfSubarrays(arr, k);\n    for (int maxVal : res) {\n        cout << maxVal << \" \";\n    }\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/sliding-window-maximum-maximum-of-all-subarrays-of-size-k/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "from collections import deque\n# Method to find the maximum for each\n# and every contiguous subarray of size k.\ndef maxOfSubarrays(arr, k):\n    n = len(arr)\n    # to store the results\n    res = []\n    # create deque to store max values\n    dq = deque()\n    # Process first k (or first window) elements of array\n    for i in range(0, k):\n        # For every element, the previous smaller elements\n        # are useless so remove them from dq\n        while dq and arr[i] >= arr[dq[-1]]:\n            # Remove from rear\n            dq.pop()\n        # Add new element at rear of queue\n        dq.append(i)\n    # Process rest of the elements, i.e., from arr[k] to arr[n-1]\n    for i in range(k, len(arr)):\n        # The element at the front of the queue is the largest\n        # element of previous window, so store it\n        res.append(arr[dq[0]])\n        # Remove the elements which are out of this window\n        while dq and dq[0] <= i - k:\n            # Remove from front of queue\n            dq.popleft()\n        # Remove all elements smaller than the currently being\n        # added element (remove useless elements)\n        while dq and arr[i] >= arr[dq[-1]]:\n            dq.pop()\n        # Add current element at the rear of dq\n        dq.append(i)\n    # store the maximum element of last window\n    res.append(arr[dq[0]])\n    return res\nif __name__ == \"__main__\":\n    arr = [1, 3, 2, 1, 7, 3]\n    k = 3\n    res = maxOfSubarrays(arr, k)\n    for maxVal in res:\n        print(maxVal, end=\" \")",
    "code_without_comments": "from collections import deque\n\n\ndef maxOfSubarrays(arr, k):\n    n = len(arr)\n\n    res = []\n\n    dq = deque()\n\n    for i in range(0, k):\n\n\n        while dq and arr[i] >= arr[dq[-1]]:\n\n            dq.pop()\n\n        dq.append(i)\n\n    for i in range(k, len(arr)):\n\n\n        res.append(arr[dq[0]])\n\n        while dq and dq[0] <= i - k:\n\n            dq.popleft()\n\n\n        while dq and arr[i] >= arr[dq[-1]]:\n            dq.pop()\n\n        dq.append(i)\n\n    res.append(arr[dq[0]])\n    return res\nif __name__ == \"__main__\":\n    arr = [1, 3, 2, 1, 7, 3]\n    k = 3\n    res = maxOfSubarrays(arr, k)\n    for maxVal in res:\n        print(maxVal, end=\" \")",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/sliding-window-maximum-maximum-of-all-subarrays-of-size-k/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <stack>\nusing namespace std;\nclass SpecialStack {\n    stack<int> st;\n    stack<int> minStack;\npublic:\n    void push(int x) {\n        st.push(x);\n        // If the minStack is empty or the new element is smaller than\n        // the top of minStack, push it onto minStack\n        if (minStack.empty() || x <= minStack.top()) {\n            minStack.push(x);\n        } else {\n            // Otherwise, push the top element of minStack\n            // again to keep the minimum unchanged\n            minStack.push(minStack.top());\n        }\n    }\n    // Pop the top element from the stack\n    void pop() {\n        if (st.empty()) {\n            return;\n        }\n        // Pop from both stacks\n        st.pop();\n        minStack.pop();\n    }\n    // Return the top element of the stack without removing it\n    int peek() {\n        if (st.empty()) {\n            return -1;\n        }\n        return st.top();\n    }\n    // Get the minimum element in the stack\n    int getMin() {\n        if (minStack.empty()) {\n            return -1;\n        }\n        return minStack.top();\n    }\n};\nint main() {\n    SpecialStack st;\n    st.push(18);\n    st.push(19);\n    st.push(29);\n    st.push(15);\n    st.push(16);\n    cout << st.getMin() << endl;\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <stack>\nusing namespace std;\nclass SpecialStack {\n    stack<int> st;\n    stack<int> minStack;\npublic:\n    void push(int x) {\n        st.push(x);\n\n\n        if (minStack.empty() || x <= minStack.top()) {\n            minStack.push(x);\n        } else {\n\n\n            minStack.push(minStack.top());\n        }\n    }\n\n    void pop() {\n        if (st.empty()) {\n            return;\n        }\n\n        st.pop();\n        minStack.pop();\n    }\n\n    int peek() {\n        if (st.empty()) {\n            return -1;\n        }\n        return st.top();\n    }\n\n    int getMin() {\n        if (minStack.empty()) {\n            return -1;\n        }\n        return minStack.top();\n    }\n};\nint main() {\n    SpecialStack st;\n    st.push(18);\n    st.push(19);\n    st.push(29);\n    st.push(15);\n    st.push(16);\n    cout << st.getMin() << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/design-a-stack-that-supports-getmin-in-o1-time-and-o1-extra-space/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "class SpecialStack:\n    def __init__(self):\n        self.st = []\n        self.minSt = []\n    def push(self, x):\n        self.st.append(x)\n        # If minSt is empty or new element is smaller than\n        # the top of minSt, push it\n        if not self.minSt or x <= self.minSt[-1]:\n            self.minSt.append(x)\n        else:\n            # Otherwise, repeat the top of minSt\n            self.minSt.append(self.minSt[-1])\n    # Pop the top element\n    def pop(self):\n        if not self.st:\n            return\n        self.st.pop()\n        self.minSt.pop()\n    # Return top element\n    def peek(self):\n        if not self.st:\n            return -1\n        return self.st[-1]\n    # Get the minimum element\n    def getMin(self):\n        if not self.minSt:\n            return -1\n        return self.minSt[-1]\nif __name__ == '__main__':\n    st = SpecialStack()\n    st.push(18)\n    st.push(19)\n    st.push(29)\n    st.push(15)\n    st.push(16)\n    print(st.getMin())",
    "code_without_comments": "class SpecialStack:\n    def __init__(self):\n        self.st = []\n        self.minSt = []\n    def push(self, x):\n        self.st.append(x)\n\n\n        if not self.minSt or x <= self.minSt[-1]:\n            self.minSt.append(x)\n        else:\n\n            self.minSt.append(self.minSt[-1])\n\n    def pop(self):\n        if not self.st:\n            return\n        self.st.pop()\n        self.minSt.pop()\n\n    def peek(self):\n        if not self.st:\n            return -1\n        return self.st[-1]\n\n    def getMin(self):\n        if not self.minSt:\n            return -1\n        return self.minSt[-1]\nif __name__ == '__main__':\n    st = SpecialStack()\n    st.push(18)\n    st.push(19)\n    st.push(29)\n    st.push(15)\n    st.push(16)\n    print(st.getMin())",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/design-a-stack-that-supports-getmin-in-o1-time-and-o1-extra-space/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <stack>\nusing namespace std;\nclass SpecialStack {\nprivate:\n    stack<pair<int, int>> st;\npublic:\n    SpecialStack() {\n    }\n    // Add an element to the top of stack\n    void push(int x) {\n        int newMin = st.empty() ? x : min(x, st.top().second);\n        st.push({x, newMin});\n    }\n    // Remove the top element from the stack\n    void pop() {\n        if (!st.empty()) {\n            st.pop();\n        }\n    }\n    // Return top element of the stack\n    int peek() {\n        if (st.empty()) {\n            return -1;\n        }\n        return st.top().first;\n    }\n    // Find minimum element of the stack\n    int getMin() {\n        if (st.empty()) {\n            return -1;\n        }\n        return st.top().second;\n    }\n};\nint main() {\n    SpecialStack st;\n    st.push(2);\n    st.push(3);\n    cout << st.peek() << \" \";\n    st.pop();\n    cout << st.getMin() << \" \";\n    st.push(1);\n    cout << st.getMin() << \" \";\n}",
    "code_without_comments": "#include <iostream>\n#include <stack>\nusing namespace std;\nclass SpecialStack {\nprivate:\n    stack<pair<int, int>> st;\npublic:\n    SpecialStack() {\n    }\n\n    void push(int x) {\n        int newMin = st.empty() ? x : min(x, st.top().second);\n        st.push({x, newMin});\n    }\n\n    void pop() {\n        if (!st.empty()) {\n            st.pop();\n        }\n    }\n\n    int peek() {\n        if (st.empty()) {\n            return -1;\n        }\n        return st.top().first;\n    }\n\n    int getMin() {\n        if (st.empty()) {\n            return -1;\n        }\n        return st.top().second;\n    }\n};\nint main() {\n    SpecialStack st;\n    st.push(2);\n    st.push(3);\n    cout << st.peek() << \" \";\n    st.pop();\n    cout << st.getMin() << \" \";\n    st.push(1);\n    cout << st.getMin() << \" \";\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/design-a-stack-that-supports-getmin-in-o1-time-and-o1-extra-space/",
    "complexity_weight": 1.0
  }
]