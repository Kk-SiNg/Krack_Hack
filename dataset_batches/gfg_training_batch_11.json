[
  {
    "code_with_comments": "class SpecialStack:\n    def __init__(self):\n        self.st = []\n    # Add an element to the top of Stack\n    def push(self, x):\n        newMin = x if not self.st else min(x, self.st[-1][1])\n        self.st.append((x, newMin))\n    # Remove the top element from the Stack\n    def pop(self):\n        if self.st:\n            self.st.pop()\n    # Returns top element of the Stack\n    def peek(self):\n        return -1 if not self.st else self.st[-1][0]\n    # Finds minimum element of Stack\n    def getMin(self):\n        return -1 if not self.st else self.st[-1][1]\nif __name__ == \"__main__\":\n    st = SpecialStack()\n    st.push(2)\n    st.push(3)\n    print(st.peek(), end=\" \")\n    st.pop()\n    print(st.getMin(), end=\" \")\n    st.push(1)\n    print(st.getMin(), end=\" \")",
    "code_without_comments": "class SpecialStack:\n    def __init__(self):\n        self.st = []\n\n    def push(self, x):\n        newMin = x if not self.st else min(x, self.st[-1][1])\n        self.st.append((x, newMin))\n\n    def pop(self):\n        if self.st:\n            self.st.pop()\n\n    def peek(self):\n        return -1 if not self.st else self.st[-1][0]\n\n    def getMin(self):\n        return -1 if not self.st else self.st[-1][1]\nif __name__ == \"__main__\":\n    st = SpecialStack()\n    st.push(2)\n    st.push(3)\n    print(st.peek(), end=\" \")\n    st.pop()\n    print(st.getMin(), end=\" \")\n    st.push(1)\n    print(st.getMin(), end=\" \")",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/design-a-stack-that-supports-getmin-in-o1-time-and-o1-extra-space/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <stack>\nusing namespace std;\nclass SpecialStack {\nprivate:\n    stack<int> st;\n    int minEle;\npublic:\n    SpecialStack() {\n        minEle = -1;\n    }\n    // Add an element to the top of stack\n    void push(int x) {\n        if (st.empty()) {\n            minEle = x;\n            st.push(x);\n        }\n        // If new number is less than minEle\n        else if (x < minEle) {\n            st.push(2 * x - minEle);\n            minEle = x;\n        }\n        else {\n            st.push(x);\n        }\n    }\n    // Remove the top element from the stack\n    void pop() {\n        if (st.empty()) return;\n        int top = st.top();\n        st.pop();\n        // Minimum will change if min element is removed\n        if (top < minEle) {\n            minEle = 2 * minEle - top;\n        }\n    }\n    // Return top element of the stack\n    int peek() {\n        if (st.empty()) return -1;\n        int top = st.top();\n        return (minEle > top) ? minEle : top;\n    }\n    // Return minimum element of the stack\n    int getMin() {\n        if (st.empty()) return -1;\n        return minEle;\n    }\n};\nint main() {\n    SpecialStack st;\n    st.push(2);\n    st.push(3);\n    cout << st.peek() << \" \";\n    st.pop();\n    cout << st.getMin() << \" \";\n    st.push(1);\n    cout << st.getMin() << \" \";\n}",
    "code_without_comments": "#include <iostream>\n#include <stack>\nusing namespace std;\nclass SpecialStack {\nprivate:\n    stack<int> st;\n    int minEle;\npublic:\n    SpecialStack() {\n        minEle = -1;\n    }\n\n    void push(int x) {\n        if (st.empty()) {\n            minEle = x;\n            st.push(x);\n        }\n\n        else if (x < minEle) {\n            st.push(2 * x - minEle);\n            minEle = x;\n        }\n        else {\n            st.push(x);\n        }\n    }\n\n    void pop() {\n        if (st.empty()) return;\n        int top = st.top();\n        st.pop();\n\n        if (top < minEle) {\n            minEle = 2 * minEle - top;\n        }\n    }\n\n    int peek() {\n        if (st.empty()) return -1;\n        int top = st.top();\n        return (minEle > top) ? minEle : top;\n    }\n\n    int getMin() {\n        if (st.empty()) return -1;\n        return minEle;\n    }\n};\nint main() {\n    SpecialStack st;\n    st.push(2);\n    st.push(3);\n    cout << st.peek() << \" \";\n    st.pop();\n    cout << st.getMin() << \" \";\n    st.push(1);\n    cout << st.getMin() << \" \";\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/design-a-stack-that-supports-getmin-in-o1-time-and-o1-extra-space/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "class SpecialStack:\n    def __init__(self):\n        self.st = []\n        self.minEle = -1\n    # Add an element to the top of stack\n    def push(self, x):\n        if not self.st:\n            self.minEle = x\n            self.st.append(x)\n        # If new number is less than minEle\n        elif x < self.minEle:\n            self.st.append(2 * x - self.minEle)\n            self.minEle = x\n        else:\n            self.st.append(x)\n    # Remove the top element from the stack\n    def pop(self):\n        if not self.st:\n            return\n        top = self.st.pop()\n        # Minimum will change if min element is removed\n        if top < self.minEle:\n            self.minEle = 2 * self.minEle - top\n    # Return top element of the stack\n    def peek(self):\n        if not self.st:\n            return -1\n        top = self.st[-1]\n        # If minEle > top, minEle stores value of top\n        return self.minEle if self.minEle > top else top\n    # Return minimum element of the stack\n    def getMin(self):\n        if not self.st:\n            return -1\n        return self.minEle\nif __name__ == '__main__':\n    st = SpecialStack()\n    st.push(2)\n    st.push(3)\n    print(st.peek(), end=\" \")\n    st.pop()\n    print(st.getMin(), end=\" \")\n    st.push(1)\n    print(st.getMin(), end=\" \")",
    "code_without_comments": "class SpecialStack:\n    def __init__(self):\n        self.st = []\n        self.minEle = -1\n\n    def push(self, x):\n        if not self.st:\n            self.minEle = x\n            self.st.append(x)\n\n        elif x < self.minEle:\n            self.st.append(2 * x - self.minEle)\n            self.minEle = x\n        else:\n            self.st.append(x)\n\n    def pop(self):\n        if not self.st:\n            return\n        top = self.st.pop()\n\n        if top < self.minEle:\n            self.minEle = 2 * self.minEle - top\n\n    def peek(self):\n        if not self.st:\n            return -1\n        top = self.st[-1]\n\n        return self.minEle if self.minEle > top else top\n\n    def getMin(self):\n        if not self.st:\n            return -1\n        return self.minEle\nif __name__ == '__main__':\n    st = SpecialStack()\n    st.push(2)\n    st.push(3)\n    print(st.peek(), end=\" \")\n    st.pop()\n    print(st.getMin(), end=\" \")\n    st.push(1)\n    print(st.getMin(), end=\" \")",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/design-a-stack-that-supports-getmin-in-o1-time-and-o1-extra-space/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "class myQueue:\n    def __init__(self, cap):\n          # Maximum capacity of the queue\n        self.capacity = cap\n       # Fixed-size list to store queue elements\n        self.arr = [0] * cap\n       # Index of the front element\n        self.front = 0\n         # Current number of elements in the queue\n        self.size = 0",
    "code_without_comments": "class myQueue:\n    def __init__(self, cap):\n\n        self.capacity = cap\n\n        self.arr = [0] * cap\n\n        self.front = 0\n\n        self.size = 0",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/circular-queue-set-1-introduction-array-implementation/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\nusing namespace std;\nclass myQueue {\nprivate:\n     // fixed-size array\n    int* arr;\n     // index of front element\n    int front;\n     // current number of elements\n    int size;\n      // maximum capacity\n    int capacity;\npublic:\n    myQueue(int cap) {\n        capacity = cap;\n        arr = new int[capacity];\n        front = 0;\n        size = 0;\n    }\n    // Insert an element at the rear\n    void enqueue(int x) {\n        if (size == capacity) {\n            cout << \"Queue is full!\" << endl;\n            return;\n        }\n        int rear = (front + size) % capacity;\n        arr[rear] = x;\n        size++;\n    }\n    // Remove an element from the front\n    int dequeue() {\n        if (size == 0) {\n            cout << \"Queue is empty!\" << endl;\n            return -1;\n        }\n        int res = arr[front];\n        front = (front + 1) % capacity;\n        size--;\n        return res;\n    }\n    // Get the front element\n    int getFront() {\n        if (size == 0) return -1;\n        return arr[front];\n    }\n    // Get the rear element\n    int getRear() {\n        if (size == 0) return -1;\n        int rear = (front + size - 1) % capacity;\n        return arr[rear];\n    }\n};\nint main() {\n    myQueue q(5);\n    q.enqueue(10);\n    q.enqueue(20);\n    q.enqueue(30);\n    cout << q.getFront() << \" \" << q.getRear() << endl;\n    q.dequeue();\n    cout << q.getFront() << \" \" << q.getRear() << endl;\n    q.enqueue(40);\n    cout << q.getFront() << \" \" << q.getRear() << endl;\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\nusing namespace std;\nclass myQueue {\nprivate:\n\n    int* arr;\n\n    int front;\n\n    int size;\n\n    int capacity;\npublic:\n    myQueue(int cap) {\n        capacity = cap;\n        arr = new int[capacity];\n        front = 0;\n        size = 0;\n    }\n\n    void enqueue(int x) {\n        if (size == capacity) {\n            cout << \"Queue is full!\" << endl;\n            return;\n        }\n        int rear = (front + size) % capacity;\n        arr[rear] = x;\n        size++;\n    }\n\n    int dequeue() {\n        if (size == 0) {\n            cout << \"Queue is empty!\" << endl;\n            return -1;\n        }\n        int res = arr[front];\n        front = (front + 1) % capacity;\n        size--;\n        return res;\n    }\n\n    int getFront() {\n        if (size == 0) return -1;\n        return arr[front];\n    }\n\n    int getRear() {\n        if (size == 0) return -1;\n        int rear = (front + size - 1) % capacity;\n        return arr[rear];\n    }\n};\nint main() {\n    myQueue q(5);\n    q.enqueue(10);\n    q.enqueue(20);\n    q.enqueue(30);\n    cout << q.getFront() << \" \" << q.getRear() << endl;\n    q.dequeue();\n    cout << q.getFront() << \" \" << q.getRear() << endl;\n    q.enqueue(40);\n    cout << q.getFront() << \" \" << q.getRear() << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/circular-queue-set-1-introduction-array-implementation/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "class myQueue:\n    def __init__(self, cap):\n         # fixed-size array\n        self.arr = [0]*cap\n           # index of front element\n        self.front = 0\n          # current number of elements\n        self.size = 0\n         # maximum capacity\n        self.capacity = cap\n    # Insert an element at the rear\n    def enqueue(self, x):\n        if self.size == self.capacity:\n            print(\"Queue is full!\")\n            return\n        rear = (self.front + self.size) % self.capacity\n        self.arr[rear] = x\n        self.size += 1\n    # Remove an element from the front\n    def dequeue(self):\n        if self.size == 0:\n            print(\"Queue is empty!\")\n            return -1\n        res = self.arr[self.front]\n        self.front = (self.front + 1) % self.capacity\n        self.size -= 1\n        return res\n    # Get the front element\n    def getFront(self):\n        if self.size == 0:\n            return -1\n        return self.arr[self.front]\n    # Get the rear element\n    def getRear(self):\n        if self.size == 0:\n            return -1\n        rear = (self.front + self.size - 1) % self.capacity\n        return self.arr[rear]\nif __name__ == \"__main__\":\n    q = myQueue(5)\n    q.enqueue(10)\n    q.enqueue(20)\n    q.enqueue(30)\n    print(q.getFront(), q.getRear())\n    q.dequeue()\n    print(q.getFront(), q.getRear())\n    q.enqueue(40)\n    print(q.getFront(), q.getRear())",
    "code_without_comments": "class myQueue:\n    def __init__(self, cap):\n\n        self.arr = [0]*cap\n\n        self.front = 0\n\n        self.size = 0\n\n        self.capacity = cap\n\n    def enqueue(self, x):\n        if self.size == self.capacity:\n            print(\"Queue is full!\")\n            return\n        rear = (self.front + self.size) % self.capacity\n        self.arr[rear] = x\n        self.size += 1\n\n    def dequeue(self):\n        if self.size == 0:\n            print(\"Queue is empty!\")\n            return -1\n        res = self.arr[self.front]\n        self.front = (self.front + 1) % self.capacity\n        self.size -= 1\n        return res\n\n    def getFront(self):\n        if self.size == 0:\n            return -1\n        return self.arr[self.front]\n\n    def getRear(self):\n        if self.size == 0:\n            return -1\n        rear = (self.front + self.size - 1) % self.capacity\n        return self.arr[rear]\nif __name__ == \"__main__\":\n    q = myQueue(5)\n    q.enqueue(10)\n    q.enqueue(20)\n    q.enqueue(30)\n    print(q.getFront(), q.getRear())\n    q.dequeue()\n    print(q.getFront(), q.getRear())\n    q.enqueue(40)\n    print(q.getFront(), q.getRear())",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/circular-queue-set-1-introduction-array-implementation/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nbool compare(const vector<int>& a, const vector<int>& b) {\n    return a[1] < b[1];\n}\nint activitySelection(vector<int> &start, vector<int> &finish) {\n    vector<vector<int>> arr;\n    for (int i = 0; i < start.size(); i++) {\n        arr.push_back({start[i], finish[i]});\n    }\n    // Sort activities by finish time\n    sort(arr.begin(), arr.end(), compare);\n    // At least one activity can be performed\n    int count = 1;\n    // Index of last selected activity\n    int j = 0;\n    for (int i = 1; i < arr.size(); i++) {\n        // Check if current activity starts\n        // after last selected activity finishes\n        if (arr[i][0] > arr[j][1]) {\n            count++;\n            // Update last selected activity\n            j = i;\n        }\n    }\n    return count;\n}\nint main() {\n    vector<int> start = {1, 3, 0, 5, 8, 5};\n    vector<int> finish = {2, 4, 6, 7, 9, 9};\n    cout << activitySelection(start, finish);\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nbool compare(const vector<int>& a, const vector<int>& b) {\n    return a[1] < b[1];\n}\nint activitySelection(vector<int> &start, vector<int> &finish) {\n    vector<vector<int>> arr;\n    for (int i = 0; i < start.size(); i++) {\n        arr.push_back({start[i], finish[i]});\n    }\n\n    sort(arr.begin(), arr.end(), compare);\n\n    int count = 1;\n\n    int j = 0;\n    for (int i = 1; i < arr.size(); i++) {\n\n\n        if (arr[i][0] > arr[j][1]) {\n            count++;\n\n            j = i;\n        }\n    }\n    return count;\n}\nint main() {\n    vector<int> start = {1, 3, 0, 5, 8, 5};\n    vector<int> finish = {2, 4, 6, 7, 9, 9};\n    cout << activitySelection(start, finish);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/activity-selection-problem-greedy-algo-1/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def activitySelection(start, finish):\n    arr = list(zip(start, finish))\n    # Sort activities by finish time\n    arr.sort(key=lambda x: x[1])\n    # At least one activity can be performed\n    count = 1\n    # Index of last selected activity\n    j = 0\n    for i in range(1, len(arr)):\n        # Check if current activity starts\n        # after last selected activity finishes\n        if arr[i][0] > arr[j][1]:\n            count += 1\n            # Update last selected activity\n            j = i\n    return count\nif __name__ == '__main__':\n    start = [1, 3, 0, 5, 8, 5]\n    finish = [2, 4, 6, 7, 9, 9]\n    print(activitySelection(start, finish))",
    "code_without_comments": "def activitySelection(start, finish):\n    arr = list(zip(start, finish))\n\n    arr.sort(key=lambda x: x[1])\n\n    count = 1\n\n    j = 0\n    for i in range(1, len(arr)):\n\n\n        if arr[i][0] > arr[j][1]:\n            count += 1\n\n            j = i\n    return count\nif __name__ == '__main__':\n    start = [1, 3, 0, 5, 8, 5]\n    finish = [2, 4, 6, 7, 9, 9]\n    print(activitySelection(start, finish))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/activity-selection-problem-greedy-algo-1/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nint activitySelection(vector<int> &start, vector<int> &finish) {\n    int ans = 0;\n    // Minimum Priority Queue to sort activities in\n    // ascending order of finishing time (end[i]).\n    priority_queue<pair<int, int>,\n        vector<pair<int, int>>, greater<pair<int, int>>> p;\n    for (int i = 0; i < start.size(); i++) {\n        p.push(make_pair(finish[i], start[i]));\n    }\n    // to store the end time of last activity\n    int finishtime = -1;\n    while (!p.empty()) {\n        pair<int, int> activity = p.top();\n        p.pop();\n        if (activity.second > finishtime)\n        {\n            finishtime = activity.first;\n            ans++;\n        }\n    }\n    return ans;\n}\nint main() {\n    vector<int> start = {1, 3, 0, 5, 8, 5};\n    vector<int> finish = {2, 4, 6, 7, 9, 9};\n    cout << activitySelection(start, finish);\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nint activitySelection(vector<int> &start, vector<int> &finish) {\n    int ans = 0;\n\n\n    priority_queue<pair<int, int>,\n        vector<pair<int, int>>, greater<pair<int, int>>> p;\n    for (int i = 0; i < start.size(); i++) {\n        p.push(make_pair(finish[i], start[i]));\n    }\n\n    int finishtime = -1;\n    while (!p.empty()) {\n        pair<int, int> activity = p.top();\n        p.pop();\n        if (activity.second > finishtime)\n        {\n            finishtime = activity.first;\n            ans++;\n        }\n    }\n    return ans;\n}\nint main() {\n    vector<int> start = {1, 3, 0, 5, 8, 5};\n    vector<int> finish = {2, 4, 6, 7, 9, 9};\n    cout << activitySelection(start, finish);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/activity-selection-problem-greedy-algo-1/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "import heapq\ndef activitySelection(start, finish):\n    ans = 0\n    # Minimum Priority Queue to sort activities in\n    # ascending order of finishing time (end[i]).\n    p = []\n    for i in range(len(start)):\n        heapq.heappush(p, (finish[i], start[i]))\n    # to store the end time of last activity\n    finishtime = -1\n    while p:\n        activity = heapq.heappop(p)\n        if activity[1] > finishtime:\n            finishtime = activity[0]\n            ans += 1\n    return ans\nif __name__ == \"__main__\":\n    start = [1, 3, 0, 5, 8, 5]\n    finish = [2, 4, 6, 7, 9, 9]\n    print(activitySelection(start, finish))",
    "code_without_comments": "import heapq\ndef activitySelection(start, finish):\n    ans = 0\n\n\n    p = []\n    for i in range(len(start)):\n        heapq.heappush(p, (finish[i], start[i]))\n\n    finishtime = -1\n    while p:\n        activity = heapq.heappop(p)\n        if activity[1] > finishtime:\n            finishtime = activity[0]\n            ans += 1\n    return ans\nif __name__ == \"__main__\":\n    start = [1, 3, 0, 5, 8, 5]\n    finish = [2, 4, 6, 7, 9, 9]\n    print(activitySelection(start, finish))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/activity-selection-problem-greedy-algo-1/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> jobSequencing(vector<int> &deadline,\n                           vector<int> &profit) {\n    int n = deadline.size();\n    int cnt = 0;\n    int totProfit = 0;\n    // pair the profit and deadline of\n    // all the jos together\n    vector<pair<int, int>> jobs;\n    for (int i = 0; i < n; i++) {\n        jobs.push_back({profit[i], deadline[i]});\n    }\n    // sort the jobs based on profit\n    // in decreasing order\n    sort(jobs.begin(), jobs.end(),\n                greater<pair<int, int>>());\n    vector<int> slot(n, 0);\n    for (int i = 0; i < n; i++) {\n        int start = min(n, jobs[i].second) - 1;\n        for (int j = start; j >= 0; j--) {\n            // if slot is empty\n            if (slot[j] == 0) {\n                slot[j] = 1;\n                cnt++;\n                totProfit+= jobs[i].first;\n                break;\n            }\n        }\n    }\n    return {cnt, totProfit};\n}\nint main() {\n    vector<int> deadline = {2, 1, 2, 1, 1};\n    vector<int> profit = {100, 19, 27, 25, 15};\n    vector<int> ans = jobSequencing(deadline, profit);\n    cout<<ans[0]<<\" \"<<ans[1];\n    return 0;\n}",
    "code_without_comments": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> jobSequencing(vector<int> &deadline,\n                           vector<int> &profit) {\n    int n = deadline.size();\n    int cnt = 0;\n    int totProfit = 0;\n\n\n    vector<pair<int, int>> jobs;\n    for (int i = 0; i < n; i++) {\n        jobs.push_back({profit[i], deadline[i]});\n    }\n\n\n    sort(jobs.begin(), jobs.end(),\n                greater<pair<int, int>>());\n    vector<int> slot(n, 0);\n    for (int i = 0; i < n; i++) {\n        int start = min(n, jobs[i].second) - 1;\n        for (int j = start; j >= 0; j--) {\n\n            if (slot[j] == 0) {\n                slot[j] = 1;\n                cnt++;\n                totProfit+= jobs[i].first;\n                break;\n            }\n        }\n    }\n    return {cnt, totProfit};\n}\nint main() {\n    vector<int> deadline = {2, 1, 2, 1, 1};\n    vector<int> profit = {100, 19, 27, 25, 15};\n    vector<int> ans = jobSequencing(deadline, profit);\n    cout<<ans[0]<<\" \"<<ans[1];\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/job-sequencing-problem/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "from typing import List, Tuple\ndef jobSequencing(deadline: List[int], profit: List[int]) -> List[int]:\n    n = len(deadline)\n    cnt = 0\n    totProfit = 0\n    # pair the profit and deadline of\n    # all the jobs together\n    jobs = [(profit[i], deadline[i]) for i in range(n)]\n    # sort the jobs based on profit\n    # in decreasing order\n    jobs.sort(key=lambda x: x[0], reverse=True)\n    slot = [0] * n\n    for i in range(n):\n        start = min(n, jobs[i][1]) - 1\n        for j in range(start, -1, -1):\n            # if slot is empty\n            if slot[j] == 0:\n                slot[j] = 1\n                cnt += 1\n                totProfit += jobs[i][0]\n                break\n    return [cnt, totProfit]\nif __name__ == \"__main__\":\n    deadline = [2, 1, 2, 1, 1]\n    profit = [100, 19, 27, 25, 15]\n    ans = jobSequencing(deadline, profit)\n    print(ans[0], ans[1])",
    "code_without_comments": "from typing import List, Tuple\ndef jobSequencing(deadline: List[int], profit: List[int]) -> List[int]:\n    n = len(deadline)\n    cnt = 0\n    totProfit = 0\n\n\n    jobs = [(profit[i], deadline[i]) for i in range(n)]\n\n\n    jobs.sort(key=lambda x: x[0], reverse=True)\n    slot = [0] * n\n    for i in range(n):\n        start = min(n, jobs[i][1]) - 1\n        for j in range(start, -1, -1):\n\n            if slot[j] == 0:\n                slot[j] = 1\n                cnt += 1\n                totProfit += jobs[i][0]\n                break\n    return [cnt, totProfit]\nif __name__ == \"__main__\":\n    deadline = [2, 1, 2, 1, 1]\n    profit = [100, 19, 27, 25, 15]\n    ans = jobSequencing(deadline, profit)\n    print(ans[0], ans[1])",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/job-sequencing-problem/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "using System;\nusing System.Collections.Generic;\nclass GfG {\n    static List<int> jobSequencing(int[] deadline, int[] profit) {\n        int n = deadline.Length;\n        int cnt = 0;\n        int totProfit = 0;\n        List<Tuple<int, int>> jobs = new List<Tuple<int, int>>();\n        // pair the profit and deadline of\n        // all the jos together\n        for (int i = 0; i < n; i++) {\n            jobs.Add(new Tuple<int, int>(profit[i], deadline[i]));\n        }\n        // sort the jobs based on profit\n        // in decreasing order\n        jobs.Sort((a, b) => b.Item1.CompareTo(a.Item1));\n        int[] slot = new int[n];\n        for (int i = 0; i < n; i++) {\n            int start = Math.Min(n, jobs[i].Item2) - 1;\n            for (int j = start; j >= 0; j--) {\n                // if slot is empty\n                if (slot[j] == 0) {\n                    slot[j] = 1;\n                    cnt++;\n                    totProfit += jobs[i].Item1;\n                    break;\n                }\n            }\n        }\n        return new List<int> { cnt, totProfit };\n    }\n    static void Main() {\n        int[] deadline = { 2, 1, 2, 1, 1 };\n        int[] profit = { 100, 19, 27, 25, 15 };\n        List<int> ans = jobSequencing(deadline, profit);\n        Console.WriteLine(ans[0] + \" \" + ans[1]);\n    }\n}",
    "code_without_comments": "using System;\nusing System.Collections.Generic;\nclass GfG {\n    static List<int> jobSequencing(int[] deadline, int[] profit) {\n        int n = deadline.Length;\n        int cnt = 0;\n        int totProfit = 0;\n        List<Tuple<int, int>> jobs = new List<Tuple<int, int>>();\n\n\n        for (int i = 0; i < n; i++) {\n            jobs.Add(new Tuple<int, int>(profit[i], deadline[i]));\n        }\n\n\n        jobs.Sort((a, b) => b.Item1.CompareTo(a.Item1));\n        int[] slot = new int[n];\n        for (int i = 0; i < n; i++) {\n            int start = Math.Min(n, jobs[i].Item2) - 1;\n            for (int j = start; j >= 0; j--) {\n\n                if (slot[j] == 0) {\n                    slot[j] = 1;\n                    cnt++;\n                    totProfit += jobs[i].Item1;\n                    break;\n                }\n            }\n        }\n        return new List<int> { cnt, totProfit };\n    }\n    static void Main() {\n        int[] deadline = { 2, 1, 2, 1, 1 };\n        int[] profit = { 100, 19, 27, 25, 15 };\n        List<int> ans = jobSequencing(deadline, profit);\n        Console.WriteLine(ans[0] + \" \" + ans[1]);\n    }\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/job-sequencing-problem/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "function jobSequencing(deadline, profit) {\n    let n = deadline.length;\n    let cnt = 0;\n    let totProfit = 0;\n    // pair the profit and deadline of\n    // all the jobs together\n    let jobs = [];\n    for (let i = 0; i < n; i++) {\n        jobs.push([profit[i], deadline[i]]);\n    }\n    // sort the jobs based on profit\n    // in decreasing order\n    jobs.sort((a, b) => b[0] - a[0]);\n    let slot = Array(n).fill(0);\n    for (let i = 0; i < n; i++) {\n        let start = Math.min(n, jobs[i][1]) - 1;\n        for (let j = start; j >= 0; j--) {\n            // if slot is empty\n            if (slot[j] === 0) {\n                slot[j] = 1;\n                cnt++;\n                totProfit += jobs[i][0];\n                break;\n            }\n        }\n    }\n    return [cnt, totProfit];\n}\nlet deadline = [2, 1, 2, 1, 1];\nlet profit = [100, 19, 27, 25, 15];\nlet ans = jobSequencing(deadline, profit);\nconsole.log(ans[0] + ' ' + ans[1]);",
    "code_without_comments": "function jobSequencing(deadline, profit) {\n    let n = deadline.length;\n    let cnt = 0;\n    let totProfit = 0;\n\n\n    let jobs = [];\n    for (let i = 0; i < n; i++) {\n        jobs.push([profit[i], deadline[i]]);\n    }\n\n\n    jobs.sort((a, b) => b[0] - a[0]);\n    let slot = Array(n).fill(0);\n    for (let i = 0; i < n; i++) {\n        let start = Math.min(n, jobs[i][1]) - 1;\n        for (let j = start; j >= 0; j--) {\n\n            if (slot[j] === 0) {\n                slot[j] = 1;\n                cnt++;\n                totProfit += jobs[i][0];\n                break;\n            }\n        }\n    }\n    return [cnt, totProfit];\n}\nlet deadline = [2, 1, 2, 1, 1];\nlet profit = [100, 19, 27, 25, 15];\nlet ans = jobSequencing(deadline, profit);\nconsole.log(ans[0] + ' ' + ans[1]);",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/job-sequencing-problem/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nvector<int> jobSequencing(vector<int> &deadline, vector<int> &profit) {\n    int n = deadline.size();\n    vector<int> ans = {0, 0};\n    vector<pair<int, int>> jobs;\n    for (int i = 0; i < n; i++) {\n        jobs.push_back({deadline[i], profit[i]});\n    }\n    // sort the jobs based on deadline\n    // in ascending order\n    sort(jobs.begin(), jobs.end());\n    priority_queue<int, vector<int>, greater<int>> pq;\n    for (int i = 0; i < jobs.size(); i++) {\n        // if job can be scheduled within its deadline\n        if (jobs[i].first > pq.size())\n            pq.push(jobs[i].second);\n        // replace the job with the lowest profit\n        else if (!pq.empty() && pq.top() < jobs[i].second) {\n            pq.pop();\n            pq.push(jobs[i].second);\n        }\n    }\n    while (!pq.empty()) {\n        ans[1] += pq.top();\n        pq.pop();\n        ans[0]++;\n    }\n    return ans;\n}\nint main() {\n    vector<int> deadline = {2, 1, 2, 1, 1};\n    vector<int> profit = {100, 19, 27, 25, 15};\n    vector<int> ans = jobSequencing(deadline, profit);\n    cout<<ans[0]<<\" \"<<ans[1];\n    return 0;\n}",
    "code_without_comments": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nvector<int> jobSequencing(vector<int> &deadline, vector<int> &profit) {\n    int n = deadline.size();\n    vector<int> ans = {0, 0};\n    vector<pair<int, int>> jobs;\n    for (int i = 0; i < n; i++) {\n        jobs.push_back({deadline[i], profit[i]});\n    }\n\n\n    sort(jobs.begin(), jobs.end());\n    priority_queue<int, vector<int>, greater<int>> pq;\n    for (int i = 0; i < jobs.size(); i++) {\n\n        if (jobs[i].first > pq.size())\n            pq.push(jobs[i].second);\n\n        else if (!pq.empty() && pq.top() < jobs[i].second) {\n            pq.pop();\n            pq.push(jobs[i].second);\n        }\n    }\n    while (!pq.empty()) {\n        ans[1] += pq.top();\n        pq.pop();\n        ans[0]++;\n    }\n    return ans;\n}\nint main() {\n    vector<int> deadline = {2, 1, 2, 1, 1};\n    vector<int> profit = {100, 19, 27, 25, 15};\n    vector<int> ans = jobSequencing(deadline, profit);\n    cout<<ans[0]<<\" \"<<ans[1];\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/job-sequencing-problem/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "import heapq\ndef jobSequencing(deadline, profit):\n    n = len(deadline)\n    ans = [0, 0]\n    jobs = [(deadline[i], profit[i]) for i in range(n)]\n    # sort the jobs based on deadline\n    # in ascending order\n    jobs.sort()\n    pq = []\n    for job in jobs:\n        # if job can be scheduled within its deadline\n        if job[0] > len(pq):\n            heapq.heappush(pq, job[1])\n        # Replace the job with the lowest profit\n        elif pq and pq[0] < job[1]:\n            heapq.heappop(pq)\n            heapq.heappush(pq, job[1])\n    while pq:\n        ans[1] += heapq.heappop(pq)\n        ans[0] += 1\n    return ans\nif __name__ == \"__main__\":\n    deadline = [2, 1, 2, 1, 1]\n    profit = [100, 19, 27, 25,15]\n    ans = jobSequencing(deadline, profit)\n    print(ans[0], ans[1])",
    "code_without_comments": "import heapq\ndef jobSequencing(deadline, profit):\n    n = len(deadline)\n    ans = [0, 0]\n    jobs = [(deadline[i], profit[i]) for i in range(n)]\n\n\n    jobs.sort()\n    pq = []\n    for job in jobs:\n\n        if job[0] > len(pq):\n            heapq.heappush(pq, job[1])\n\n        elif pq and pq[0] < job[1]:\n            heapq.heappop(pq)\n            heapq.heappush(pq, job[1])\n    while pq:\n        ans[1] += heapq.heappop(pq)\n        ans[0] += 1\n    return ans\nif __name__ == \"__main__\":\n    deadline = [2, 1, 2, 1, 1]\n    profit = [100, 19, 27, 25,15]\n    ans = jobSequencing(deadline, profit)\n    print(ans[0], ans[1])",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/job-sequencing-problem/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "using System;\nusing System.Collections.Generic;\nclass MinHeap {\n    private List<int> heap = new List<int>();\n    public int Count => heap.Count;\n    public int Peek() {\n        if (heap.Count == 0)\n            throw new InvalidOperationException();\n        return heap[0];\n    }\n    public void Push(int val) {\n        heap.Add(val);\n        HeapifyUp(heap.Count - 1);\n    }\n    public int Pop() {\n        if (heap.Count == 0)\n            throw new InvalidOperationException();\n        int top = heap[0];\n        heap[0] = heap[heap.Count - 1];\n        heap.RemoveAt(heap.Count - 1);\n        if (heap.Count > 0)\n            HeapifyDown(0);\n        return top;\n    }\n    private void HeapifyUp(int idx) {\n        while (idx > 0) {\n            int parent = (idx - 1) / 2;\n            if (heap[parent] <= heap[idx])\n                break;\n            Swap(parent, idx);\n            idx = parent;\n        }\n    }\n    private void HeapifyDown(int idx) {\n        int n = heap.Count;\n        while (true) {\n            int left = 2 * idx + 1;\n            int right = 2 * idx + 2;\n            int smallest = idx;\n            if (left < n && heap[left] < heap[smallest])\n                smallest = left;\n            if (right < n && heap[right] < heap[smallest])\n                smallest = right;\n            if (smallest == idx)\n                break;\n            Swap(idx, smallest);\n            idx = smallest;\n        }\n    }\n    private void Swap(int i, int j) {\n        int temp = heap[i];\n        heap[i] = heap[j];\n        heap[j] = temp;\n    }\n}\nclass GfG {\n    static List<int> jobSequencing(int[] deadline, int[] profit) {\n        int n = deadline.Length;\n        var jobs = new List<(int d, int p)>();\n        for (int i = 0; i < n; i++)\n            jobs.Add((deadline[i], profit[i]));\n        // sort jobs by deadline\n        jobs.Sort((a, b) => a.d.CompareTo(b.d));\n        var minHeap = new MinHeap();\n        foreach (var job in jobs) {\n            // if job can be scheduled within its deadline\n            if (minHeap.Count < job.d) {\n                minHeap.Push(job.p);\n            }\n            // replace the job with the lowest profit\n            else if (minHeap.Count > 0 && minHeap.Peek() < job.p) {\n                minHeap.Pop();\n                minHeap.Push(job.p);\n            }\n        }\n        int totalJobs = minHeap.Count;\n        int totalProfit = 0;\n        while (minHeap.Count > 0) {\n            totalProfit += minHeap.Pop();\n        }\n        return new List<int> { totalJobs, totalProfit };\n    }\n    public static void Main() {\n        int[] deadline = { 2, 1, 2, 1, 1 };\n        int[] profit = { 100, 19, 27, 25, 15 };\n        List<int> ans = jobSequencing(deadline, profit);\n        Console.WriteLine(ans[0] + \" \" + ans[1]);\n    }\n}",
    "code_without_comments": "using System;\nusing System.Collections.Generic;\nclass MinHeap {\n    private List<int> heap = new List<int>();\n    public int Count => heap.Count;\n    public int Peek() {\n        if (heap.Count == 0)\n            throw new InvalidOperationException();\n        return heap[0];\n    }\n    public void Push(int val) {\n        heap.Add(val);\n        HeapifyUp(heap.Count - 1);\n    }\n    public int Pop() {\n        if (heap.Count == 0)\n            throw new InvalidOperationException();\n        int top = heap[0];\n        heap[0] = heap[heap.Count - 1];\n        heap.RemoveAt(heap.Count - 1);\n        if (heap.Count > 0)\n            HeapifyDown(0);\n        return top;\n    }\n    private void HeapifyUp(int idx) {\n        while (idx > 0) {\n            int parent = (idx - 1) / 2;\n            if (heap[parent] <= heap[idx])\n                break;\n            Swap(parent, idx);\n            idx = parent;\n        }\n    }\n    private void HeapifyDown(int idx) {\n        int n = heap.Count;\n        while (true) {\n            int left = 2 * idx + 1;\n            int right = 2 * idx + 2;\n            int smallest = idx;\n            if (left < n && heap[left] < heap[smallest])\n                smallest = left;\n            if (right < n && heap[right] < heap[smallest])\n                smallest = right;\n            if (smallest == idx)\n                break;\n            Swap(idx, smallest);\n            idx = smallest;\n        }\n    }\n    private void Swap(int i, int j) {\n        int temp = heap[i];\n        heap[i] = heap[j];\n        heap[j] = temp;\n    }\n}\nclass GfG {\n    static List<int> jobSequencing(int[] deadline, int[] profit) {\n        int n = deadline.Length;\n        var jobs = new List<(int d, int p)>();\n        for (int i = 0; i < n; i++)\n            jobs.Add((deadline[i], profit[i]));\n\n        jobs.Sort((a, b) => a.d.CompareTo(b.d));\n        var minHeap = new MinHeap();\n        foreach (var job in jobs) {\n\n            if (minHeap.Count < job.d) {\n                minHeap.Push(job.p);\n            }\n\n            else if (minHeap.Count > 0 && minHeap.Peek() < job.p) {\n                minHeap.Pop();\n                minHeap.Push(job.p);\n            }\n        }\n        int totalJobs = minHeap.Count;\n        int totalProfit = 0;\n        while (minHeap.Count > 0) {\n            totalProfit += minHeap.Pop();\n        }\n        return new List<int> { totalJobs, totalProfit };\n    }\n    public static void Main() {\n        int[] deadline = { 2, 1, 2, 1, 1 };\n        int[] profit = { 100, 19, 27, 25, 15 };\n        List<int> ans = jobSequencing(deadline, profit);\n        Console.WriteLine(ans[0] + \" \" + ans[1]);\n    }\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/job-sequencing-problem/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "class MinHeap {\n    constructor() {\n        this.heap = [];\n    }\n    push(val) {\n        this.heap.push(val);\n        this.heapifyUp();\n    }\n    pop() {\n        if (this.heap.length === 1) return this.heap.pop();\n        let top = this.heap[0];\n        this.heap[0] = this.heap.pop();\n        this.heapifyDown();\n        return top;\n    }\n    top() {\n        return this.heap[0];\n    }\n    size() {\n        return this.heap.length;\n    }\n    heapifyUp() {\n        let idx = this.heap.length - 1;\n        while (idx > 0) {\n            let parent = Math.floor((idx - 1) / 2);\n            if (this.heap[parent] <= this.heap[idx]) break;\n            [this.heap[parent], this.heap[idx]] =\n            [this.heap[idx], this.heap[parent]];\n            idx = parent;\n        }\n    }\n    heapifyDown() {\n        let idx = 0;\n        while (2 * idx + 1 < this.heap.length) {\n            let left = 2 * idx + 1, right = 2 * idx + 2;\n            let smallest = left;\n            if (right < this.heap.length && this.heap[right]\n            < this.heap[left]) smallest = right;\n            if (this.heap[idx] <= this.heap[smallest]) break;\n            [this.heap[idx], this.heap[smallest]] =\n            [this.heap[smallest], this.heap[idx]];\n            idx = smallest;\n        }\n    }\n}\nfunction jobSequencing(deadline, profit) {\n    let n = deadline.length;\n    let ans = [0, 0];\n    let jobs = [];\n    for (let i = 0; i < n; i++) {\n        jobs.push([deadline[i], profit[i]]);\n    }\n    // sort the jobs based on deadline\n    // in ascending order\n    jobs.sort((a, b) => a[0] - b[0]);\n    let pq = new MinHeap();\n    for (let job of jobs) {\n        // if job can be scheduled within its deadline\n        if (job[0] > pq.size()) {\n            pq.push(job[1]);\n        }\n        // Replace the job with the lowest profit\n        else if (pq.size() > 0 && pq.top() < job[1]) {\n            pq.pop();\n            pq.push(job[1]);\n        }\n    }\n    while (pq.size() > 0) {\n        ans[1] += pq.pop();\n        ans[0]++;\n    }\n    return ans;\n}\n// Driver Code\nlet deadline = [2, 1, 2, 1, 1];\nlet profit = [100, 19, 27, 25, 15];\nlet ans = jobSequencing(deadline, profit);\nconsole.log(ans[0] + \" \" + ans[1]);",
    "code_without_comments": "class MinHeap {\n    constructor() {\n        this.heap = [];\n    }\n    push(val) {\n        this.heap.push(val);\n        this.heapifyUp();\n    }\n    pop() {\n        if (this.heap.length === 1) return this.heap.pop();\n        let top = this.heap[0];\n        this.heap[0] = this.heap.pop();\n        this.heapifyDown();\n        return top;\n    }\n    top() {\n        return this.heap[0];\n    }\n    size() {\n        return this.heap.length;\n    }\n    heapifyUp() {\n        let idx = this.heap.length - 1;\n        while (idx > 0) {\n            let parent = Math.floor((idx - 1) / 2);\n            if (this.heap[parent] <= this.heap[idx]) break;\n            [this.heap[parent], this.heap[idx]] =\n            [this.heap[idx], this.heap[parent]];\n            idx = parent;\n        }\n    }\n    heapifyDown() {\n        let idx = 0;\n        while (2 * idx + 1 < this.heap.length) {\n            let left = 2 * idx + 1, right = 2 * idx + 2;\n            let smallest = left;\n            if (right < this.heap.length && this.heap[right]\n            < this.heap[left]) smallest = right;\n            if (this.heap[idx] <= this.heap[smallest]) break;\n            [this.heap[idx], this.heap[smallest]] =\n            [this.heap[smallest], this.heap[idx]];\n            idx = smallest;\n        }\n    }\n}\nfunction jobSequencing(deadline, profit) {\n    let n = deadline.length;\n    let ans = [0, 0];\n    let jobs = [];\n    for (let i = 0; i < n; i++) {\n        jobs.push([deadline[i], profit[i]]);\n    }\n\n\n    jobs.sort((a, b) => a[0] - b[0]);\n    let pq = new MinHeap();\n    for (let job of jobs) {\n\n        if (job[0] > pq.size()) {\n            pq.push(job[1]);\n        }\n\n        else if (pq.size() > 0 && pq.top() < job[1]) {\n            pq.pop();\n            pq.push(job[1]);\n        }\n    }\n    while (pq.size() > 0) {\n        ans[1] += pq.pop();\n        ans[0]++;\n    }\n    return ans;\n}\n\nlet deadline = [2, 1, 2, 1, 1];\nlet profit = [100, 19, 27, 25, 15];\nlet ans = jobSequencing(deadline, profit);\nconsole.log(ans[0] + \" \" + ans[1]);",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/job-sequencing-problem/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "// C++ code for the above approach:\n#include <bits/stdc++.h>\nusing namespace std;\n// Class to represent huffman tree\nclass Node {\npublic:\n\tint data;\n\tNode *left, *right;\n\tNode(int x) {\n\t\tdata = x;\n\t\tleft = nullptr;\n\t\tright = nullptr;\n\t}\n};\n// Custom min heap for Node class.\nclass Compare {\npublic:\n\tbool operator() (Node* a, Node* b) {\n\t\treturn a->data > b->data;\n\t}\n};\n// Function to traverse tree in preorder\n// manner and push the huffman representation\n// of each character.\nvoid preOrder(Node* root, vector<string> &ans, string curr) {\n\tif (root == nullptr) return;\n    // Leaf node represents a character.\n\tif (root->left == nullptr && root->right==nullptr) {\n\t\tans.push_back(curr);\n\t\treturn;\n\t}\n\tpreOrder(root->left, ans, curr + '0');\n\tpreOrder(root->right, ans, curr + '1');\n}\nvector<string> huffmanCodes(string s,vector<int> freq) {\n\tint n = s.length();\n    // Min heap for node class.\n\tpriority_queue<Node*, vector<Node*>, Compare> pq;\n\tfor (int i=0; i<n; i++) {\n\t\tNode* tmp = new Node(freq[i]);\n\t\tpq.push(tmp);\n\t}\n    // Construct huffman tree.\n\twhile (pq.size()>=2) {\n\t    // Left node\n\t\tNode* l = pq.top();\n\t\tpq.pop();\n        // Right node\n\t\tNode* r = pq.top();\n\t\tpq.pop();\n\t\tNode* newNode = new Node(l->data + r->data);\n\t\tnewNode->left = l;\n\t\tnewNode->right = r;\n\t\tpq.push(newNode);\n\t}\n\tNode* root = pq.top();\n\tvector<string> ans;\n\tpreOrder(root, ans, \"\");\n\treturn ans;\n}\nint main() {\n\tstring s = \"abcdef\";\n\tvector<int> freq = {5, 9, 12, 13, 16, 45};\n\tvector<string> ans = huffmanCodes(s, freq);\n\tfor (int i=0; i< ans.size(); i++) {\n\t    cout << ans[i] << \" \";\n\t}\n\treturn 0;\n}",
    "code_without_comments": "\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass Node {\npublic:\n\tint data;\n\tNode *left, *right;\n\tNode(int x) {\n\t\tdata = x;\n\t\tleft = nullptr;\n\t\tright = nullptr;\n\t}\n};\n\nclass Compare {\npublic:\n\tbool operator() (Node* a, Node* b) {\n\t\treturn a->data > b->data;\n\t}\n};\n\n\n\nvoid preOrder(Node* root, vector<string> &ans, string curr) {\n\tif (root == nullptr) return;\n\n\tif (root->left == nullptr && root->right==nullptr) {\n\t\tans.push_back(curr);\n\t\treturn;\n\t}\n\tpreOrder(root->left, ans, curr + '0');\n\tpreOrder(root->right, ans, curr + '1');\n}\nvector<string> huffmanCodes(string s,vector<int> freq) {\n\tint n = s.length();\n\n\tpriority_queue<Node*, vector<Node*>, Compare> pq;\n\tfor (int i=0; i<n; i++) {\n\t\tNode* tmp = new Node(freq[i]);\n\t\tpq.push(tmp);\n\t}\n\n\twhile (pq.size()>=2) {\n\n\t\tNode* l = pq.top();\n\t\tpq.pop();\n\n\t\tNode* r = pq.top();\n\t\tpq.pop();\n\t\tNode* newNode = new Node(l->data + r->data);\n\t\tnewNode->left = l;\n\t\tnewNode->right = r;\n\t\tpq.push(newNode);\n\t}\n\tNode* root = pq.top();\n\tvector<string> ans;\n\tpreOrder(root, ans, \"\");\n\treturn ans;\n}\nint main() {\n\tstring s = \"abcdef\";\n\tvector<int> freq = {5, 9, 12, 13, 16, 45};\n\tvector<string> ans = huffmanCodes(s, freq);\n\tfor (int i=0; i< ans.size(); i++) {\n\t    cout << ans[i] << \" \";\n\t}\n\treturn 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/huffman-coding-greedy-algo-3/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "# Python program for the above approach:\nimport heapq\n# Class to represent huffman tree\nclass Node:\n\tdef __init__(self, x):\n\t\tself.data = x\n\t\tself.left = None\n\t\tself.right = None\n\tdef __lt__(self, other):\n\t\treturn self.data < other.data\n# Function to traverse tree in preorder\n# manner and push the huffman representation\n# of each character.\ndef preOrder(root, ans, curr):\n\tif root is None:\n\t\treturn\n\t# Leaf node represents a character.\n\tif root.left is None and root.right is None:\n\t\tans.append(curr)\n\t\treturn\n\tpreOrder(root.left, ans, curr + '0')\n\tpreOrder(root.right, ans, curr + '1')\ndef huffmanCodes(s, freq):\n\t# Code here\n\tn = len(s)\n\t# Min heap for node class.\n\tpq = []\n\tfor i in range(n):\n\t\ttmp = Node(freq[i])\n\t\theapq.heappush(pq, tmp)\n\t# Construct huffman tree.\n\twhile len(pq) >= 2:\n\t\t# Left node\n\t\tl = heapq.heappop(pq)\n\t\t# Right node\n\t\tr = heapq.heappop(pq)\n\t\tnewNode = Node(l.data + r.data)\n\t\tnewNode.left = l\n\t\tnewNode.right = r\n\t\theapq.heappush(pq, newNode)\n\troot = heapq.heappop(pq)\n\tans = []\n\tpreOrder(root, ans, \"\")\n\treturn ans\nif __name__ == \"__main__\":\n\ts = \"abcdef\"\n\tfreq = [5, 9, 12, 13, 16, 45]\n\tans = huffmanCodes(s, freq)\n\tfor code in ans:\n\t\tprint(code, end=\" \")",
    "code_without_comments": "\nimport heapq\n\nclass Node:\n\tdef __init__(self, x):\n\t\tself.data = x\n\t\tself.left = None\n\t\tself.right = None\n\tdef __lt__(self, other):\n\t\treturn self.data < other.data\n\n\n\ndef preOrder(root, ans, curr):\n\tif root is None:\n\t\treturn\n\n\tif root.left is None and root.right is None:\n\t\tans.append(curr)\n\t\treturn\n\tpreOrder(root.left, ans, curr + '0')\n\tpreOrder(root.right, ans, curr + '1')\ndef huffmanCodes(s, freq):\n\n\tn = len(s)\n\n\tpq = []\n\tfor i in range(n):\n\t\ttmp = Node(freq[i])\n\t\theapq.heappush(pq, tmp)\n\n\twhile len(pq) >= 2:\n\n\t\tl = heapq.heappop(pq)\n\n\t\tr = heapq.heappop(pq)\n\t\tnewNode = Node(l.data + r.data)\n\t\tnewNode.left = l\n\t\tnewNode.right = r\n\t\theapq.heappush(pq, newNode)\n\troot = heapq.heappop(pq)\n\tans = []\n\tpreOrder(root, ans, \"\")\n\treturn ans\nif __name__ == \"__main__\":\n\ts = \"abcdef\"\n\tfreq = [5, 9, 12, 13, 16, 45]\n\tans = huffmanCodes(s, freq)\n\tfor code in ans:\n\t\tprint(code, end=\" \")",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/huffman-coding-greedy-algo-3/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n// Comparison function to sort items based on value/weight ratio\nbool compare(vector<int>& a, vector<int>& b) {\n    double a1 = (1.0 * a[0]) / a[1];\n    double b1 = (1.0 * b[0]) / b[1];\n    return a1 > b1;\n}\ndouble fractionalKnapsack(vector<int>& val, vector<int>& wt, int capacity) {\n    int n = val.size();\n    // Create 2D vector to store value and weight\n    // items[i][0] = value, items[i][1] = weight\n    vector<vector<int>> items(n, vector<int>(2));\n    for (int i = 0; i < n; i++) {\n        items[i][0] = val[i];\n        items[i][1] = wt[i];\n    }\n    // Sort items based on value-to-weight ratio in descending order\n    sort(items.begin(), items.end(), compare);\n    double res = 0.0;\n    int currentCapacity = capacity;\n    // Process items in sorted order\n    for (int i = 0; i < n; i++) {\n        // If we can take the entire item\n        if (items[i][1] <= currentCapacity) {\n            res += items[i][0];\n            currentCapacity -= items[i][1];\n        }\n        // Otherwise take a fraction of the item\n        else {\n            res += (1.0 * items[i][0] / items[i][1]) * currentCapacity;\n            // Knapsack is full\n            break;\n        }\n    }\n    return res;\n}\nint main() {\n    vector<int> val = {60, 100, 120};\n    vector<int> wt = {10, 20, 30};\n    int capacity = 50;\n    cout << fractionalKnapsack(val, wt, capacity) << endl;\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nbool compare(vector<int>& a, vector<int>& b) {\n    double a1 = (1.0 * a[0]) / a[1];\n    double b1 = (1.0 * b[0]) / b[1];\n    return a1 > b1;\n}\ndouble fractionalKnapsack(vector<int>& val, vector<int>& wt, int capacity) {\n    int n = val.size();\n\n\n    vector<vector<int>> items(n, vector<int>(2));\n    for (int i = 0; i < n; i++) {\n        items[i][0] = val[i];\n        items[i][1] = wt[i];\n    }\n\n    sort(items.begin(), items.end(), compare);\n    double res = 0.0;\n    int currentCapacity = capacity;\n\n    for (int i = 0; i < n; i++) {\n\n        if (items[i][1] <= currentCapacity) {\n            res += items[i][0];\n            currentCapacity -= items[i][1];\n        }\n\n        else {\n            res += (1.0 * items[i][0] / items[i][1]) * currentCapacity;\n\n            break;\n        }\n    }\n    return res;\n}\nint main() {\n    vector<int> val = {60, 100, 120};\n    vector<int> wt = {10, 20, 30};\n    int capacity = 50;\n    cout << fractionalKnapsack(val, wt, capacity) << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/fractional-knapsack-problem/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def compare(a, b):\n    a1 = (1.0 * a[0]) / a[1]\n    b1 = (1.0 * b[0]) / b[1]\n    return b1 - a1\ndef fractionalKnapsack(val, wt, capacity):\n    n = len(val)\n    # Create list to store value and weight\n    # items[i][0] = value, items[i][1] = weight\n    items = [[val[i], wt[i]] for i in range(n)]\n    # Sort items based on value-to-weight ratio in descending order\n    items.sort(key=lambda x: x[0]/x[1], reverse=True)\n    res = 0.0\n    currentCapacity = capacity\n    # Process items in sorted order\n    for i in range(n):\n        # If we can take the entire item\n        if items[i][1] <= currentCapacity:\n            res += items[i][0]\n            currentCapacity -= items[i][1]\n        # Otherwise take a fraction of the item\n        else:\n            res += (1.0 * items[i][0] / items[i][1]) * currentCapacity\n            # Knapsack is full\n            break\n    return res\nif __name__ == \"__main__\":\n    val = [60, 100, 120]\n    wt = [10, 20, 30]\n    capacity = 50\n    print(fractionalKnapsack(val, wt, capacity))",
    "code_without_comments": "def compare(a, b):\n    a1 = (1.0 * a[0]) / a[1]\n    b1 = (1.0 * b[0]) / b[1]\n    return b1 - a1\ndef fractionalKnapsack(val, wt, capacity):\n    n = len(val)\n\n\n    items = [[val[i], wt[i]] for i in range(n)]\n\n    items.sort(key=lambda x: x[0]/x[1], reverse=True)\n    res = 0.0\n    currentCapacity = capacity\n\n    for i in range(n):\n\n        if items[i][1] <= currentCapacity:\n            res += items[i][0]\n            currentCapacity -= items[i][1]\n\n        else:\n            res += (1.0 * items[i][0] / items[i][1]) * currentCapacity\n\n            break\n    return res\nif __name__ == \"__main__\":\n    val = [60, 100, 120]\n    wt = [10, 20, 30]\n    capacity = 50\n    print(fractionalKnapsack(val, wt, capacity))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/fractional-knapsack-problem/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nbool twoSum(vector<int> &arr, int target) {\n    int n = arr.size();\n    // Consider all pairs (arr[i], arr[j])\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            // Check if the sum of the current pair\n            // equals the target\n            if (arr[i] + arr[j] == target) {\n                return true;\n            }\n        }\n    }\n    // If no pair is found after checking all\n    return false;\n}\nint main() {\n    vector<int> arr = {0, -1, 2, -3, 1};\n    int target = -2;\n    cout << ((twoSum(arr, target))? \"true\" : \"false\");\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nbool twoSum(vector<int> &arr, int target) {\n    int n = arr.size();\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n\n\n            if (arr[i] + arr[j] == target) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\nint main() {\n    vector<int> arr = {0, -1, 2, -3, 1};\n    int target = -2;\n    cout << ((twoSum(arr, target))? \"true\" : \"false\");\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/two-pointers-technique/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <stdbool.h>\n#include <stdio.h>\n// Function to check whether any pair exists\n// whose sum is equal to the given target value\nbool twoSum(int arr[], int n, int target){\n    // Iterate through each element in the array\n    for (int i = 0; i < n; i++){\n        // For each element arr[i], check every\n        // other element arr[j] that comes after it\n        for (int j = i + 1; j < n; j++){\n            // Check if the sum of the current pair\n            // equals the target\n            if (arr[i] + arr[j] == target)\n                return true;\n        }\n    }\n    // If no pair is found after checking\n    // all possibilities\n    return false;\n}\nint main(){\n    int arr[] = {0, -1, 2, -3, 1};\n    int target = -2;\n    int n = sizeof(arr) / sizeof(arr[0]);\n    // Call the twoSum function and print the result\n    if (twoSum(arr, n, target))\n        printf(\"true\\n\");\n    else\n        printf(\"false\\n\");\n    return 0;\n}",
    "code_without_comments": "#include <stdbool.h>\n#include <stdio.h>\n\n\nbool twoSum(int arr[], int n, int target){\n\n    for (int i = 0; i < n; i++){\n\n\n        for (int j = i + 1; j < n; j++){\n\n\n            if (arr[i] + arr[j] == target)\n                return true;\n        }\n    }\n\n\n    return false;\n}\nint main(){\n    int arr[] = {0, -1, 2, -3, 1};\n    int target = -2;\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    if (twoSum(arr, n, target))\n        printf(\"true\\n\");\n    else\n        printf(\"false\\n\");\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/two-pointers-technique/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "# Function to check whether any pair exists\n# whose sum is equal to the given target value\ndef two_sum(arr, target):\n    n = len(arr)\n    # Iterate through each element in the array\n    for i in range(n):\n        # For each element arr[i], check every\n        # other element arr[j] that comes after it\n        for j in range(i + 1, n):\n            # Check if the sum of the current pair\n            # equals the target\n            if arr[i] + arr[j] == target:\n                return True\n    # If no pair is found after checking\n    # all possibilities\n    return False\narr = [0, -1, 2, -3, 1]\ntarget = -2\n# Call the two_sum function and print the result\nif two_sum(arr, target):\n    print(\"true\")\nelse:\n    print(\"false\")",
    "code_without_comments": "\n\ndef two_sum(arr, target):\n    n = len(arr)\n\n    for i in range(n):\n\n\n        for j in range(i + 1, n):\n\n\n            if arr[i] + arr[j] == target:\n                return True\n\n\n    return False\narr = [0, -1, 2, -3, 1]\ntarget = -2\n\nif two_sum(arr, target):\n    print(\"true\")\nelse:\n    print(\"false\")",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/two-pointers-technique/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nbool twoSum(vector<int> &arr, int target){\n    int left = 0, right = arr.size() - 1;\n    while (left < right){\n        int sum = arr[left] + arr[right];\n        if (sum == target)\n            return true;\n        // Move toward a higher sum\n        else if (sum < target)\n            left++;\n        // Move toward a lower sum\n        else\n            right--;\n    }\n    // If no pair found\n    return false;\n}\nint main(){\n    vector<int> arr = {-3, -1, 0, 1, 2};\n    int target = -2;\n    if (twoSum(arr, target))\n        cout << \"true\";\n    else\n        cout << \"false\";\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nbool twoSum(vector<int> &arr, int target){\n    int left = 0, right = arr.size() - 1;\n    while (left < right){\n        int sum = arr[left] + arr[right];\n        if (sum == target)\n            return true;\n\n        else if (sum < target)\n            left++;\n\n        else\n            right--;\n    }\n\n    return false;\n}\nint main(){\n    vector<int> arr = {-3, -1, 0, 1, 2};\n    int target = -2;\n    if (twoSum(arr, target))\n        cout << \"true\";\n    else\n        cout << \"false\";\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/two-pointers-technique/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n// Comparison function for qsort\nint compare(const void *a, const void *b){\n    return (*(int *)a - *(int *)b);\n}\n// Function to check whether any pair exists\n// whose sum is equal to the given target value\nbool twoSum(int arr[], int n, int target){\n    // Sort the array\n    int left = 0, right = n - 1;\n    // Iterate while left pointer is less than right\n    while (left < right){\n        int sum = arr[left] + arr[right];\n        // Check if the sum matches the target\n        if (sum == target)\n            return true;\n        else if (sum < target)\n            left++; // Move left pointer to the right\n        else\n            right--; // Move right pointer to the left\n    }\n    // If no pair  found\n    return false;\n}\nint main(){\n    int arr[] = {-3, -1, 0, 1, 2};\n    int target = -2;\n    int n = sizeof(arr) / sizeof(arr[0]);\n    // Call the twoSum function and print the result\n    if (twoSum(arr, n, target))\n        printf(\"true\\n\");\n    else\n        printf(\"false\\n\");\n    return 0;\n}",
    "code_without_comments": "#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint compare(const void *a, const void *b){\n    return (*(int *)a - *(int *)b);\n}\n\n\nbool twoSum(int arr[], int n, int target){\n\n    int left = 0, right = n - 1;\n\n    while (left < right){\n        int sum = arr[left] + arr[right];\n\n        if (sum == target)\n            return true;\n        else if (sum < target)\n            left++;\n        else\n            right--;\n    }\n\n    return false;\n}\nint main(){\n    int arr[] = {-3, -1, 0, 1, 2};\n    int target = -2;\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    if (twoSum(arr, n, target))\n        printf(\"true\\n\");\n    else\n        printf(\"false\\n\");\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/two-pointers-technique/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "# Function to check whether any pair exists\n# whose sum is equal to the given target value\ndef two_sum(arr, target):\n    # Sort the array\n    left, right = 0, len(arr) - 1\n    # Iterate while left pointer is less than right\n    while left < right:\n        sum = arr[left] + arr[right]\n        # Check if the sum matches the target\n        if sum == target:\n            return True\n        elif sum < target:\n            left += 1  # Move left pointer to the right\n        else:\n            right -= 1 # Move right pointer to the left\n    # If no pair is found\n    return False\narr = [-3, -1, 0, 1, 2]\ntarget = -2\n# Call the two_sum function and print the result\nif two_sum(arr, target):\n    print(\"true\")\nelse:\n    print(\"false\")",
    "code_without_comments": "\n\ndef two_sum(arr, target):\n\n    left, right = 0, len(arr) - 1\n\n    while left < right:\n        sum = arr[left] + arr[right]\n\n        if sum == target:\n            return True\n        elif sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\narr = [-3, -1, 0, 1, 2]\ntarget = -2\n\nif two_sum(arr, target):\n    print(\"true\")\nelse:\n    print(\"false\")",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/two-pointers-technique/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\nint maxSum(vector<int>& arr, int k) {\n    int n = arr.size();\n    int max_sum = INT_MIN;\n    // Consider all blocks starting with i\n    for (int i = 0; i <= n - k; i++) {\n        int current_sum = 0;\n        // Calculate sum of current subarray of size k\n        for (int j = 0; j < k; j++)\n            current_sum += arr[i + j];\n        // Update result if required\n        max_sum = max(current_sum, max_sum);\n    }\n    return max_sum;\n}\nint main() {\n    vector<int> arr = {5, 2, -1, 0, 3};\n    int k = 3;\n    cout << maxSum(arr, k) << endl;\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\nint maxSum(vector<int>& arr, int k) {\n    int n = arr.size();\n    int max_sum = INT_MIN;\n\n    for (int i = 0; i <= n - k; i++) {\n        int current_sum = 0;\n\n        for (int j = 0; j < k; j++)\n            current_sum += arr[i + j];\n\n        max_sum = max(current_sum, max_sum);\n    }\n    return max_sum;\n}\nint main() {\n    vector<int> arr = {5, 2, -1, 0, 3};\n    int k = 3;\n    cout << maxSum(arr, k) << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/window-sliding-technique/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <limits.h>\n#include <math.h>\n#include <stdio.h>\n// Find maximum between two numbers.\nint max(int num1, int num2){\n    return (num1 > num2) ? num1 : num2;\n}\nint maxSum(int arr[], int n, int k){\n    // Initialize result\n    int max_sum = INT_MIN;\n    // Consider all blocks starting with i.\n    for (int i = 0; i < n - k + 1; i++) {\n        int current_sum = 0;\n        for (int j = 0; j < k; j++)\n            current_sum = current_sum + arr[i + j];\n        // Update result if required.\n        max_sum = max(current_sum, max_sum);\n    }\n    return max_sum;\n}\n// Driver code\nint main(){\n    int arr[] = {5, 2, -1, 0, 3};\n    int k = 3;\n    int n = sizeof(arr) / sizeof(arr[0]);\n    printf(\"%d\", maxSum(arr, n, k));\n    return 0;\n}",
    "code_without_comments": "#include <limits.h>\n#include <math.h>\n#include <stdio.h>\n\nint max(int num1, int num2){\n    return (num1 > num2) ? num1 : num2;\n}\nint maxSum(int arr[], int n, int k){\n\n    int max_sum = INT_MIN;\n\n    for (int i = 0; i < n - k + 1; i++) {\n        int current_sum = 0;\n        for (int j = 0; j < k; j++)\n            current_sum = current_sum + arr[i + j];\n\n        max_sum = max(current_sum, max_sum);\n    }\n    return max_sum;\n}\n\nint main(){\n    int arr[] = {5, 2, -1, 0, 3};\n    int k = 3;\n    int n = sizeof(arr) / sizeof(arr[0]);\n    printf(\"%d\", maxSum(arr, n, k));\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/window-sliding-technique/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "import sys\ndef maxSum(arr, n, k):\n    # Initialize result\n    max_sum = -sys.maxsize\n    # Consider all blocks starting with i.\n    for i in range(n - k + 1):\n        current_sum = 0\n        for j in range(k):\n            current_sum += arr[i + j]\n        # Update result if required.\n        max_sum = max(current_sum, max_sum)\n    return max_sum\nif __name__ == \"__main__\":\n    arr = [5, 2, -1, 0, 3]\n    k = 3\n    n = len(arr)\n    print(maxSum(arr, n, k))",
    "code_without_comments": "import sys\ndef maxSum(arr, n, k):\n\n    max_sum = -sys.maxsize\n\n    for i in range(n - k + 1):\n        current_sum = 0\n        for j in range(k):\n            current_sum += arr[i + j]\n\n        max_sum = max(current_sum, max_sum)\n    return max_sum\nif __name__ == \"__main__\":\n    arr = [5, 2, -1, 0, 3]\n    k = 3\n    n = len(arr)\n    print(maxSum(arr, n, k))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/window-sliding-technique/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nint maxSum(vector<int>& arr, int k){\n    int n = arr.size();\n    // n must be greater\n    if (n <= k) {\n        cout << \"Invalid\";\n        return -1;\n    }\n    // Compute sum of first window of size k\n    int max_sum = 0;\n    for (int i = 0; i < k; i++)\n        max_sum += arr[i];\n    // Compute sums of remaining windows by\n    // removing first element of previous\n    // window and adding last element of\n    // current window.\n    int window_sum = max_sum;\n    for (int i = k; i < n; i++) {\n        window_sum += arr[i] - arr[i - k];\n        max_sum = max(max_sum, window_sum);\n    }\n    return max_sum;\n}\nint main(){\n    vector<int> arr = {5, 2, -1, 0, 3};\n    int k = 3;\n    cout << maxSum(arr, k);\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nint maxSum(vector<int>& arr, int k){\n    int n = arr.size();\n\n    if (n <= k) {\n        cout << \"Invalid\";\n        return -1;\n    }\n\n    int max_sum = 0;\n    for (int i = 0; i < k; i++)\n        max_sum += arr[i];\n\n\n\n\n    int window_sum = max_sum;\n    for (int i = k; i < n; i++) {\n        window_sum += arr[i] - arr[i - k];\n        max_sum = max(max_sum, window_sum);\n    }\n    return max_sum;\n}\nint main(){\n    vector<int> arr = {5, 2, -1, 0, 3};\n    int k = 3;\n    cout << maxSum(arr, k);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/window-sliding-technique/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def maxSum(arr, k):\n    # length of the array\n    n = len(arr)\n    # n must be greater than k\n    if n <= k:\n        print(\"Invalid\")\n        return -1\n    # Compute sum of first window of size k\n    window_sum = sum(arr[:k])\n    # first sum available\n    max_sum = window_sum\n    # Compute the sums of remaining windows by\n    # removing first element of previous\n    # window and adding last element of\n    # the current window.\n    for i in range(n - k):\n        window_sum = window_sum - arr[i] + arr[i + k]\n        max_sum = max(window_sum, max_sum)\n    return max_sum\nif __name__ == \"__main__\":\n    arr = [5, 2, -1, 0, 3]\n    k = 3\n    print(maxSum(arr, k))",
    "code_without_comments": "def maxSum(arr, k):\n\n    n = len(arr)\n\n    if n <= k:\n        print(\"Invalid\")\n        return -1\n\n    window_sum = sum(arr[:k])\n\n    max_sum = window_sum\n\n\n\n\n    for i in range(n - k):\n        window_sum = window_sum - arr[i] + arr[i + k]\n        max_sum = max(window_sum, max_sum)\n    return max_sum\nif __name__ == \"__main__\":\n    arr = [5, 2, -1, 0, 3]\n    k = 3\n    print(maxSum(arr, k))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/window-sliding-technique/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nclass DisjointUnionSets {\n    vector<int> rank, parent;\npublic:\n    // Constructor to initialize sets\n    DisjointUnionSets(int n) {\n        rank.resize(n, 0);\n        parent.resize(n);\n        // Initially, each element is in its own set\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n    // Find the representative of the set that x belongs to\n    int find(int i) {\n        int root = parent[i];\n        // Path Compression\n        if (parent[root] != root) {\n            return parent[i] = find(root);\n        }\n        return root;\n    }\n    // Union of sets containing x and y\n    void unionSets(int x, int y) {\n        int xRoot = find(x);\n        int yRoot = find(y);\n        // If they are in the same set, no need to union\n        if (xRoot == yRoot) return;\n        // Union by rank\n        if (rank[xRoot] < rank[yRoot]) {\n            parent[xRoot] = yRoot;\n        } else if (rank[yRoot] < rank[xRoot]) {\n            parent[yRoot] = xRoot;\n        } else {\n            parent[yRoot] = xRoot;\n            rank[xRoot]++;\n        }\n    }\n};\nint main() {\n    // Let there be 5 persons with ids 0, 1, 2, 3, and 4\n    int n = 5;\n    DisjointUnionSets dus(n);\n    // 0 is a friend of 2\n    dus.unionSets(0, 2);\n    // 4 is a friend of 2\n    dus.unionSets(4, 2);\n    // 3 is a friend of 1\n    dus.unionSets(3, 1);\n    // Check if 4 is a friend of 0\n    if (dus.find(4) == dus.find(0))\n        cout << \"Yes\\n\";\n    else\n        cout << \"No\\n\";\n    // Check if 1 is a friend of 0\n    if (dus.find(1) == dus.find(0))\n        cout << \"Yes\\n\";\n    else\n        cout << \"No\\n\";\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nclass DisjointUnionSets {\n    vector<int> rank, parent;\npublic:\n\n    DisjointUnionSets(int n) {\n        rank.resize(n, 0);\n        parent.resize(n);\n\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int i) {\n        int root = parent[i];\n\n        if (parent[root] != root) {\n            return parent[i] = find(root);\n        }\n        return root;\n    }\n\n    void unionSets(int x, int y) {\n        int xRoot = find(x);\n        int yRoot = find(y);\n\n        if (xRoot == yRoot) return;\n\n        if (rank[xRoot] < rank[yRoot]) {\n            parent[xRoot] = yRoot;\n        } else if (rank[yRoot] < rank[xRoot]) {\n            parent[yRoot] = xRoot;\n        } else {\n            parent[yRoot] = xRoot;\n            rank[xRoot]++;\n        }\n    }\n};\nint main() {\n\n    int n = 5;\n    DisjointUnionSets dus(n);\n\n    dus.unionSets(0, 2);\n\n    dus.unionSets(4, 2);\n\n    dus.unionSets(3, 1);\n\n    if (dus.find(4) == dus.find(0))\n        cout << \"Yes\\n\";\n    else\n        cout << \"No\\n\";\n\n    if (dus.find(1) == dus.find(0))\n        cout << \"Yes\\n\";\n    else\n        cout << \"No\\n\";\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/union-find-algorithm-set-2-union-by-rank/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "class DisjointUnionSets:\n    def __init__(self, n):\n        self.rank = [0] * n\n        self.parent = list(range(n))\n    def find(self, i):\n        root = self.parent[i]\n        # Path Compression\n        if self.parent[root] != root:\n            self.parent[i] = self.find(root)\n            return self.parent[i]\n        return root\n    def unionSets(self, x, y):\n        xRoot = self.find(x)\n        yRoot = self.find(y)\n        if xRoot == yRoot:\n            return\n        # Union by Rank\n        if self.rank[xRoot] < self.rank[yRoot]:\n            self.parent[xRoot] = yRoot\n        elif self.rank[yRoot] < self.rank[xRoot]:\n            self.parent[yRoot] = xRoot\n        else:\n            self.parent[yRoot] = xRoot\n            self.rank[xRoot] += 1\nif __name__ == '__main__':\n    n = 5  # Let there be 5 persons with ids 0, 1, 2, 3, and 4\n    dus = DisjointUnionSets(n)\n    dus.unionSets(0, 2)  # 0 is a friend of 2\n    dus.unionSets(4, 2)  # 4 is a friend of 2\n    dus.unionSets(3, 1)  # 3 is a friend of 1\n    # Check if 4 is a friend of 0\n    if dus.find(4) == dus.find(0):\n        print('Yes')\n    else:\n        print('No')\n    # Check if 1 is a friend of 0\n    if dus.find(1) == dus.find(0):\n        print('Yes')\n    else:\n        print('No')",
    "code_without_comments": "class DisjointUnionSets:\n    def __init__(self, n):\n        self.rank = [0] * n\n        self.parent = list(range(n))\n    def find(self, i):\n        root = self.parent[i]\n\n        if self.parent[root] != root:\n            self.parent[i] = self.find(root)\n            return self.parent[i]\n        return root\n    def unionSets(self, x, y):\n        xRoot = self.find(x)\n        yRoot = self.find(y)\n        if xRoot == yRoot:\n            return\n\n        if self.rank[xRoot] < self.rank[yRoot]:\n            self.parent[xRoot] = yRoot\n        elif self.rank[yRoot] < self.rank[xRoot]:\n            self.parent[yRoot] = xRoot\n        else:\n            self.parent[yRoot] = xRoot\n            self.rank[xRoot] += 1\nif __name__ == '__main__':\n    n = 5\n    dus = DisjointUnionSets(n)\n    dus.unionSets(0, 2)\n    dus.unionSets(4, 2)\n    dus.unionSets(3, 1)\n\n    if dus.find(4) == dus.find(0):\n        print('Yes')\n    else:\n        print('No')\n\n    if dus.find(1) == dus.find(0):\n        print('Yes')\n    else:\n        print('No')",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/union-find-algorithm-set-2-union-by-rank/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "// C++ program for Union by Size with Path Compression\n#include <iostream>\n#include <vector>\nusing namespace std;\nclass UnionFind {\n    vector<int> Parent;\n    vector<int> Size;\npublic:\n    UnionFind(int n) {\n        Parent.resize(n);\n        for (int i = 0; i < n; i++) {\n            Parent[i] = i;\n        }\n        // Initialize Size array with 1s\n        Size.resize(n, 1);\n    }\n    // Function to find the representative (or the root\n    // node) for the set that includes i\n    int find(int i) {\n        int root = Parent[i];\n        if (Parent[root] != root) {\n            return Parent[i] = find(root);\n        }\n        return root;\n    }\n    // Unites the set that includes i and the set that\n    // includes j by size\n    void unionBySize(int i, int j) {\n        // Find the representatives (or the root nodes) for\n        // the set that includes i\n        int irep = find(i);\n        // And do the same for the set that includes j\n        int jrep = find(j);\n        // Elements are in the same set, no need to unite\n        // anything.\n        if (irep == jrep)\n            return;\n        // Get the size of is tree\n        int isize = Size[irep];\n        // Get the size of js tree\n        int jsize = Size[jrep];\n        // If is size is less than js size\n        if (isize < jsize) {\n            // Then move i under j\n            Parent[irep] = jrep;\n            // Increment j's size by i's size\n            Size[jrep] += Size[irep];\n        }\n        // Else if js size is less than is size\n        else {\n            // Then move j under i\n            Parent[jrep] = irep;\n            // Increment i's size by j's size\n            Size[irep] += Size[jrep];\n        }\n    }\n};\nint main() {\n    int n = 5;\n    UnionFind unionFind(n);\n    unionFind.unionBySize(0, 1);\n    unionFind.unionBySize(2, 3);\n    unionFind.unionBySize(0, 4);\n    for (int i = 0; i < n; i++) {\n        cout << \"Element \" << i << \": Representative = \"\n             << unionFind.find(i) << endl;\n    }\n    return 0;\n}",
    "code_without_comments": "\n#include <iostream>\n#include <vector>\nusing namespace std;\nclass UnionFind {\n    vector<int> Parent;\n    vector<int> Size;\npublic:\n    UnionFind(int n) {\n        Parent.resize(n);\n        for (int i = 0; i < n; i++) {\n            Parent[i] = i;\n        }\n\n        Size.resize(n, 1);\n    }\n\n\n    int find(int i) {\n        int root = Parent[i];\n        if (Parent[root] != root) {\n            return Parent[i] = find(root);\n        }\n        return root;\n    }\n\n\n    void unionBySize(int i, int j) {\n\n\n        int irep = find(i);\n\n        int jrep = find(j);\n\n\n        if (irep == jrep)\n            return;\n\n        int isize = Size[irep];\n\n        int jsize = Size[jrep];\n\n        if (isize < jsize) {\n\n            Parent[irep] = jrep;\n\n            Size[jrep] += Size[irep];\n        }\n\n        else {\n\n            Parent[jrep] = irep;\n\n            Size[irep] += Size[jrep];\n        }\n    }\n};\nint main() {\n    int n = 5;\n    UnionFind unionFind(n);\n    unionFind.unionBySize(0, 1);\n    unionFind.unionBySize(2, 3);\n    unionFind.unionBySize(0, 4);\n    for (int i = 0; i < n; i++) {\n        cout << \"Element \" << i << \": Representative = \"\n             << unionFind.find(i) << endl;\n    }\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/union-find-algorithm-set-2-union-by-rank/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "class UnionFind:\n    def __init__(self, n):\n        self.Parent = list(range(n))\n        self.Size = [1] * n\n    # Function to find the representative (or the root\n    # node) for the set that includes i\n    def find(self, i):\n        root = self.Parent[i]\n        if self.Parent[root] != root:\n            self.Parent[i] = self.find(root)\n            return self.Parent[i]\n        return root\n    # Unites the set that includes i and the set that\n    # includes j by size\n    def unionBySize(self, i, j):\n        # Find the representatives (or the root nodes) for\n        # the set that includes i\n        irep = self.find(i)\n        # And do the same for the set that includes j\n        jrep = self.find(j)\n        # Elements are in the same set, no need to unite\n        # anything.\n        if irep == jrep:\n            return\n        # Get the size of is tree\n        isize = self.Size[irep]\n        # Get the size of js tree\n        jsize = self.Size[jrep]\n        # If is size is less than js size\n        if isize < jsize:\n            # Then move i under j\n            self.Parent[irep] = jrep\n            # Increment j's size by i's size\n            self.Size[jrep] += self.Size[irep]\n        # Else if js size is less than is size\n        else:\n            # Then move j under i\n            self.Parent[jrep] = irep\n            # Increment i's size by j's size\n            self.Size[irep] += self.Size[jrep]\nn = 5\nunionFind = UnionFind(n)\nunionFind.unionBySize(0, 1)\nunionFind.unionBySize(2, 3)\nunionFind.unionBySize(0, 4)\nfor i in range(n):\n    print(f'Element {i}: Representative = {unionFind.find(i)}')",
    "code_without_comments": "class UnionFind:\n    def __init__(self, n):\n        self.Parent = list(range(n))\n        self.Size = [1] * n\n\n\n    def find(self, i):\n        root = self.Parent[i]\n        if self.Parent[root] != root:\n            self.Parent[i] = self.find(root)\n            return self.Parent[i]\n        return root\n\n\n    def unionBySize(self, i, j):\n\n\n        irep = self.find(i)\n\n        jrep = self.find(j)\n\n\n        if irep == jrep:\n            return\n\n        isize = self.Size[irep]\n\n        jsize = self.Size[jrep]\n\n        if isize < jsize:\n\n            self.Parent[irep] = jrep\n            # Increment j's size by i's size\n            self.Size[jrep] += self.Size[irep]\n\n        else:\n\n            self.Parent[jrep] = irep\n            # Increment i's size by j's size\n            self.Size[irep] += self.Size[jrep]\nn = 5\nunionFind = UnionFind(n)\nunionFind.unionBySize(0, 1)\nunionFind.unionBySize(2, 3)\nunionFind.unionBySize(0, 4)\nfor i in range(n):\n    print(f'Element {i}: Representative = {unionFind.find(i)}')",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/union-find-algorithm-set-2-union-by-rank/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <bits/stdc++.h>\nusing namespace std;\n// Function to perform DFS and topological sorting\nvoid topologicalSortUtil(string v, unordered_map<string, string> &mp, unordered_map<string, int> &visited, stack<string> &st) {\n    // Mark the current node as visited\n    visited[v] = 1;\n    // Recur for adjacent vertex\n    if (mp.find(v) != mp.end() && visited[mp[v]] == 0)\n        topologicalSortUtil(mp[v], mp, visited, st);\n    // Push current vertex onto stack\n    if (!v.empty())\n        st.push(v);\n}\n// Function to perform topological sort\nvector<string> topologicalSort(unordered_map<string, string> &mp) {\n    stack<string> st;\n    unordered_map<string, int> visited;\n    // Perform DFS for all vertices\n    for (auto &i : mp) {\n        if (visited[i.first] == 0)\n            topologicalSortUtil(i.first, mp, visited, st);\n    }\n    vector<string> ans;\n    while (!st.empty()) {\n        ans.push_back(st.top());\n        st.pop();\n    }\n    return ans;\n}\n// Function to find the itinerary order\nvector<vector<string>> findItinerary(vector<vector<string>> &arr) {\n    unordered_map<string, string> mp;\n    // Map the list of tickets\n    for (auto &i : arr) {\n        mp[i[0]] = i[1];\n    }\n    vector<string> res = topologicalSort(mp);\n    vector<vector<string>> ans;\n    // Create itinerary pairs\n    for (size_t i = 0; i < res.size() - 1; i++) {\n        ans.push_back({res[i], res[i + 1]});\n    }\n    return ans;\n}\nint main() {\n    vector<vector<string>> arr = {\n        {\"Chennai\", \"Bangalore\"},\n        {\"Bombay\", \"Delhi\"},\n        {\"Goa\", \"Chennai\"},\n        {\"Delhi\", \"Goa\"}\n    };\n    vector<vector<string>> res = findItinerary(arr);\n    for (auto &i : res) {\n        cout << i[0] << \" -> \" << i[1] << endl;\n    }\n    return 0;\n}",
    "code_without_comments": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid topologicalSortUtil(string v, unordered_map<string, string> &mp, unordered_map<string, int> &visited, stack<string> &st) {\n\n    visited[v] = 1;\n\n    if (mp.find(v) != mp.end() && visited[mp[v]] == 0)\n        topologicalSortUtil(mp[v], mp, visited, st);\n\n    if (!v.empty())\n        st.push(v);\n}\n\nvector<string> topologicalSort(unordered_map<string, string> &mp) {\n    stack<string> st;\n    unordered_map<string, int> visited;\n\n    for (auto &i : mp) {\n        if (visited[i.first] == 0)\n            topologicalSortUtil(i.first, mp, visited, st);\n    }\n    vector<string> ans;\n    while (!st.empty()) {\n        ans.push_back(st.top());\n        st.pop();\n    }\n    return ans;\n}\n\nvector<vector<string>> findItinerary(vector<vector<string>> &arr) {\n    unordered_map<string, string> mp;\n\n    for (auto &i : arr) {\n        mp[i[0]] = i[1];\n    }\n    vector<string> res = topologicalSort(mp);\n    vector<vector<string>> ans;\n\n    for (size_t i = 0; i < res.size() - 1; i++) {\n        ans.push_back({res[i], res[i + 1]});\n    }\n    return ans;\n}\nint main() {\n    vector<vector<string>> arr = {\n        {\"Chennai\", \"Bangalore\"},\n        {\"Bombay\", \"Delhi\"},\n        {\"Goa\", \"Chennai\"},\n        {\"Delhi\", \"Goa\"}\n    };\n    vector<vector<string>> res = findItinerary(arr);\n    for (auto &i : res) {\n        cout << i[0] << \" -> \" << i[1] << endl;\n    }\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/find-itinerary-from-a-given-list-of-tickets/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "# Function to perform DFS and topological sorting\ndef topologicalSortUtil(v, mp, visited, st):\n    # mark current node as visited\n    visited[v] = 1\n    # recur for adjacent vertex\n    if v in mp and visited.get(mp[v], 0) == 0:\n        topologicalSortUtil(mp[v], mp, visited, st)\n    # push current vertex in stack\n    if v:\n        st.append(v)\n# Function to perform topological sort\ndef topologicalSort(mp):\n    V = len(mp)\n    # stack to store the result\n    st = []\n    visited = {}\n    # Call the recursive helper function to store\n    # Topological Sort starting from all vertices\n    for i in mp:\n        if visited.get(i, 0) == 0:\n            topologicalSortUtil(i, mp, visited, st)\n    return st[::-1]\ndef findItinerary(arr):\n    # map the list of tickets\n    mp = {i[0]: i[1] for i in arr}\n    res = topologicalSort(mp)\n    ans = []\n    for i in range(len(res) - 1):\n        ans.append([res[i], res[i + 1]])\n    return ans\nif __name__ == \"__main__\":\n    arr = [\n        [\"Chennai\", \"Bangalore\"],\n        [\"Bombay\", \"Delhi\"],\n        [\"Goa\", \"Chennai\"],\n        [\"Delhi\", \"Goa\"]\n    ]\n    res = findItinerary(arr)\n    for i in res:\n        print(i[0] + \" -> \" + i[1])",
    "code_without_comments": "\ndef topologicalSortUtil(v, mp, visited, st):\n\n    visited[v] = 1\n\n    if v in mp and visited.get(mp[v], 0) == 0:\n        topologicalSortUtil(mp[v], mp, visited, st)\n\n    if v:\n        st.append(v)\n\ndef topologicalSort(mp):\n    V = len(mp)\n\n    st = []\n    visited = {}\n\n\n    for i in mp:\n        if visited.get(i, 0) == 0:\n            topologicalSortUtil(i, mp, visited, st)\n    return st[::-1]\ndef findItinerary(arr):\n\n    mp = {i[0]: i[1] for i in arr}\n    res = topologicalSort(mp)\n    ans = []\n    for i in range(len(res) - 1):\n        ans.append([res[i], res[i + 1]])\n    return ans\nif __name__ == \"__main__\":\n    arr = [\n        [\"Chennai\", \"Bangalore\"],\n        [\"Bombay\", \"Delhi\"],\n        [\"Goa\", \"Chennai\"],\n        [\"Delhi\", \"Goa\"]\n    ]\n    res = findItinerary(arr)\n    for i in res:\n        print(i[0] + \" -> \" + i[1])",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/find-itinerary-from-a-given-list-of-tickets/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<string>> findItinerary(\n            vector<vector<string>> &arr) {\n    map<string, string> dataSet;\n    for(auto i:arr) {\n        dataSet[i[0]] = i[1];\n    }\n    map<string, string> reverseMap;\n    for(auto i:arr) {\n        reverseMap[i[1]] = i[0];\n    }\n    // Find the starting point of itinerary\n    string start;\n    for(int i = 0; i<arr.size(); i++) {\n        if(reverseMap.count(arr[i][0]) == 0) {\n            start = arr[i][0];\n            break;\n        }\n    }\n    vector<vector<string>> ans;\n    // Once we have starting point, we simple need to go next,\n    // next of next using given hash ma\n    auto it = dataSet.find(start);\n    while (it != dataSet.end()) {\n        ans.push_back({it->first, it->second});\n        it = dataSet.find(it->second);\n    }\n    return ans;\n}\nint main() {\n    vector<vector<string>> arr =\n    {{\"Chennai\" ,\"Bangalore\"}, {\"Bombay\", \"Delhi\"},\n    {\"Goa\", \"Chennai\"}, {\"Delhi\", \"Goa\"}};\n    vector<vector<string>> res = findItinerary(arr);\n    for(auto i:res) {\n        cout<<i[0]<<\" -> \"<<i[1]<<endl;\n    }\n    return 0;\n}",
    "code_without_comments": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<string>> findItinerary(\n            vector<vector<string>> &arr) {\n    map<string, string> dataSet;\n    for(auto i:arr) {\n        dataSet[i[0]] = i[1];\n    }\n    map<string, string> reverseMap;\n    for(auto i:arr) {\n        reverseMap[i[1]] = i[0];\n    }\n\n    string start;\n    for(int i = 0; i<arr.size(); i++) {\n        if(reverseMap.count(arr[i][0]) == 0) {\n            start = arr[i][0];\n            break;\n        }\n    }\n    vector<vector<string>> ans;\n\n\n    auto it = dataSet.find(start);\n    while (it != dataSet.end()) {\n        ans.push_back({it->first, it->second});\n        it = dataSet.find(it->second);\n    }\n    return ans;\n}\nint main() {\n    vector<vector<string>> arr =\n    {{\"Chennai\" ,\"Bangalore\"}, {\"Bombay\", \"Delhi\"},\n    {\"Goa\", \"Chennai\"}, {\"Delhi\", \"Goa\"}};\n    vector<vector<string>> res = findItinerary(arr);\n    for(auto i:res) {\n        cout<<i[0]<<\" -> \"<<i[1]<<endl;\n    }\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/find-itinerary-from-a-given-list-of-tickets/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def findItinerary(arr):\n    dataSet = {}\n    for i in arr:\n        dataSet[i[0]] = i[1]\n    reverseMap = {}\n    for i in arr:\n        reverseMap[i[1]] = i[0]\n    # Find the starting point of itinerary\n    start = \"\"\n    for i in range(len(arr)):\n        if arr[i][0] not in reverseMap:\n            start = arr[i][0]\n            break\n    ans = []\n    # Once we have starting point, we simple need to go next,\n    # next of next using given hash map\n    while start in dataSet:\n        ans.append([start, dataSet[start]])\n        start = dataSet[start]\n    return ans\nif __name__ == \"__main__\":\n    arr = [[\"Chennai\", \"Bangalore\"], [\"Bombay\", \"Delhi\"],\n           [\"Goa\", \"Chennai\"], [\"Delhi\", \"Goa\"]]\n    res = findItinerary(arr)\n    for i in res:\n        print(i[0], \"->\", i[1])",
    "code_without_comments": "def findItinerary(arr):\n    dataSet = {}\n    for i in arr:\n        dataSet[i[0]] = i[1]\n    reverseMap = {}\n    for i in arr:\n        reverseMap[i[1]] = i[0]\n\n    start = \"\"\n    for i in range(len(arr)):\n        if arr[i][0] not in reverseMap:\n            start = arr[i][0]\n            break\n    ans = []\n\n\n    while start in dataSet:\n        ans.append([start, dataSet[start]])\n        start = dataSet[start]\n    return ans\nif __name__ == \"__main__\":\n    arr = [[\"Chennai\", \"Bangalore\"], [\"Bombay\", \"Delhi\"],\n           [\"Goa\", \"Chennai\"], [\"Delhi\", \"Goa\"]]\n    res = findItinerary(arr)\n    for i in res:\n        print(i[0], \"->\", i[1])",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/find-itinerary-from-a-given-list-of-tickets/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\nvector<int> countDistinct(vector<int> &arr, int k) {\n    int n = arr.size();\n    vector<int> res;\n    // Iterate over every window\n    for (int i = 0; i <= n - k; i++) {\n        // Hash Set to count unique elements\n        unordered_set<int> st;\n        for(int j = i; j < i + k; j++)\n        \tst.insert(arr[j]);\n        // Size of set denotes the number of unique elements\n        // in the window\n        res.push_back(st.size());\n    }\n    return res;\n}\nint main() {\n    vector<int> arr = {1, 2, 1, 3, 4, 2, 3};\n    int k = 4;\n    vector<int> res = countDistinct(arr, k);\n    for(int ele: res)\n        cout << ele << \" \";\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\nvector<int> countDistinct(vector<int> &arr, int k) {\n    int n = arr.size();\n    vector<int> res;\n\n    for (int i = 0; i <= n - k; i++) {\n\n        unordered_set<int> st;\n        for(int j = i; j < i + k; j++)\n        \tst.insert(arr[j]);\n\n\n        res.push_back(st.size());\n    }\n    return res;\n}\nint main() {\n    vector<int> arr = {1, 2, 1, 3, 4, 2, 3};\n    int k = 4;\n    vector<int> res = countDistinct(arr, k);\n    for(int ele: res)\n        cout << ele << \" \";\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/count-distinct-elements-in-every-window-of-size-k/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def countDistinct(arr, k):\n    n = len(arr)\n    res = []\n    # Iterate over every window\n    for i in range(n - k + 1):\n        # Hash Set to count unique elements\n        st = set()\n        for j in range(i, i + k):\n            st.add(arr[j])\n        # Size of set denotes the number of unique elements\n        # in the window\n        res.append(len(st))\n    return res\nif __name__ == \"__main__\":\n    arr = [1, 2, 1, 3, 4, 2, 3]\n    k = 4\n    res = countDistinct(arr, k)\n    for ele in res:\n        print(ele, end=\" \")",
    "code_without_comments": "def countDistinct(arr, k):\n    n = len(arr)\n    res = []\n\n    for i in range(n - k + 1):\n\n        st = set()\n        for j in range(i, i + k):\n            st.add(arr[j])\n\n\n        res.append(len(st))\n    return res\nif __name__ == \"__main__\":\n    arr = [1, 2, 1, 3, 4, 2, 3]\n    k = 4\n    res = countDistinct(arr, k)\n    for ele in res:\n        print(ele, end=\" \")",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/count-distinct-elements-in-every-window-of-size-k/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\nvector<int> countDistinct(vector<int> &arr, int k) {\n    int n = arr.size();\n    vector<int> res;\n    unordered_map<int, int> freq;\n    // Store the frequency of elements of first window\n    for(int i = 0; i < k; i++)\n        freq[arr[i]] += 1;\n    // Store the count of distinct element of first window\n    res.push_back(freq.size());\n    for(int i = k; i < n; i++) {\n    \tfreq[arr[i]] += 1;\n        freq[arr[i - k]] -= 1;\n        // If the frequency of arr[i - k] becomes 0 remove\n        // it from hash map\n        if(freq[arr[i - k]] == 0)\n            freq.erase(arr[i - k]);\n        res.push_back(freq.size());\n    }\n    return res;\n}\nint main() {\n    vector<int> arr = {1, 2, 1, 3, 4, 2, 3};\n    int k = 4;\n    vector<int> res = countDistinct(arr, k);\n    for(int ele: res)\n        cout << ele << \" \";\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\nvector<int> countDistinct(vector<int> &arr, int k) {\n    int n = arr.size();\n    vector<int> res;\n    unordered_map<int, int> freq;\n\n    for(int i = 0; i < k; i++)\n        freq[arr[i]] += 1;\n\n    res.push_back(freq.size());\n    for(int i = k; i < n; i++) {\n    \tfreq[arr[i]] += 1;\n        freq[arr[i - k]] -= 1;\n\n\n        if(freq[arr[i - k]] == 0)\n            freq.erase(arr[i - k]);\n        res.push_back(freq.size());\n    }\n    return res;\n}\nint main() {\n    vector<int> arr = {1, 2, 1, 3, 4, 2, 3};\n    int k = 4;\n    vector<int> res = countDistinct(arr, k);\n    for(int ele: res)\n        cout << ele << \" \";\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/count-distinct-elements-in-every-window-of-size-k/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "from collections import defaultdict\ndef countDistinct(arr, k):\n    n = len(arr)\n    res = []\n    freq = defaultdict(int)\n    # Store the frequency of elements of the\n    # first window\n    for i in range(k):\n        freq[arr[i]] += 1\n    # Store the count of distinct elements of\n    # the first window\n    res.append(len(freq))\n    for i in range(k, n):\n        freq[arr[i]] += 1\n        freq[arr[i - k]] -= 1\n        # If the frequency of arr[i - k] becomes 0 remove\n        # it from the hash map\n        if freq[arr[i - k]] == 0:\n            del freq[arr[i - k]]\n        res.append(len(freq))\n    return res\nif __name__==\"__main__\":\n    arr = [1, 2, 1, 3, 4, 2, 3]\n    k = 4\n    res = countDistinct(arr, k)\n    print(*res)",
    "code_without_comments": "from collections import defaultdict\ndef countDistinct(arr, k):\n    n = len(arr)\n    res = []\n    freq = defaultdict(int)\n\n\n    for i in range(k):\n        freq[arr[i]] += 1\n\n\n    res.append(len(freq))\n    for i in range(k, n):\n        freq[arr[i]] += 1\n        freq[arr[i - k]] -= 1\n\n\n        if freq[arr[i - k]] == 0:\n            del freq[arr[i - k]]\n        res.append(len(freq))\n    return res\nif __name__==\"__main__\":\n    arr = [1, 2, 1, 3, 4, 2, 3]\n    k = 4\n    res = countDistinct(arr, k)\n    print(*res)",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/count-distinct-elements-in-every-window-of-size-k/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nbool isSubset(vector<int> &a, vector<int> &b)\n{\n    // Iterate over each element in the second array\n    int m = a.size(), n = b.size();\n    for (int i = 0; i < n; i++)\n    {\n        bool found = false;\n        // Check if the element exists in the first array\n        for (int j = 0; j < m; j++)\n        {\n            if (b[i] == a[j])\n            {\n                found = true;\n                a[j] = -1;\n                break;\n            }\n        }\n        // If any element is not found, return false\n        if (!found)\n            return false;\n    }\n    // If all elements are found, return true\n    return true;\n}\nint main()\n{\n    vector<int> a = {11, 1, 13, 21, 3, 7};\n    vector<int> b = {11, 3, 7, 1};\n    if (isSubset(a, b))\n    {\n        cout << \"true\" << endl;\n    }\n    else\n    {\n        cout << \"false\" << endl;\n    }\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nbool isSubset(vector<int> &a, vector<int> &b)\n{\n\n    int m = a.size(), n = b.size();\n    for (int i = 0; i < n; i++)\n    {\n        bool found = false;\n\n        for (int j = 0; j < m; j++)\n        {\n            if (b[i] == a[j])\n            {\n                found = true;\n                a[j] = -1;\n                break;\n            }\n        }\n\n        if (!found)\n            return false;\n    }\n\n    return true;\n}\nint main()\n{\n    vector<int> a = {11, 1, 13, 21, 3, 7};\n    vector<int> b = {11, 3, 7, 1};\n    if (isSubset(a, b))\n    {\n        cout << \"true\" << endl;\n    }\n    else\n    {\n        cout << \"false\" << endl;\n    }\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/find-whether-an-array-is-subset-of-another-array-set-1/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def isSubset(a, b):\n    m, n = len(a), len(b)\n    for i in range(n):\n        found = False\n        for j in range(m):\n            if b[i] == a[j]:\n                found = True\n                # mark as visited\n                a[j] = -1\n                break\n        # If any element is not found, return false\n        if not found:\n            return False\n    # If all elements are found, return true\n    return True\nif __name__ == '__main__':\n    a = [11, 1, 13, 21, 3, 7]\n    b = [11, 3, 7, 1]\n    if isSubset(a, b):\n        print(\"true\")\n    else:\n        print(\"false\")",
    "code_without_comments": "def isSubset(a, b):\n    m, n = len(a), len(b)\n    for i in range(n):\n        found = False\n        for j in range(m):\n            if b[i] == a[j]:\n                found = True\n\n                a[j] = -1\n                break\n\n        if not found:\n            return False\n\n    return True\nif __name__ == '__main__':\n    a = [11, 1, 13, 21, 3, 7]\n    b = [11, 3, 7, 1]\n    if isSubset(a, b):\n        print(\"true\")\n    else:\n        print(\"false\")",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/find-whether-an-array-is-subset-of-another-array-set-1/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\nusing namespace std;\nbool isSubset(vector<int>& a, vector<int>& b) {\n    sort(a.begin(), a.end());\n    sort(b.begin(), b.end());\n    int i = 0, j = 0;\n    int m = a.size(), n = b.size();\n    while (i < m && j < n) {\n        if (a[i] < b[j]) {\n            // move in a to catch up\n            i++;\n        }\n        else if (a[i] == b[j]) {\n            i++;\n            // matched one element from b\n            j++;\n        }\n        else {\n            // a[i] > b[j]  means b[j] is missing\n            return false;\n        }\n    }\n    // all b[] matched\n    return (j == n);\n}\nint main() {\n    vector<int> a = {11, 1, 13, 21, 3, 7};\n    vector<int> b = {11, 3, 7, 1};\n    if (isSubset(a, b)) cout << \"true\\n\";\n    else cout << \"false\\n\";\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\nusing namespace std;\nbool isSubset(vector<int>& a, vector<int>& b) {\n    sort(a.begin(), a.end());\n    sort(b.begin(), b.end());\n    int i = 0, j = 0;\n    int m = a.size(), n = b.size();\n    while (i < m && j < n) {\n        if (a[i] < b[j]) {\n\n            i++;\n        }\n        else if (a[i] == b[j]) {\n            i++;\n\n            j++;\n        }\n        else {\n\n            return false;\n        }\n    }\n\n    return (j == n);\n}\nint main() {\n    vector<int> a = {11, 1, 13, 21, 3, 7};\n    vector<int> b = {11, 3, 7, 1};\n    if (isSubset(a, b)) cout << \"true\\n\";\n    else cout << \"false\\n\";\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/find-whether-an-array-is-subset-of-another-array-set-1/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\nvoid sort(int arr[], int n) {\n    for (int i = 0; i < n-1; i++)\n        for (int j = 0; j < n-i-1; j++)\n            if (arr[j] > arr[j+1]) {\n                int temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n}\nbool isSubset(int a[], int b[], int m, int n) {\n    sort(a, m);\n    sort(b, n);\n    int i = 0, j = 0;\n    while (i < m && j < n) {\n        if (a[i] < b[j]) {\n            // move in a to catch up\n            i++;\n        }\n        else if (a[i] == b[j]) {\n            i++;\n            // matched one element from b\n            j++;\n        }\n        else {\n            // a[i] > b[j]  means b[j] is missing\n            return false;\n        }\n    }\n    // all b[] matched\n    return (j == n);\n}\nint main() {\n    int a[] = {11, 1, 13, 21, 3, 7};\n    int b[] = {11, 3, 7, 1};\n    int m = sizeof(a)/sizeof(a[0]);\n    int n = sizeof(b)/sizeof(b[0]);\n    if (isSubset(a, b, m, n)) printf(\"true\\n\");\n    else printf(\"false\\n\");\n    return 0;\n}",
    "code_without_comments": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\nvoid sort(int arr[], int n) {\n    for (int i = 0; i < n-1; i++)\n        for (int j = 0; j < n-i-1; j++)\n            if (arr[j] > arr[j+1]) {\n                int temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n}\nbool isSubset(int a[], int b[], int m, int n) {\n    sort(a, m);\n    sort(b, n);\n    int i = 0, j = 0;\n    while (i < m && j < n) {\n        if (a[i] < b[j]) {\n\n            i++;\n        }\n        else if (a[i] == b[j]) {\n            i++;\n\n            j++;\n        }\n        else {\n\n            return false;\n        }\n    }\n\n    return (j == n);\n}\nint main() {\n    int a[] = {11, 1, 13, 21, 3, 7};\n    int b[] = {11, 3, 7, 1};\n    int m = sizeof(a)/sizeof(a[0]);\n    int n = sizeof(b)/sizeof(b[0]);\n    if (isSubset(a, b, m, n)) printf(\"true\\n\");\n    else printf(\"false\\n\");\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/find-whether-an-array-is-subset-of-another-array-set-1/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def isSubset(a, b):\n    a.sort()\n    b.sort()\n    i = 0\n    j = 0\n    m = len(a)\n    n = len(b)\n    while i < m and j < n:\n        if a[i] < b[j]:\n            # move in a to catch up\n            i += 1\n        elif a[i] == b[j]:\n            i += 1\n            # matched one element from b\n            j += 1\n        else:\n            # a[i] > b[j]  means b[j] is missing\n            return False\n    # all b[] matched\n    return j == n\n# Custom Input\na = [11, 1, 13, 21, 3, 7]\nb = [11, 3, 7, 1]\nif isSubset(a, b):\n    print('true')\nelse:\n    print('false')",
    "code_without_comments": "def isSubset(a, b):\n    a.sort()\n    b.sort()\n    i = 0\n    j = 0\n    m = len(a)\n    n = len(b)\n    while i < m and j < n:\n        if a[i] < b[j]:\n\n            i += 1\n        elif a[i] == b[j]:\n            i += 1\n\n            j += 1\n        else:\n\n            return False\n\n    return j == n\n\na = [11, 1, 13, 21, 3, 7]\nb = [11, 3, 7, 1]\nif isSubset(a, b):\n    print('true')\nelse:\n    print('false')",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/find-whether-an-array-is-subset-of-another-array-set-1/",
    "complexity_weight": 1.0
  }
]