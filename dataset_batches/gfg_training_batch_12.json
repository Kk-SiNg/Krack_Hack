[
  {
    "code_with_comments": "#include <iostream>\nusing namespace std;\nbool isSubset( vector<int>& a,  vector<int>& b) {\n    // Create a hash set and insert all elements of a\n    multiset<int> hashSet(a.begin(), a.end());\n    // Check each element of b in the hash set\n    for (int num : b) {\n        if (hashSet.find(num) == hashSet.end()) {\n            return false;\n        }\n        hashSet.erase(hashSet.find(num));\n    }\n    // If all elements of b are found in the hash set\n    return true;\n}\nint main() {\n    vector<int> a = {11, 1, 13, 21, 3, 7};\n    vector<int> b = {11, 3, 7, 1};\n    if (isSubset(a, b)) {\n        cout << \"true\" << endl;\n    } else {\n        cout << \"false\" << endl;\n    }\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\nusing namespace std;\nbool isSubset( vector<int>& a,  vector<int>& b) {\n\n    multiset<int> hashSet(a.begin(), a.end());\n\n    for (int num : b) {\n        if (hashSet.find(num) == hashSet.end()) {\n            return false;\n        }\n        hashSet.erase(hashSet.find(num));\n    }\n\n    return true;\n}\nint main() {\n    vector<int> a = {11, 1, 13, 21, 3, 7};\n    vector<int> b = {11, 3, 7, 1};\n    if (isSubset(a, b)) {\n        cout << \"true\" << endl;\n    } else {\n        cout << \"false\" << endl;\n    }\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/find-whether-an-array-is-subset-of-another-array-set-1/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def isSubset(a, b):\n    # Create a hash set and insert all elements of a\n    hash_set = set(a)\n    # Check each element of b in the hash set\n    for num in b:\n        if num not in hash_set:\n            return False\n    # If all elements of b are found in the hash set\n    return True\nif __name__ == \"__main__\":\n  a = [11, 1, 13, 21, 3, 7]\n  b = [11, 3, 7, 1]\n  if isSubset(a, b):\n      print(\"true\")\n  else:\n      print(\"false\")",
    "code_without_comments": "def isSubset(a, b):\n\n    hash_set = set(a)\n\n    for num in b:\n        if num not in hash_set:\n            return False\n\n    return True\nif __name__ == \"__main__\":\n  a = [11, 1, 13, 21, 3, 7]\n  b = [11, 3, 7, 1]\n  if isSubset(a, b):\n      print(\"true\")\n  else:\n      print(\"false\")",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/find-whether-an-array-is-subset-of-another-array-set-1/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "# Method to insert a key into the Trie\ndef insert(root, key):\n    # Initialize the curr pointer with the root node\n    curr = root\n    # Iterate across the length of the string\n    for c in key:\n        # Check if the node exists for the\n        # current character in the Trie\n        index = ord(c) - ord('a')\n        if curr.children[index] is None:\n            # If node for current character does\n            # not exist then make a new node\n            new_node = TrieNode()\n            # Keep the reference for the newly\n            # created node\n            curr.children[index] = new_node\n        # Move the curr pointer to the\n        # newly created node\n        curr = curr.children[index]\n    # Mark the end of the word\n    curr.isEndOfWord = True",
    "code_without_comments": "\ndef insert(root, key):\n\n    curr = root\n\n    for c in key:\n\n\n        index = ord(c) - ord('a')\n        if curr.children[index] is None:\n\n\n            new_node = TrieNode()\n\n\n            curr.children[index] = new_node\n\n\n        curr = curr.children[index]\n\n    curr.isEndOfWord = True",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/trie-insert-and-search/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "# Method to search a key in the Trie\ndef search(root, key):\n    # Initialize the curr pointer with the root node\n    curr = root\n    # Iterate across the length of the string\n    for c in key:\n        # Check if the node exists for the\n        # current character in the Trie\n        index = ord(c) - ord('a')\n        if curr.children[index] is None:\n            return False\n        # Move the curr pointer to the\n        # already existing node for the\n        # current character\n        curr = curr.children[index]\n    # Return true if the word exists\n    # and is marked as ending\n    return curr.isEndOfWord",
    "code_without_comments": "\ndef search(root, key):\n\n    curr = root\n\n    for c in key:\n\n\n        index = ord(c) - ord('a')\n        if curr.children[index] is None:\n            return False\n\n\n\n        curr = curr.children[index]\n\n\n    return curr.isEndOfWord",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/trie-insert-and-search/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <bits/stdc++.h>\nusing namespace std;\nclass TrieNode\n{\n  public:\n    // Array for children nodes of each node\n    TrieNode *children[26];\n    // for end of word\n    bool isLeaf;\n    TrieNode()\n    {\n        isLeaf = false;\n        for (int i = 0; i < 26; i++)\n        {\n            children[i] = nullptr;\n        }\n    }\n};\n  // Method to insert a key into the Trie\nvoid insert(TrieNode *root, const string &key)\n{\n    // Initialize the curr pointer with the root node\n    TrieNode *curr = root;\n    // Iterate across the length of the string\n    for (char c : key)\n    {\n        // Check if the node exists for the\n        // current character in the Trie\n        if (curr->children[c - 'a'] == nullptr)\n        {\n            // If node for current character does\n            // not exist then make a new node\n            TrieNode *newNode = new TrieNode();\n            // Keep the reference for the newly\n            // created node\n            curr->children[c - 'a'] = newNode;\n        }\n        // Move the curr pointer to the\n        // newly created node\n        curr = curr->children[c - 'a'];\n    }\n    // Mark the end of the word\n    curr->isLeaf = true;\n}\n// Method to search a key in the Trie\nbool search(TrieNode *root, const string &key)\n{\n    if (root == nullptr)\n    {\n        return false;\n    }\n    // Initialize the curr pointer with the root node\n    TrieNode *curr = root;\n    // Iterate across the length of the string\n    for (char c : key)\n    {\n        // Check if the node exists for the\n        // current character in the Trie\n        if (curr->children[c - 'a'] == nullptr)\n            return false;\n        // Move the curr pointer to the\n        // already existing node for the\n        // current character\n        curr = curr->children[c - 'a'];\n    }\n    // Return true if the word exists\n    // and is marked as ending\n    return curr->isLeaf;\n}\n// Method to check if a prefix exists in the Trie\nbool isPrefix(TrieNode *root, const string &prefix)\n{\n    // Initialize the curr pointer with the root node\n    TrieNode *curr = root;\n    // Iterate across the length of the prefix string\n    for (char c : prefix)\n    {\n        // Check if the node exists for the current character in the Trie\n        if (curr->children[c - 'a'] == nullptr)\n            return false;\n        // Move the curr pointer to the already existing node\n        // for the current character\n        curr = curr->children[c - 'a'];\n    }\n    // If we reach here, the prefix exists in the Trie\n    return true;\n  }\nint main()\n{\n    // Create am example Trie\n    TrieNode *root = new TrieNode();\n    vector<string> arr = {\"and\", \"ant\", \"do\", \"dad\"};\n    for (const string &s : arr)\n    {\n        insert(root, s);\n    }\n    // One by one search strings\n    vector<string> searchKeys = {\"do\", \"gee\", \"bat\"};\n    for (string &s : searchKeys){\n        if(search(root, s))\n            cout << \"true \";\n        else\n            cout << \"false \";\n    }\n    cout<<\"\\n\";\n    // One by one search for prefixes\n    vector<string> prefixKeys = {\"ge\", \"ba\", \"do\", \"de\"};\n    for (string &s : prefixKeys){\n        if (isPrefix(root, s))\n            cout << \"true \";\n        else\n            cout << \"false \";\n    }\n    return 0;\n}",
    "code_without_comments": "#include <bits/stdc++.h>\nusing namespace std;\nclass TrieNode\n{\n  public:\n\n    TrieNode *children[26];\n\n    bool isLeaf;\n    TrieNode()\n    {\n        isLeaf = false;\n        for (int i = 0; i < 26; i++)\n        {\n            children[i] = nullptr;\n        }\n    }\n};\n\nvoid insert(TrieNode *root, const string &key)\n{\n\n    TrieNode *curr = root;\n\n    for (char c : key)\n    {\n\n\n        if (curr->children[c - 'a'] == nullptr)\n        {\n\n\n            TrieNode *newNode = new TrieNode();\n\n\n            curr->children[c - 'a'] = newNode;\n        }\n\n\n        curr = curr->children[c - 'a'];\n    }\n\n    curr->isLeaf = true;\n}\n\nbool search(TrieNode *root, const string &key)\n{\n    if (root == nullptr)\n    {\n        return false;\n    }\n\n    TrieNode *curr = root;\n\n    for (char c : key)\n    {\n\n\n        if (curr->children[c - 'a'] == nullptr)\n            return false;\n\n\n\n        curr = curr->children[c - 'a'];\n    }\n\n\n    return curr->isLeaf;\n}\n\nbool isPrefix(TrieNode *root, const string &prefix)\n{\n\n    TrieNode *curr = root;\n\n    for (char c : prefix)\n    {\n\n        if (curr->children[c - 'a'] == nullptr)\n            return false;\n\n\n        curr = curr->children[c - 'a'];\n    }\n\n    return true;\n  }\nint main()\n{\n\n    TrieNode *root = new TrieNode();\n    vector<string> arr = {\"and\", \"ant\", \"do\", \"dad\"};\n    for (const string &s : arr)\n    {\n        insert(root, s);\n    }\n\n    vector<string> searchKeys = {\"do\", \"gee\", \"bat\"};\n    for (string &s : searchKeys){\n        if(search(root, s))\n            cout << \"true \";\n        else\n            cout << \"false \";\n    }\n    cout<<\"\\n\";\n\n    vector<string> prefixKeys = {\"ge\", \"ba\", \"do\", \"de\"};\n    for (string &s : prefixKeys){\n        if (isPrefix(root, s))\n            cout << \"true \";\n        else\n            cout << \"false \";\n    }\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/trie-insert-and-search/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "class TrieNode:\n    def __init__(self):\n        self.children = [None] * 26\n        self.isLeaf = False\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    # Method to insert a key into the Trie\n    def insert(self, key):\n        curr = self.root\n        for c in key:\n            index = ord(c) - ord('a')\n            if curr.children[index] is None:\n                curr.children[index] = TrieNode()\n            curr = curr.children[index]\n        curr.isLeaf = True\n    # Method to search a key in the Trie\n    def search(self, key):\n        curr = self.root\n        for c in key:\n            index = ord(c) - ord('a')\n            if curr.children[index] is None:\n                return False\n            curr = curr.children[index]\n        return curr.isLeaf\n    # Method to check if a prefix exists in the Trie\n    def isPrefix(self, prefix):\n        curr = self.root\n        for c in prefix:\n            index = ord(c) - ord('a')\n            if curr.children[index] is None:\n                return False\n            curr = curr.children[index]\n        return True\nif __name__ == '__main__':\n    trie = Trie()\n    arr = [\"and\", \"ant\", \"do\", \"dad\"]\n    for s in arr:\n        trie.insert(s)\n    searchKeys = [\"do\", \"gee\", \"bat\"]\n    for s in searchKeys:\n        if trie.search(s):\n            print(\"true\", end= \" \")\n        else:\n            print(\"false\", end=\" \")\n    print()\n    prefixKeys = [\"ge\", \"ba\", \"do\", \"de\"]\n    for s in prefixKeys:\n        if trie.isPrefix(s):\n            print(\"true\", end = \" \")\n        else:\n            print(\"false\", end = \" \")",
    "code_without_comments": "class TrieNode:\n    def __init__(self):\n        self.children = [None] * 26\n        self.isLeaf = False\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, key):\n        curr = self.root\n        for c in key:\n            index = ord(c) - ord('a')\n            if curr.children[index] is None:\n                curr.children[index] = TrieNode()\n            curr = curr.children[index]\n        curr.isLeaf = True\n\n    def search(self, key):\n        curr = self.root\n        for c in key:\n            index = ord(c) - ord('a')\n            if curr.children[index] is None:\n                return False\n            curr = curr.children[index]\n        return curr.isLeaf\n\n    def isPrefix(self, prefix):\n        curr = self.root\n        for c in prefix:\n            index = ord(c) - ord('a')\n            if curr.children[index] is None:\n                return False\n            curr = curr.children[index]\n        return True\nif __name__ == '__main__':\n    trie = Trie()\n    arr = [\"and\", \"ant\", \"do\", \"dad\"]\n    for s in arr:\n        trie.insert(s)\n    searchKeys = [\"do\", \"gee\", \"bat\"]\n    for s in searchKeys:\n        if trie.search(s):\n            print(\"true\", end= \" \")\n        else:\n            print(\"false\", end=\" \")\n    print()\n    prefixKeys = [\"ge\", \"ba\", \"do\", \"de\"]\n    for s in prefixKeys:\n        if trie.isPrefix(s):\n            print(\"true\", end = \" \")\n        else:\n            print(\"false\", end = \" \")",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/trie-insert-and-search/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "// A C++ program to demonstrate common Binary Heap Operations\n#include <climits>\n#include <iostream>\nusing namespace std;\n// Prototype of a utility function to swap two integers\nvoid swap(int *x, int *y);\n// A class for Min Heap\nclass MinHeap\n{\n    int *harr;     // pointer to array of elements in heap\n    int capacity;  // maximum possible size of min heap\n    int heap_size; // Current number of elements in min heap\n  public:\n    // Constructor\n    MinHeap(int capacity);\n    // to heapify a subtree with the root at given index\n    void MinHeapify(int i);\n    int parent(int i)\n    {\n        return (i - 1) / 2;\n    }\n    // to get index of left child of node at index i\n    int left(int i)\n    {\n        return (2 * i + 1);\n    }\n    // to get index of right child of node at index i\n    int right(int i)\n    {\n        return (2 * i + 2);\n    }\n    // to extract the root which is the minimum element\n    int extractMin();\n    // Decreases key value of key at index i to new_val\n    void decreaseKey(int i, int new_val);\n    // Returns the minimum key (key at root) from min heap\n    int getMin()\n    {\n        return harr[0];\n    }\n    // Deletes a key stored at index i\n    void deleteKey(int i);\n    // Inserts a new key 'k'\n    void insertKey(int k);\n};\n// Constructor: Builds a heap from a given array a[] of given size\nMinHeap::MinHeap(int cap)\n{\n    heap_size = 0;\n    capacity = cap;\n    harr = new int[cap];\n}\n// Inserts a new key 'k'\nvoid MinHeap::insertKey(int k)\n{\n    if (heap_size == capacity)\n    {\n        cout << \"\\nOverflow: Could not insertKey\\n\";\n        return;\n    }\n    // First insert the new key at the end\n    heap_size++;\n    int i = heap_size - 1;\n    harr[i] = k;\n    // Fix the min heap property if it is violated\n    while (i != 0 && harr[parent(i)] > harr[i])\n    {\n        swap(&harr[i], &harr[parent(i)]);\n        i = parent(i);\n    }\n}\n// Decreases value of key at index 'i' to new_val.  It is assumed that\n// new_val is smaller than harr[i].\nvoid MinHeap::decreaseKey(int i, int new_val)\n{\n    harr[i] = new_val;\n    while (i != 0 && harr[parent(i)] > harr[i])\n    {\n        swap(&harr[i], &harr[parent(i)]);\n        i = parent(i);\n    }\n}\n// Method to remove minimum element (or root) from min heap\nint MinHeap::extractMin()\n{\n    if (heap_size <= 0)\n        return INT_MAX;\n    if (heap_size == 1)\n    {\n        heap_size--;\n        return harr[0];\n    }\n    // Store the minimum value, and remove it from heap\n    int root = harr[0];\n    harr[0] = harr[heap_size - 1];\n    heap_size--;\n    MinHeapify(0);\n    return root;\n}\n// This function deletes key at index i. It first reduced value to minus\n// infinite, then calls extractMin()\nvoid MinHeap::deleteKey(int i)\n{\n    decreaseKey(i, INT_MIN);\n    extractMin();\n}\n// A recursive method to heapify a subtree with the root at given index\n// This method assumes that the subtrees are already heapified\nvoid MinHeap::MinHeapify(int i)\n{\n    int l = left(i);\n    int r = right(i);\n    int smallest = i;\n    if (l < heap_size && harr[l] < harr[i])\n        smallest = l;\n    if (r < heap_size && harr[r] < harr[smallest])\n        smallest = r;\n    if (smallest != i)\n    {\n        swap(&harr[i], &harr[smallest]);\n        MinHeapify(smallest);\n    }\n}\n// A utility function to swap two elements\nvoid swap(int *x, int *y)\n{\n    int temp = *x;\n    *x = *y;\n    *y = temp;\n}\n// Driver program to test above functions\nint main()\n{\n    MinHeap h(11);\n    h.insertKey(3);\n    h.insertKey(2);\n    h.deleteKey(1);\n    h.insertKey(15);\n    h.insertKey(5);\n    h.insertKey(4);\n    h.insertKey(45);\n    cout << h.extractMin() << \" \";\n    cout << h.getMin() << \" \";\n    h.decreaseKey(2, 1);\n    cout << h.getMin();\n    return 0;\n}",
    "code_without_comments": "\n#include <climits>\n#include <iostream>\nusing namespace std;\n\nvoid swap(int *x, int *y);\n\nclass MinHeap\n{\n    int *harr;\n    int capacity;\n    int heap_size;\n  public:\n\n    MinHeap(int capacity);\n\n    void MinHeapify(int i);\n    int parent(int i)\n    {\n        return (i - 1) / 2;\n    }\n\n    int left(int i)\n    {\n        return (2 * i + 1);\n    }\n\n    int right(int i)\n    {\n        return (2 * i + 2);\n    }\n\n    int extractMin();\n\n    void decreaseKey(int i, int new_val);\n\n    int getMin()\n    {\n        return harr[0];\n    }\n\n    void deleteKey(int i);\n\n    void insertKey(int k);\n};\n\nMinHeap::MinHeap(int cap)\n{\n    heap_size = 0;\n    capacity = cap;\n    harr = new int[cap];\n}\n\nvoid MinHeap::insertKey(int k)\n{\n    if (heap_size == capacity)\n    {\n        cout << \"\\nOverflow: Could not insertKey\\n\";\n        return;\n    }\n\n    heap_size++;\n    int i = heap_size - 1;\n    harr[i] = k;\n\n    while (i != 0 && harr[parent(i)] > harr[i])\n    {\n        swap(&harr[i], &harr[parent(i)]);\n        i = parent(i);\n    }\n}\n\n\nvoid MinHeap::decreaseKey(int i, int new_val)\n{\n    harr[i] = new_val;\n    while (i != 0 && harr[parent(i)] > harr[i])\n    {\n        swap(&harr[i], &harr[parent(i)]);\n        i = parent(i);\n    }\n}\n\nint MinHeap::extractMin()\n{\n    if (heap_size <= 0)\n        return INT_MAX;\n    if (heap_size == 1)\n    {\n        heap_size--;\n        return harr[0];\n    }\n\n    int root = harr[0];\n    harr[0] = harr[heap_size - 1];\n    heap_size--;\n    MinHeapify(0);\n    return root;\n}\n\n\nvoid MinHeap::deleteKey(int i)\n{\n    decreaseKey(i, INT_MIN);\n    extractMin();\n}\n\n\nvoid MinHeap::MinHeapify(int i)\n{\n    int l = left(i);\n    int r = right(i);\n    int smallest = i;\n    if (l < heap_size && harr[l] < harr[i])\n        smallest = l;\n    if (r < heap_size && harr[r] < harr[smallest])\n        smallest = r;\n    if (smallest != i)\n    {\n        swap(&harr[i], &harr[smallest]);\n        MinHeapify(smallest);\n    }\n}\n\nvoid swap(int *x, int *y)\n{\n    int temp = *x;\n    *x = *y;\n    *y = temp;\n}\n\nint main()\n{\n    MinHeap h(11);\n    h.insertKey(3);\n    h.insertKey(2);\n    h.deleteKey(1);\n    h.insertKey(15);\n    h.insertKey(5);\n    h.insertKey(4);\n    h.insertKey(45);\n    cout << h.extractMin() << \" \";\n    cout << h.getMin() << \" \";\n    h.decreaseKey(2, 1);\n    cout << h.getMin();\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/binary-heap/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n// Prototype of a utility function to swap two integers\nvoid swap(int *x, int *y);\n// A structure to represent a Min Heap\nstruct MinHeap\n{\n    int *harr;\n    int capacity;\n    int heap_size;\n};\n// Function prototypes\nstruct MinHeap *createMinHeap(int capacity);\nvoid MinHeapify(struct MinHeap *h, int i);\nint parent(int i)\n{\n    return (i - 1) / 2;\n}\nint left(int i)\n{\n    return (2 * i + 1);\n}\nint right(int i)\n{\n    return (2 * i + 2);\n}\nint extractMin(struct MinHeap *h);\nvoid decreaseKey(struct MinHeap *h, int i, int new_val);\nint getMin(struct MinHeap *h)\n{\n    return h->harr[0];\n}\nvoid deleteKey(struct MinHeap *h, int i);\nvoid insertKey(struct MinHeap *h, int k);\n// Constructor: Creates a heap of given capacity\nstruct MinHeap *createMinHeap(int capacity)\n{\n    struct MinHeap *h = (struct MinHeap *)malloc(sizeof(struct MinHeap));\n    h->heap_size = 0;\n    h->capacity = capacity;\n    h->harr = (int *)malloc(capacity * sizeof(int));\n    return h;\n}\n// Inserts a new key 'k'\nvoid insertKey(struct MinHeap *h, int k)\n{\n    if (h->heap_size == h->capacity)\n    {\n        printf(\"\\nOverflow: Could not insertKey\\n\");\n        return;\n    }\n    // First insert the new key at the end\n    h->heap_size++;\n    int i = h->heap_size - 1;\n    h->harr[i] = k;\n    // Fix the min heap property if it is violated\n    while (i != 0 && h->harr[parent(i)] > h->harr[i])\n    {\n        swap(&h->harr[i], &h->harr[parent(i)]);\n        i = parent(i);\n    }\n}\n// Decreases value of key at index 'i' to new_val.\nvoid decreaseKey(struct MinHeap *h, int i, int new_val)\n{\n    h->harr[i] = new_val;\n    while (i != 0 && h->harr[parent(i)] > h->harr[i])\n    {\n        swap(&h->harr[i], &h->harr[parent(i)]);\n        i = parent(i);\n    }\n}\n// Method to remove minimum element (or root) from min heap\nint extractMin(struct MinHeap *h)\n{\n    if (h->heap_size <= 0)\n        return INT_MAX;\n    if (h->heap_size == 1)\n    {\n        h->heap_size--;\n        return h->harr[0];\n    }\n    // Store the minimum value, and remove it from heap\n    int root = h->harr[0];\n    h->harr[0] = h->harr[h->heap_size - 1];\n    h->heap_size--;\n    MinHeapify(h, 0);\n    return root;\n}\n// This function deletes key at index i.\nvoid deleteKey(struct MinHeap *h, int i)\n{\n    decreaseKey(h, i, INT_MIN);\n    extractMin(h);\n}\n// A recursive method to heapify a subtree with root at given index\nvoid MinHeapify(struct MinHeap *h, int i)\n{\n    int l = left(i);\n    int r = right(i);\n    int smallest = i;\n    if (l < h->heap_size && h->harr[l] < h->harr[i])\n        smallest = l;\n    if (r < h->heap_size && h->harr[r] < h->harr[smallest])\n        smallest = r;\n    if (smallest != i)\n    {\n        swap(&h->harr[i], &h->harr[smallest]);\n        MinHeapify(h, smallest);\n    }\n}\n// A utility function to swap two elements\nvoid swap(int *x, int *y)\n{\n    int temp = *x;\n    *x = *y;\n    *y = temp;\n}\n// Driver program to test above functions\nint main()\n{\n    struct MinHeap *h = createMinHeap(11);\n    insertKey(h, 3);\n    insertKey(h, 2);\n    deleteKey(h, 1);\n    insertKey(h, 15);\n    insertKey(h, 5);\n    insertKey(h, 4);\n    insertKey(h, 45);\n    printf(\"%d \", extractMin(h));\n    printf(\"%d \", getMin(h));\n    decreaseKey(h, 2, 1);\n    printf(\"%d\", getMin(h));\n    // Free allocated memory\n    free(h->harr);\n    free(h);\n    return 0;\n}",
    "code_without_comments": "#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid swap(int *x, int *y);\n\nstruct MinHeap\n{\n    int *harr;\n    int capacity;\n    int heap_size;\n};\n\nstruct MinHeap *createMinHeap(int capacity);\nvoid MinHeapify(struct MinHeap *h, int i);\nint parent(int i)\n{\n    return (i - 1) / 2;\n}\nint left(int i)\n{\n    return (2 * i + 1);\n}\nint right(int i)\n{\n    return (2 * i + 2);\n}\nint extractMin(struct MinHeap *h);\nvoid decreaseKey(struct MinHeap *h, int i, int new_val);\nint getMin(struct MinHeap *h)\n{\n    return h->harr[0];\n}\nvoid deleteKey(struct MinHeap *h, int i);\nvoid insertKey(struct MinHeap *h, int k);\n\nstruct MinHeap *createMinHeap(int capacity)\n{\n    struct MinHeap *h = (struct MinHeap *)malloc(sizeof(struct MinHeap));\n    h->heap_size = 0;\n    h->capacity = capacity;\n    h->harr = (int *)malloc(capacity * sizeof(int));\n    return h;\n}\n\nvoid insertKey(struct MinHeap *h, int k)\n{\n    if (h->heap_size == h->capacity)\n    {\n        printf(\"\\nOverflow: Could not insertKey\\n\");\n        return;\n    }\n\n    h->heap_size++;\n    int i = h->heap_size - 1;\n    h->harr[i] = k;\n\n    while (i != 0 && h->harr[parent(i)] > h->harr[i])\n    {\n        swap(&h->harr[i], &h->harr[parent(i)]);\n        i = parent(i);\n    }\n}\n\nvoid decreaseKey(struct MinHeap *h, int i, int new_val)\n{\n    h->harr[i] = new_val;\n    while (i != 0 && h->harr[parent(i)] > h->harr[i])\n    {\n        swap(&h->harr[i], &h->harr[parent(i)]);\n        i = parent(i);\n    }\n}\n\nint extractMin(struct MinHeap *h)\n{\n    if (h->heap_size <= 0)\n        return INT_MAX;\n    if (h->heap_size == 1)\n    {\n        h->heap_size--;\n        return h->harr[0];\n    }\n\n    int root = h->harr[0];\n    h->harr[0] = h->harr[h->heap_size - 1];\n    h->heap_size--;\n    MinHeapify(h, 0);\n    return root;\n}\n\nvoid deleteKey(struct MinHeap *h, int i)\n{\n    decreaseKey(h, i, INT_MIN);\n    extractMin(h);\n}\n\nvoid MinHeapify(struct MinHeap *h, int i)\n{\n    int l = left(i);\n    int r = right(i);\n    int smallest = i;\n    if (l < h->heap_size && h->harr[l] < h->harr[i])\n        smallest = l;\n    if (r < h->heap_size && h->harr[r] < h->harr[smallest])\n        smallest = r;\n    if (smallest != i)\n    {\n        swap(&h->harr[i], &h->harr[smallest]);\n        MinHeapify(h, smallest);\n    }\n}\n\nvoid swap(int *x, int *y)\n{\n    int temp = *x;\n    *x = *y;\n    *y = temp;\n}\n\nint main()\n{\n    struct MinHeap *h = createMinHeap(11);\n    insertKey(h, 3);\n    insertKey(h, 2);\n    deleteKey(h, 1);\n    insertKey(h, 15);\n    insertKey(h, 5);\n    insertKey(h, 4);\n    insertKey(h, 45);\n    printf(\"%d \", extractMin(h));\n    printf(\"%d \", getMin(h));\n    decreaseKey(h, 2, 1);\n    printf(\"%d\", getMin(h));\n\n    free(h->harr);\n    free(h);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/binary-heap/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "# Enables Python 3 print function behavior in Python 2 environments\nfrom __future__ import print_function\nimport math\nclass MinHeap:\n    def __init__(self):\n        # Initialize the heap as an empty list\n        self.arr = []\n    # Get the index of the left child\n    def left(self, i): return 2 * i + 1\n    # Get the index of the right child\n    def right(self, i): return 2 * i + 2\n    # Get the index of the parent\n    def parent(self, i): return (i - 1) // 2\n    # Return the minimum element without removing it\n    def get_min(self):\n        return self.arr[0] if self.arr else None\n    # Insert a new key into the heap\n    def insert(self, k):\n        self.arr.append(k)\n        i = len(self.arr) - 1\n        # Fix the min heap property by bubbling up\n        while i > 0 and self.arr[self.parent(i)] > self.arr[i]:\n            p = self.parent(i)\n            self.arr[i], self.arr[p] = self.arr[p], self.arr[i]\n            i = p\n    # Decrease the value of a key at a specific index\n    def decrease_key(self, i, new_val):\n        self.arr[i] = new_val\n        # Percolate the new smaller value up to maintain heap property\n        while i != 0 and self.arr[self.parent(i)] > self.arr[i]:\n            p = self.parent(i)\n            self.arr[i], self.arr[p] = self.arr[p], self.arr[i]\n            i = p\n    # Remove and return the root (minimum) element\n    def extract_min(self):\n        if len(self.arr) <= 0: return None\n        if len(self.arr) == 1: return self.arr.pop()\n        res = self.arr[0]\n        # Replace root with the last element and heapify down\n        self.arr[0] = self.arr.pop()\n        self.min_heapify(0)\n        return res\n    # Delete a key at index i by forcing it to root and extracting\n    def delete_key(self, i):\n        # Use negative infinity to ensure it becomes the new root\n        self.decrease_key(i, -float('inf'))\n        # Remove the forced root\n        self.extract_min()\n    # Recursive method to fix the heap property downwards\n    def min_heapify(self, i):\n        l, r, n = self.left(i), self.right(i), len(self.arr)\n        smallest = i\n        # Find the smallest among root, left child, and right child\n        if l < n and self.arr[l] < self.arr[smallest]: smallest = l\n        if r < n and self.arr[r] < self.arr[smallest]: smallest = r\n        # If the root is not the smallest, swap and continue heapifying\n        if smallest != i:\n            self.arr[i], self.arr[smallest] = self.arr[smallest], self.arr[i]\n            self.min_heapify(smallest)\n# --- Execution ---\nh = MinHeap()\nh.insert(3)\nh.insert(2)\nh.delete_key(1)\nh.insert(15)\nh.insert(5)\nh.insert(4)\nh.insert(45)\n# Prints values on the same line separated by spaces\nprint(h.extract_min(), end=\" \")\nprint(h.get_min(), end=\" \")\nh.decrease_key(2, 1)\nprint(h.extract_min())",
    "code_without_comments": "\nfrom __future__ import print_function\nimport math\nclass MinHeap:\n    def __init__(self):\n\n        self.arr = []\n\n    def left(self, i): return 2 * i + 1\n\n    def right(self, i): return 2 * i + 2\n\n    def parent(self, i): return (i - 1) // 2\n\n    def get_min(self):\n        return self.arr[0] if self.arr else None\n\n    def insert(self, k):\n        self.arr.append(k)\n        i = len(self.arr) - 1\n\n        while i > 0 and self.arr[self.parent(i)] > self.arr[i]:\n            p = self.parent(i)\n            self.arr[i], self.arr[p] = self.arr[p], self.arr[i]\n            i = p\n\n    def decrease_key(self, i, new_val):\n        self.arr[i] = new_val\n\n        while i != 0 and self.arr[self.parent(i)] > self.arr[i]:\n            p = self.parent(i)\n            self.arr[i], self.arr[p] = self.arr[p], self.arr[i]\n            i = p\n\n    def extract_min(self):\n        if len(self.arr) <= 0: return None\n        if len(self.arr) == 1: return self.arr.pop()\n        res = self.arr[0]\n\n        self.arr[0] = self.arr.pop()\n        self.min_heapify(0)\n        return res\n\n    def delete_key(self, i):\n\n        self.decrease_key(i, -float('inf'))\n\n        self.extract_min()\n\n    def min_heapify(self, i):\n        l, r, n = self.left(i), self.right(i), len(self.arr)\n        smallest = i\n\n        if l < n and self.arr[l] < self.arr[smallest]: smallest = l\n        if r < n and self.arr[r] < self.arr[smallest]: smallest = r\n\n        if smallest != i:\n            self.arr[i], self.arr[smallest] = self.arr[smallest], self.arr[i]\n            self.min_heapify(smallest)\n\nh = MinHeap()\nh.insert(3)\nh.insert(2)\nh.delete_key(1)\nh.insert(15)\nh.insert(5)\nh.insert(4)\nh.insert(45)\n\nprint(h.extract_min(), end=\" \")\nprint(h.get_min(), end=\" \")\nh.decrease_key(2, 1)\nprint(h.extract_min())",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/binary-heap/",
    "complexity_weight": 1.0
  }
]