[
  {
    "code_with_comments": "#Driver Code Starts\nimport heapq\nimport sys\n#Driver Code Ends\ndef dijkstra(adj, src):\n    V = len(adj)\n    # Min-heap (priority queue) storing pairs of (distance, node)\n    pq = []\n    dist = [sys.maxsize] * V\n    # Distance from source to itself is 0\n    dist[src] = 0\n    heapq.heappush(pq, (0, src))\n    # Process the queue until all reachable vertices are finalized\n    while pq:\n        d, u = heapq.heappop(pq)\n        # If this distance not the latest shortest one, skip it\n        if d > dist[u]:\n            continue\n        # Explore all neighbors of the current vertex\n        for v, w in adj[u]:\n            # If we found a shorter path to v through u, update it\n            if dist[u] + w < dist[v]:\n                dist[v] = dist[u] + w\n                heapq.heappush(pq, (dist[v], v))\n    # Return the final shortest distances from the source\n    return dist\n#Driver Code Starts\nif __name__ == \"__main__\":\n    src = 0\n    adj = [\n        [(1, 4), (2, 8)],\n        [(0, 4), (4, 6), (2, 3)],\n        [(0, 8), (3, 2), (1, 3)],\n        [(2, 2), (4, 10)],\n        [(1, 6), (3, 10)]\n    ]\n    result = dijkstra(adj, src)\n    print(*result)\n#Driver Code Ends",
    "code_without_comments": "\nimport heapq\nimport sys\n\ndef dijkstra(adj, src):\n    V = len(adj)\n\n    pq = []\n    dist = [sys.maxsize] * V\n\n    dist[src] = 0\n    heapq.heappush(pq, (0, src))\n\n    while pq:\n        d, u = heapq.heappop(pq)\n\n        if d > dist[u]:\n            continue\n\n        for v, w in adj[u]:\n\n            if dist[u] + w < dist[v]:\n                dist[v] = dist[u] + w\n                heapq.heappush(pq, (dist[v], v))\n\n    return dist\n\nif __name__ == \"__main__\":\n    src = 0\n    adj = [\n        [(1, 4), (2, 8)],\n        [(0, 4), (4, 6), (2, 3)],\n        [(0, 8), (3, 2), (1, 3)],\n        [(2, 2), (4, 10)],\n        [(1, 6), (3, 10)]\n    ]\n    result = dijkstra(adj, src)\n    print(*result)\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nvector<int> bellmanFord(int V, vector<vector<int>>& edges, int src) {\n    // Initially distance from source to all\n    // other vertices is not known(Infinite).\n\tvector<int> dist(V, 1e8);\n\tdist[src] = 0;\n\t// Relaxation of all the edges V times, not (V - 1) as we\n    // need one additional relaxation to detect negative cycle\n\tfor (int i = 0; i < V; i++) {\n\t\tfor (vector<int> edge : edges) {\n\t\t\tint u = edge[0];\n\t\t\tint v = edge[1];\n\t\t\tint wt = edge[2];\n\t\t\tif (dist[u] != 1e8 && dist[u] + wt < dist[v]) {\n                // If this is the Vth relaxation, then there is\n                // a negative cycle\n                if(i == V - 1)\n                    return {-1};\n                // Update shortest distance to node v\n                dist[v] = dist[u] + wt;\n            }\n\t\t}\n\t}\n    return dist;\n}\nint main() {\n    // Number of vertices in the graph\n    int V = 5;\n    // Edge list representation: {source, destination, weight}\n    vector<vector<int>> edges = {\n        {1, 3, 2},\n        {4, 3, -1},\n        {2, 4, 1},\n        {1, 2, 1},\n        {0, 1, 5}\n    };\n    // Define the source vertex\n    int src = 0;\n    // Run Bellman-Ford algorithm to get shortest paths from src\n    vector<int> ans = bellmanFord(V, edges, src);\n    // Output the shortest distances from src to all vertices\n    for (int dist : ans)\n        cout << dist << \" \";\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nvector<int> bellmanFord(int V, vector<vector<int>>& edges, int src) {\n\n\n\tvector<int> dist(V, 1e8);\n\tdist[src] = 0;\n\n\n\tfor (int i = 0; i < V; i++) {\n\t\tfor (vector<int> edge : edges) {\n\t\t\tint u = edge[0];\n\t\t\tint v = edge[1];\n\t\t\tint wt = edge[2];\n\t\t\tif (dist[u] != 1e8 && dist[u] + wt < dist[v]) {\n\n\n                if(i == V - 1)\n                    return {-1};\n\n                dist[v] = dist[u] + wt;\n            }\n\t\t}\n\t}\n    return dist;\n}\nint main() {\n\n    int V = 5;\n\n    vector<vector<int>> edges = {\n        {1, 3, 2},\n        {4, 3, -1},\n        {2, 4, 1},\n        {1, 2, 1},\n        {0, 1, 5}\n    };\n\n    int src = 0;\n\n    vector<int> ans = bellmanFord(V, edges, src);\n\n    for (int dist : ans)\n        cout << dist << \" \";\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "def bellmanFord(V, edges, src):\n    # Initially distance from source to all other vertices\n    # is not known(Infinite) e.g. 1e8.\n    dist = [100000000] * V\n    dist[src] = 0\n    # Relaxation of all the edges V times, not (V - 1) as we\n    # need one additional relaxation to detect negative cycle\n    for i in range(V):\n        for edge in edges:\n            u, v, wt = edge\n            if dist[u] != 100000000 and dist[u] + wt < dist[v]:\n                # If this is the Vth relaxation, then there\n                # is a negative cycle\n                if i == V - 1:\n                    return [-1]\n                # Update shortest distance to node v\n                dist[v] = dist[u] + wt\n    return dist\nif __name__ == '__main__':\n    V = 5\n    edges = [[1, 3, 2], [4, 3, -1], [2, 4, 1], [1, 2, 1], [0, 1, 5]]\n    src = 0\n    ans = bellmanFord(V, edges, src)\n    print(' '.join(map(str, ans)))",
    "code_without_comments": "def bellmanFord(V, edges, src):\n\n\n    dist = [100000000] * V\n    dist[src] = 0\n\n\n    for i in range(V):\n        for edge in edges:\n            u, v, wt = edge\n            if dist[u] != 100000000 and dist[u] + wt < dist[v]:\n\n\n                if i == V - 1:\n                    return [-1]\n\n                dist[v] = dist[u] + wt\n    return dist\nif __name__ == '__main__':\n    V = 5\n    edges = [[1, 3, 2], [4, 3, -1], [2, 4, 1], [1, 2, 1], [0, 1, 5]]\n    src = 0\n    ans = bellmanFord(V, edges, src)\n    print(' '.join(map(str, ans)))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n// Solves the all-pairs shortest path\n// problem using Floyd Warshall algorithm\nvoid floydWarshall(vector<vector<int>> &dist) {\n    int V = dist.size();\n    // Add all vertices one by one to\n    // the set of intermediate vertices.\n    for (int k = 0; k < V; k++) {\n        // Pick all vertices as source one by one\n        for (int i = 0; i < V; i++) {\n            // Pick all vertices as destination\n            // for the above picked source\n            for (int j = 0; j < V; j++) {\n                // shortest path from\n                // i to j\n                if(dist[i][k] != 1e8 && dist[k][j]!= 1e8)\n                dist[i][j] = min(dist[i][j],dist[i][k] + dist[k][j]);\n            }\n        }\n    }\n}\nint main() {\n    int INF = 100000000;\n    vector<vector<int>> dist = {\n        {0, 4, INF, 5, INF},\n        {INF, 0, 1, INF, 6},\n        {2, INF, 0, 3, INF},\n        {INF, INF, 1, 0, 2},\n        {1, INF, INF, 4, 0}\n    };\n    floydWarshall(dist);\n    for(int i = 0; i<dist.size(); i++) {\n        for(int j = 0; j<dist.size(); j++) {\n            cout<<dist[i][j]<<\" \";\n        }\n        cout<<endl;\n    }\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\n\nvoid floydWarshall(vector<vector<int>> &dist) {\n    int V = dist.size();\n\n\n    for (int k = 0; k < V; k++) {\n\n        for (int i = 0; i < V; i++) {\n\n\n            for (int j = 0; j < V; j++) {\n\n\n                if(dist[i][k] != 1e8 && dist[k][j]!= 1e8)\n                dist[i][j] = min(dist[i][j],dist[i][k] + dist[k][j]);\n            }\n        }\n    }\n}\nint main() {\n    int INF = 100000000;\n    vector<vector<int>> dist = {\n        {0, 4, INF, 5, INF},\n        {INF, 0, 1, INF, 6},\n        {2, INF, 0, 3, INF},\n        {INF, INF, 1, 0, 2},\n        {1, INF, INF, 4, 0}\n    };\n    floydWarshall(dist);\n    for(int i = 0; i<dist.size(); i++) {\n        for(int j = 0; j<dist.size(); j++) {\n            cout<<dist[i][j]<<\" \";\n        }\n        cout<<endl;\n    }\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/floyd-warshall-algorithm-dp-16/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "# Solves the all-pairs shortest path\n# problem using Floyd Warshall algorithm\ndef floydWarshall(dist):\n    V = len(dist)\n    # Add all vertices one by one to\n    # the set of intermediate vertices.\n    for k in range(V):\n        # Pick all vertices as source one by one\n        for i in range(V):\n            # Pick all vertices as destination\n            # for the above picked source\n            for j in range(V):\n                #shortest path from\n                #i to j\n                if(dist[i][k] != 100000000 and dist[k][j]!= 100000000):\n                    dist[i][j] = min(dist[i][j],dist[i][k] + dist[k][j]);\nif __name__ == \"__main__\":\n    INF = 100000000;\n    dist = [\n        [0, 4, INF, 5, INF],\n        [INF, 0, 1, INF, 6],\n        [2, INF, 0, 3, INF],\n        [INF, INF, 1, 0, 2],\n        [1, INF, INF, 4, 0]\n    ]\n    floydWarshall(dist)\n    for i in range(len(dist)):\n        for j in range(len(dist)):\n            print(dist[i][j], end=\" \")\n        print()",
    "code_without_comments": "\n\ndef floydWarshall(dist):\n    V = len(dist)\n\n\n    for k in range(V):\n\n        for i in range(V):\n\n\n            for j in range(V):\n\n\n                if(dist[i][k] != 100000000 and dist[k][j]!= 100000000):\n                    dist[i][j] = min(dist[i][j],dist[i][k] + dist[k][j]);\nif __name__ == \"__main__\":\n    INF = 100000000;\n    dist = [\n        [0, 4, INF, 5, INF],\n        [INF, 0, 1, INF, 6],\n        [2, INF, 0, 3, INF],\n        [INF, INF, 1, 0, 2],\n        [1, INF, INF, 4, 0]\n    ]\n    floydWarshall(dist)\n    for i in range(len(dist)):\n        for j in range(len(dist)):\n            print(dist[i][j], end=\" \")\n        print()",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/floyd-warshall-algorithm-dp-16/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\n// A utility function to find the vertex with\n// minimum key value, from the set of vertices\n// not yet included in MST\nint minKey(vector<int> &key, vector<bool> &mstSet) {\n    // Initialize min value\n    int min = INT_MAX, min_index;\n    for (int v = 0; v < mstSet.size(); v++)\n        if (mstSet[v] == false && key[v] < min)\n            min = key[v], min_index = v;\n    return min_index;\n}\n// A utility function to print the\n// constructed MST stored in parent[]\nvoid printMST(vector<int> &parent, vector<vector<int>> &graph) {\n    cout << \"Edge \\tWeight\\n\";\n    for (int i = 1; i < graph.size(); i++)\n        cout << parent[i] << \" - \" << i << \" \\t\"\n             << graph[parent[i]][i] << \" \\n\";\n}\n// Function to construct and print MST for\n// a graph represented using adjacency\n// matrix representation\nvoid primMST(vector<vector<int>> &graph) {\n    int V = graph.size();\n    // Array to store constructed MST\n    vector<int> parent(V);\n    // Key values used to pick minimum weight edge in cut\n    vector<int> key(V);\n    // To represent set of vertices included in MST\n    vector<bool> mstSet(V);\n    // Initialize all keys as INFINITE\n    for (int i = 0; i < V; i++)\n        key[i] = INT_MAX, mstSet[i] = false;\n    // Always include first 1st vertex in MST.\n    // Make key 0 so that this vertex is picked as first\n    // vertex.\n    key[0] = 0;\n    // First node is always root of MST\n    parent[0] = -1;\n    // The MST will have V vertices\n    for (int count = 0; count < V - 1; count++) {\n        // Pick the minimum key vertex from the\n        // set of vertices not yet included in MST\n        int u = minKey(key, mstSet);\n        // Add the picked vertex to the MST Set\n        mstSet[u] = true;\n        // Update key value and parent index of\n        // the adjacent vertices of the picked vertex.\n        // Consider only those vertices which are not\n        // yet included in MST\n        for (int v = 0; v < V; v++)\n            // graph[u][v] is non zero only for adjacent\n            // vertices of m mstSet[v] is false for vertices\n            // not yet included in MST Update the key only\n            // if graph[u][v] is smaller than key[v]\n            if (graph[u][v] && mstSet[v] == false\n                && graph[u][v] < key[v])\n                parent[v] = u, key[v] = graph[u][v];\n    }\n    // Print the constructed MST\n    printMST(parent, graph);\n}\nint main() {\n  \tvector<vector<int>> graph = { { 0, 2, 0, 6, 0 },\n                        \t\t{ 2, 0, 3, 8, 5 },\n                        \t\t{ 0, 3, 0, 0, 7 },\n                        \t\t{ 6, 8, 0, 0, 9 },\n                        \t\t{ 0, 5, 7, 9, 0 } };\n    // Print the solution\n    primMST(graph);\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n\n\nint minKey(vector<int> &key, vector<bool> &mstSet) {\n\n    int min = INT_MAX, min_index;\n    for (int v = 0; v < mstSet.size(); v++)\n        if (mstSet[v] == false && key[v] < min)\n            min = key[v], min_index = v;\n    return min_index;\n}\n\n\nvoid printMST(vector<int> &parent, vector<vector<int>> &graph) {\n    cout << \"Edge \\tWeight\\n\";\n    for (int i = 1; i < graph.size(); i++)\n        cout << parent[i] << \" - \" << i << \" \\t\"\n             << graph[parent[i]][i] << \" \\n\";\n}\n\n\n\nvoid primMST(vector<vector<int>> &graph) {\n    int V = graph.size();\n\n    vector<int> parent(V);\n\n    vector<int> key(V);\n\n    vector<bool> mstSet(V);\n\n    for (int i = 0; i < V; i++)\n        key[i] = INT_MAX, mstSet[i] = false;\n\n\n\n    key[0] = 0;\n\n    parent[0] = -1;\n\n    for (int count = 0; count < V - 1; count++) {\n\n\n        int u = minKey(key, mstSet);\n\n        mstSet[u] = true;\n\n\n\n\n        for (int v = 0; v < V; v++)\n\n\n\n\n            if (graph[u][v] && mstSet[v] == false\n                && graph[u][v] < key[v])\n                parent[v] = u, key[v] = graph[u][v];\n    }\n\n    printMST(parent, graph);\n}\nint main() {\n  \tvector<vector<int>> graph = { { 0, 2, 0, 6, 0 },\n                        \t\t{ 2, 0, 3, 8, 5 },\n                        \t\t{ 0, 3, 0, 0, 7 },\n                        \t\t{ 6, 8, 0, 0, 9 },\n                        \t\t{ 0, 5, 7, 9, 0 } };\n\n    primMST(graph);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/prims-minimum-spanning-tree-mst-greedy-algo-5/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#include <limits.h>\n#include <stdbool.h>\n#include <stdio.h>\n// Number of vertices in the graph\n#define V 5\n// A utility function to find the vertex with\n// minimum key value, from the set of vertices\n// not yet included in MST\nint minKey(int key[], bool mstSet[]) {\n    // Initialize min value\n    int min = INT_MAX, min_index;\n    for (int v = 0; v < V; v++)\n        if (mstSet[v] == false && key[v] < min)\n            min = key[v], min_index = v;\n    return min_index;\n}\n// A utility function to print the\n// constructed MST stored in parent[]\nint printMST(int parent[], int graph[V][V]) {\n    printf(\"Edge \\tWeight\\n\");\n    for (int i = 1; i < V; i++)\n        printf(\"%d - %d \\t%d \\n\", parent[i], i,\n               graph[parent[i]][i]);\n}\n// Function to construct and print MST for\n// a graph represented using adjacency\n// matrix representation\nvoid primMST(int graph[V][V]) {\n    // Array to store constructed MST\n    int parent[V];\n    // Key values used to pick minimum weight edge in cut\n    int key[V];\n    // To represent set of vertices included in MST\n    bool mstSet[V];\n    // Initialize all keys as INFINITE\n    for (int i = 0; i < V; i++)\n        key[i] = INT_MAX, mstSet[i] = false;\n    // Always include first 1st vertex in MST.\n    // Make key 0 so that this vertex is picked as first\n    // vertex.\n    key[0] = 0;\n    // First node is always root of MST\n    parent[0] = -1;\n    // The MST will have V vertices\n    for (int count = 0; count < V - 1; count++) {\n        // Pick the minimum key vertex from the\n        // set of vertices not yet included in MST\n        int u = minKey(key, mstSet);\n        // Add the picked vertex to the MST Set\n        mstSet[u] = true;\n        // Update key value and parent index of\n        // the adjacent vertices of the picked vertex.\n        // Consider only those vertices which are not\n        // yet included in MST\n        for (int v = 0; v < V; v++)\n            // graph[u][v] is non zero only for adjacent\n            // vertices of m mstSet[v] is false for vertices\n            // not yet included in MST Update the key only\n            // if graph[u][v] is smaller than key[v]\n            if (graph[u][v] && mstSet[v] == false\n                && graph[u][v] < key[v])\n                parent[v] = u, key[v] = graph[u][v];\n    }\n    // print the constructed MST\n    printMST(parent, graph);\n}\nint main() {\n    int graph[V][V] = { { 0, 2, 0, 6, 0 },\n                        { 2, 0, 3, 8, 5 },\n                        { 0, 3, 0, 0, 7 },\n                        { 6, 8, 0, 0, 9 },\n                        { 0, 5, 7, 9, 0 } };\n    // Print the solution\n    primMST(graph);\n    return 0;\n}",
    "code_without_comments": "#include <limits.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define V 5\n\n\n\nint minKey(int key[], bool mstSet[]) {\n\n    int min = INT_MAX, min_index;\n    for (int v = 0; v < V; v++)\n        if (mstSet[v] == false && key[v] < min)\n            min = key[v], min_index = v;\n    return min_index;\n}\n\n\nint printMST(int parent[], int graph[V][V]) {\n    printf(\"Edge \\tWeight\\n\");\n    for (int i = 1; i < V; i++)\n        printf(\"%d - %d \\t%d \\n\", parent[i], i,\n               graph[parent[i]][i]);\n}\n\n\n\nvoid primMST(int graph[V][V]) {\n\n    int parent[V];\n\n    int key[V];\n\n    bool mstSet[V];\n\n    for (int i = 0; i < V; i++)\n        key[i] = INT_MAX, mstSet[i] = false;\n\n\n\n    key[0] = 0;\n\n    parent[0] = -1;\n\n    for (int count = 0; count < V - 1; count++) {\n\n\n        int u = minKey(key, mstSet);\n\n        mstSet[u] = true;\n\n\n\n\n        for (int v = 0; v < V; v++)\n\n\n\n\n            if (graph[u][v] && mstSet[v] == false\n                && graph[u][v] < key[v])\n                parent[v] = u, key[v] = graph[u][v];\n    }\n\n    printMST(parent, graph);\n}\nint main() {\n    int graph[V][V] = { { 0, 2, 0, 6, 0 },\n                        { 2, 0, 3, 8, 5 },\n                        { 0, 3, 0, 0, 7 },\n                        { 6, 8, 0, 0, 9 },\n                        { 0, 5, 7, 9, 0 } };\n\n    primMST(graph);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/prims-minimum-spanning-tree-mst-greedy-algo-5/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "# Library for INT_MAX\nimport sys\nclass Graph():\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for column in range(vertices)]\n                      for row in range(vertices)]\n    # A utility function to print\n    # the constructed MST stored in parent[]\n    def printMST(self, parent):\n        print(\"Edge \\tWeight\")\n        for i in range(1, self.V):\n            print(parent[i], \"-\", i, \"\\t\", self.graph[parent[i]][i])\n    # A utility function to find the vertex with\n    # minimum distance value, from the set of vertices\n    # not yet included in shortest path tree\n    def minKey(self, key, mstSet):\n        # Initialize min value\n        min = sys.maxsize\n        for v in range(self.V):\n            if key[v] < min and mstSet[v] == False:\n                min = key[v]\n                min_index = v\n        return min_index\n    # Function to construct and print MST for a graph\n    # represented using adjacency matrix representation\n    def primMST(self):\n        # Key values used to pick minimum weight edge in cut\n        key = [sys.maxsize] * self.V\n        parent = [None] * self.V  # Array to store constructed MST\n        # Make key 0 so that this vertex is picked as first vertex\n        key[0] = 0\n        mstSet = [False] * self.V\n        parent[0] = -1  # First node is always the root of\n        for cout in range(self.V):\n            # Pick the minimum distance vertex from\n            # the set of vertices not yet processed.\n            # u is always equal to src in first iteration\n            u = self.minKey(key, mstSet)\n            # Put the minimum distance vertex in\n            # the shortest path tree\n            mstSet[u] = True\n            # Update dist value of the adjacent vertices\n            # of the picked vertex only if the current\n            # distance is greater than new distance and\n            # the vertex in not in the shortest path tree\n            for v in range(self.V):\n                # graph[u][v] is non zero only for adjacent vertices of m\n                # mstSet[v] is false for vertices not yet included in MST\n                # Update the key only if graph[u][v] is smaller than key[v]\n                if self.graph[u][v] > 0 and mstSet[v] == False \\\n                and key[v] > self.graph[u][v]:\n                    key[v] = self.graph[u][v]\n                    parent[v] = u\n        self.printMST(parent)\nif __name__ == '__main__':\n    g = Graph(5)\n    g.graph = [[0, 2, 0, 6, 0],\n               [2, 0, 3, 8, 5],\n               [0, 3, 0, 0, 7],\n               [6, 8, 0, 0, 9],\n               [0, 5, 7, 9, 0]]\n    g.primMST()",
    "code_without_comments": "\nimport sys\nclass Graph():\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for column in range(vertices)]\n                      for row in range(vertices)]\n\n\n    def printMST(self, parent):\n        print(\"Edge \\tWeight\")\n        for i in range(1, self.V):\n            print(parent[i], \"-\", i, \"\\t\", self.graph[parent[i]][i])\n\n\n\n    def minKey(self, key, mstSet):\n\n        min = sys.maxsize\n        for v in range(self.V):\n            if key[v] < min and mstSet[v] == False:\n                min = key[v]\n                min_index = v\n        return min_index\n\n\n    def primMST(self):\n\n        key = [sys.maxsize] * self.V\n        parent = [None] * self.V\n\n        key[0] = 0\n        mstSet = [False] * self.V\n        parent[0] = -1\n        for cout in range(self.V):\n\n\n\n            u = self.minKey(key, mstSet)\n\n\n            mstSet[u] = True\n\n\n\n\n            for v in range(self.V):\n\n\n\n                if self.graph[u][v] > 0 and mstSet[v] == False \\\n                and key[v] > self.graph[u][v]:\n                    key[v] = self.graph[u][v]\n                    parent[v] = u\n        self.printMST(parent)\nif __name__ == '__main__':\n    g = Graph(5)\n    g.graph = [[0, 2, 0, 6, 0],\n               [2, 0, 3, 8, 5],\n               [0, 3, 0, 0, 7],\n               [6, 8, 0, 0, 9],\n               [0, 5, 7, 9, 0]]\n    g.primMST()",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/prims-minimum-spanning-tree-mst-greedy-algo-5/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n// Returns total weight of the Minimum Spanning Tree\nint spanningTree(int V, vector<vector<int>> adj[]) {\n    // Min-heap storing {weight, vertex}\n    priority_queue<pair<int,int>, vector<pair<int,int>>,\n                                greater<pair<int,int>>> pq;\n    // Marks vertices already taken in MST\n    vector<bool> visited(V, false);\n    int res = 0;\n    // Start from node 0\n    pq.push({0, 0});\n    while(!pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        int wt = p.first;\n        int u = p.second;\n        if(visited[u])\n            continue;\n        res += wt;\n        visited[u] = true;\n        // Push adjacent edges\n        for(auto &v : adj[u]) {\n            if(!visited[v[0]]) {\n                pq.push({v[1], v[0]});\n            }\n        }\n    }\n    return res;\n}\nint main() {\n    int V = 3;\n    vector<vector<int>> adj[V];\n    adj[0].push_back({1, 5});\n    adj[1].push_back({0, 5});\n    adj[1].push_back({2, 3});\n    adj[2].push_back({1, 3});\n    adj[0].push_back({2, 1});\n    adj[2].push_back({0, 1});\n    cout << spanningTree(V, adj) << endl;\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint spanningTree(int V, vector<vector<int>> adj[]) {\n\n    priority_queue<pair<int,int>, vector<pair<int,int>>,\n                                greater<pair<int,int>>> pq;\n\n    vector<bool> visited(V, false);\n    int res = 0;\n\n    pq.push({0, 0});\n    while(!pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        int wt = p.first;\n        int u = p.second;\n        if(visited[u])\n            continue;\n        res += wt;\n        visited[u] = true;\n\n        for(auto &v : adj[u]) {\n            if(!visited[v[0]]) {\n                pq.push({v[1], v[0]});\n            }\n        }\n    }\n    return res;\n}\nint main() {\n    int V = 3;\n    vector<vector<int>> adj[V];\n    adj[0].push_back({1, 5});\n    adj[1].push_back({0, 5});\n    adj[1].push_back({2, 3});\n    adj[2].push_back({1, 3});\n    adj[0].push_back({2, 1});\n    adj[2].push_back({0, 1});\n    cout << spanningTree(V, adj) << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/prims-minimum-spanning-tree-mst-greedy-algo-5/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "import heapq\n# Returns total weight of the Minimum Spanning Tree\ndef spanningTree(V, adj):\n    # Min-heap storing (weight, vertex)\n    pq = []\n    visited = [False] * V\n    res = 0\n    # Start from node 0\n    heapq.heappush(pq, (0, 0))\n    while pq:\n        wt, u = heapq.heappop(pq)\n        if visited[u]:\n            continue\n        res += wt\n        visited[u] = True\n        # Push adjacent edges\n        for v in adj[u]:\n            if not visited[v[0]]:\n                heapq.heappush(pq, (v[1], v[0]))\n    return res\nif __name__ == '__main__':\n    V = 3\n    adj = [[] for _ in range(V)]\n    adj[0].append([1, 5])\n    adj[1].append([0, 5])\n    adj[1].append([2, 3])\n    adj[2].append([1, 3])\n    adj[0].append([2, 1])\n    adj[2].append([0, 1])\n    print(spanningTree(V, adj))",
    "code_without_comments": "import heapq\n\ndef spanningTree(V, adj):\n\n    pq = []\n    visited = [False] * V\n    res = 0\n\n    heapq.heappush(pq, (0, 0))\n    while pq:\n        wt, u = heapq.heappop(pq)\n        if visited[u]:\n            continue\n        res += wt\n        visited[u] = True\n\n        for v in adj[u]:\n            if not visited[v[0]]:\n                heapq.heappush(pq, (v[1], v[0]))\n    return res\nif __name__ == '__main__':\n    V = 3\n    adj = [[] for _ in range(V)]\n    adj[0].append([1, 5])\n    adj[1].append([0, 5])\n    adj[1].append([2, 3])\n    adj[2].append([1, 3])\n    adj[0].append([2, 1])\n    adj[2].append([0, 1])\n    print(spanningTree(V, adj))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/prims-minimum-spanning-tree-mst-greedy-algo-5/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#include <bits/stdc++.h>\nusing namespace std;\n// Disjoint set data struture\nclass DSU {\n    vector<int> parent, rank;\npublic:\n    DSU(int n) {\n        parent.resize(n);\n        rank.resize(n);\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n            rank[i] = 1;\n        }\n    }\n    int find(int i) {\n        return (parent[i] == i) ? i : (parent[i] = find(parent[i]));\n    }\n    void unite(int x, int y) {\n        int s1 = find(x), s2 = find(y);\n        if (s1 != s2) {\n            if (rank[s1] < rank[s2]) parent[s1] = s2;\n            else if (rank[s1] > rank[s2]) parent[s2] = s1;\n            else parent[s2] = s1, rank[s1]++;\n        }\n    }\n};\nbool comparator(vector<int> &a,vector<int> &b){\n   return a[2] < b[2];\n}\nint kruskalsMST(int V, vector<vector<int>> &edges) {\n    // Sort all edges\n    sort(edges.begin(), edges.end(),comparator);\n    // Traverse edges in sorted order\n    DSU dsu(V);\n    int cost = 0, count = 0;\n    for (auto &e : edges) {\n        int x = e[0], y = e[1], w = e[2];\n        // Make sure that there is no cycle\n        if (dsu.find(x) != dsu.find(y)) {\n            dsu.unite(x, y);\n            cost += w;\n            if (++count == V - 1) break;\n        }\n    }\n    return cost;\n}\nint main() {\n    // An edge contains source, destination and weight\n    vector<vector<int>> edges = {\n        {0, 1, 10}, {1, 3, 15}, {2, 3, 4}, {2, 0, 6}, {0, 3, 5}\n    };\n    cout<<kruskalsMST(4, edges);\n    return 0;\n}",
    "code_without_comments": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass DSU {\n    vector<int> parent, rank;\npublic:\n    DSU(int n) {\n        parent.resize(n);\n        rank.resize(n);\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n            rank[i] = 1;\n        }\n    }\n    int find(int i) {\n        return (parent[i] == i) ? i : (parent[i] = find(parent[i]));\n    }\n    void unite(int x, int y) {\n        int s1 = find(x), s2 = find(y);\n        if (s1 != s2) {\n            if (rank[s1] < rank[s2]) parent[s1] = s2;\n            else if (rank[s1] > rank[s2]) parent[s2] = s1;\n            else parent[s2] = s1, rank[s1]++;\n        }\n    }\n};\nbool comparator(vector<int> &a,vector<int> &b){\n   return a[2] < b[2];\n}\nint kruskalsMST(int V, vector<vector<int>> &edges) {\n\n    sort(edges.begin(), edges.end(),comparator);\n\n    DSU dsu(V);\n    int cost = 0, count = 0;\n    for (auto &e : edges) {\n        int x = e[0], y = e[1], w = e[2];\n\n        if (dsu.find(x) != dsu.find(y)) {\n            dsu.unite(x, y);\n            cost += w;\n            if (++count == V - 1) break;\n        }\n    }\n    return cost;\n}\nint main() {\n\n    vector<vector<int>> edges = {\n        {0, 1, 10}, {1, 3, 15}, {2, 3, 4}, {2, 0, 6}, {0, 3, 5}\n    };\n    cout<<kruskalsMST(4, edges);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "// C code to implement Kruskal's algorithm\n#include <stdio.h>\n#include <stdlib.h>\n// Comparator function to use in sorting\nint comparator(const int p1[], const int p2[])\n{\n    return p1[2] - p2[2];\n}\n// Initialization of parent[] and rank[] arrays\nvoid makeSet(int parent[], int rank[], int n)\n{\n    for (int i = 0; i < n; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n}\n// Function to find the parent of a node\nint findParent(int parent[], int component)\n{\n    if (parent[component] == component)\n        return component;\n    return parent[component]\n           = findParent(parent, parent[component]);\n}\n// Function to unite two sets\nvoid unionSet(int u, int v, int parent[], int rank[], int n)\n{\n    // Finding the parents\n    u = findParent(parent, u);\n    v = findParent(parent, v);\n    if (rank[u] < rank[v]) {\n        parent[u] = v;\n    }\n    else if (rank[u] > rank[v]) {\n        parent[v] = u;\n    }\n    else {\n        parent[v] = u;\n        // Since the rank increases if\n        // the ranks of two sets are same\n        rank[u]++;\n    }\n}\n// Function to find the MST\nint kruskalAlgo(int n, int edge[n][3])\n{\n    // First we sort the edge array in ascending order\n    // so that we can access minimum distances/cost\n    qsort(edge, n, sizeof(edge[0]), comparator);\n    int parent[n];\n    int rank[n];\n    // Function to initialize parent[] and rank[]\n    makeSet(parent, rank, n);\n    // To store the minimun cost\n    int minCost = 0;\n    for (int i = 0; i < n; i++) {\n        int v1 = findParent(parent, edge[i][0]);\n        int v2 = findParent(parent, edge[i][1]);\n        int wt = edge[i][2];\n        // If the parents are different that\n        // means they are in different sets so\n        // union them\n        if (v1 != v2) {\n            unionSet(v1, v2, parent, rank, n);\n            minCost += wt;\n        }\n    }\n    return minCost;\n}\n// Driver code\nint main()\n{\n    int edge[5][3] = { { 0, 1, 10 },\n                       { 0, 2, 6 },\n                       { 0, 3, 5 },\n                       { 1, 3, 15 },\n                       { 2, 3, 4 } };\n    printf(\"%d\",kruskalAlgo(5, edge));\n    return 0;\n}",
    "code_without_comments": "\n#include <stdio.h>\n#include <stdlib.h>\n\nint comparator(const int p1[], const int p2[])\n{\n    return p1[2] - p2[2];\n}\n\nvoid makeSet(int parent[], int rank[], int n)\n{\n    for (int i = 0; i < n; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n}\n\nint findParent(int parent[], int component)\n{\n    if (parent[component] == component)\n        return component;\n    return parent[component]\n           = findParent(parent, parent[component]);\n}\n\nvoid unionSet(int u, int v, int parent[], int rank[], int n)\n{\n\n    u = findParent(parent, u);\n    v = findParent(parent, v);\n    if (rank[u] < rank[v]) {\n        parent[u] = v;\n    }\n    else if (rank[u] > rank[v]) {\n        parent[v] = u;\n    }\n    else {\n        parent[v] = u;\n\n\n        rank[u]++;\n    }\n}\n\nint kruskalAlgo(int n, int edge[n][3])\n{\n\n\n    qsort(edge, n, sizeof(edge[0]), comparator);\n    int parent[n];\n    int rank[n];\n\n    makeSet(parent, rank, n);\n\n    int minCost = 0;\n    for (int i = 0; i < n; i++) {\n        int v1 = findParent(parent, edge[i][0]);\n        int v2 = findParent(parent, edge[i][1]);\n        int wt = edge[i][2];\n\n\n\n        if (v1 != v2) {\n            unionSet(v1, v2, parent, rank, n);\n            minCost += wt;\n        }\n    }\n    return minCost;\n}\n\nint main()\n{\n    int edge[5][3] = { { 0, 1, 10 },\n                       { 0, 2, 6 },\n                       { 0, 3, 5 },\n                       { 1, 3, 15 },\n                       { 2, 3, 4 } };\n    printf(\"%d\",kruskalAlgo(5, edge));\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "from functools import cmp_to_key\ndef comparator(a,b):\n    return a[2] - b[2];\ndef kruskals_mst(V, edges):\n    # Sort all edges\n    edges = sorted(edges,key=cmp_to_key(comparator))\n    # Traverse edges in sorted order\n    dsu = DSU(V)\n    cost = 0\n    count = 0\n    for x, y, w in edges:\n        # Make sure that there is no cycle\n        if dsu.find(x) != dsu.find(y):\n            dsu.union(x, y)\n            cost += w\n            count += 1\n            if count == V - 1:\n                break\n    return cost\n# Disjoint set data structure\nclass DSU:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [1] * n\n    def find(self, i):\n        if self.parent[i] != i:\n            self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n    def union(self, x, y):\n        s1 = self.find(x)\n        s2 = self.find(y)\n        if s1 != s2:\n            if self.rank[s1] < self.rank[s2]:\n                self.parent[s1] = s2\n            elif self.rank[s1] > self.rank[s2]:\n                self.parent[s2] = s1\n            else:\n                self.parent[s2] = s1\n                self.rank[s1] += 1\nif __name__ == '__main__':\n    # An edge contains, weight, source and destination\n    edges = [[0, 1, 10], [1, 3, 15], [2, 3, 4], [2, 0, 6], [0, 3, 5]]\n    print(kruskals_mst(4, edges))",
    "code_without_comments": "from functools import cmp_to_key\ndef comparator(a,b):\n    return a[2] - b[2];\ndef kruskals_mst(V, edges):\n\n    edges = sorted(edges,key=cmp_to_key(comparator))\n\n    dsu = DSU(V)\n    cost = 0\n    count = 0\n    for x, y, w in edges:\n\n        if dsu.find(x) != dsu.find(y):\n            dsu.union(x, y)\n            cost += w\n            count += 1\n            if count == V - 1:\n                break\n    return cost\n\nclass DSU:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [1] * n\n    def find(self, i):\n        if self.parent[i] != i:\n            self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n    def union(self, x, y):\n        s1 = self.find(x)\n        s2 = self.find(y)\n        if s1 != s2:\n            if self.rank[s1] < self.rank[s2]:\n                self.parent[s1] = s2\n            elif self.rank[s1] > self.rank[s2]:\n                self.parent[s2] = s1\n            else:\n                self.parent[s2] = s1\n                self.rank[s1] += 1\nif __name__ == '__main__':\n\n    edges = [[0, 1, 10], [1, 3, 15], [2, 3, 4], [2, 0, 6], [0, 3, 5]]\n    print(kruskals_mst(4, edges))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <iostream>\n#include <vector>\nusing namespace std;\n//Driver Code Ends\n// Utility DFS function to detect cycle in a directed graph\nbool isCyclicUtil(vector<vector<int>>& adj, int u, vector<bool>& visited,\nvector<bool>& recStack) {\n     // node is already in recursion stack cycle found\n    if (recStack[u]) return true;\n     // already processed no need to visit again\n    if (visited[u]) return false;\n    visited[u] = true;\n    recStack[u] = true;\n    // Recur for all adjacent nodes\n    for (int v : adj[u]) {\n        if (isCyclicUtil(adj, v, visited, recStack))\n            return true;\n    }\n     // remove from recursion stack before backtracking\n    recStack[u] = false;\n    return false;\n}\n// Function to detect cycle in a directed graph\nbool isCyclic(vector<vector<int>>& adj) {\n    int V = adj.size();\n    vector<bool> visited(V, false);\n    vector<bool> recStack(V, false);\n    // Run DFS from every unvisited node\n    for (int i = 0; i < V; i++) {\n        if (!visited[i] && isCyclicUtil(adj, i, visited, recStack))\n            return true;\n    }\n    return false;\n}\n//Driver Code Starts\nint main() {\n    vector<vector<int>> adj = {{1},{2},{0, 3}};\n    cout << (isCyclic(adj) ? \"true\" : \"false\") << endl;\n    return 0;\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nbool isCyclicUtil(vector<vector<int>>& adj, int u, vector<bool>& visited,\nvector<bool>& recStack) {\n\n    if (recStack[u]) return true;\n\n    if (visited[u]) return false;\n    visited[u] = true;\n    recStack[u] = true;\n\n    for (int v : adj[u]) {\n        if (isCyclicUtil(adj, v, visited, recStack))\n            return true;\n    }\n\n    recStack[u] = false;\n    return false;\n}\n\nbool isCyclic(vector<vector<int>>& adj) {\n    int V = adj.size();\n    vector<bool> visited(V, false);\n    vector<bool> recStack(V, false);\n\n    for (int i = 0; i < V; i++) {\n        if (!visited[i] && isCyclicUtil(adj, i, visited, recStack))\n            return true;\n    }\n    return false;\n}\n\nint main() {\n    vector<vector<int>> adj = {{1},{2},{0, 3}};\n    cout << (isCyclic(adj) ? \"true\" : \"false\") << endl;\n    return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/detect-cycle-in-a-graph/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "# Utility DFS function to detect cycle in a directed graph\ndef isCyclicUtil(adj, u, visited, recStack):\n    # node is already in recursion stack cycle found\n    if recStack[u]:\n        return True\n    # already processed no need to visit again\n    if visited[u]:\n        return False\n    visited[u] = True\n    recStack[u] = True\n    # Recur for all adjacent nodes\n    for v in adj[u]:\n        if isCyclicUtil(adj, v, visited, recStack):\n            return True\n    # remove from recursion stack before backtracking\n    recStack[u] = False\n    return False\n# Function to detect cycle in a directed graph\ndef isCyclic(adj):\n    V = len(adj)\n    visited = [False] * V\n    recStack = [False] * V\n    # Run DFS from every unvisited node\n    for i in range(V):\n        if not visited[i] and isCyclicUtil(adj, i, visited, recStack):\n            return True\n    return False\n#Driver Code Starts\nif __name__ == \"__main__\":\n    adj = [[1], [2], [0, 3]]\n    print(\"true\" if isCyclic(adj) else \"false\")\n#Driver Code Ends",
    "code_without_comments": "\ndef isCyclicUtil(adj, u, visited, recStack):\n\n    if recStack[u]:\n        return True\n\n    if visited[u]:\n        return False\n    visited[u] = True\n    recStack[u] = True\n\n    for v in adj[u]:\n        if isCyclicUtil(adj, v, visited, recStack):\n            return True\n\n    recStack[u] = False\n    return False\n\ndef isCyclic(adj):\n    V = len(adj)\n    visited = [False] * V\n    recStack = [False] * V\n\n    for i in range(V):\n        if not visited[i] and isCyclicUtil(adj, i, visited, recStack):\n            return True\n    return False\n\nif __name__ == \"__main__\":\n    adj = [[1], [2], [0, 3]]\n    print(\"true\" if isCyclic(adj) else \"false\")\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/detect-cycle-in-a-graph/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n//Driver Code Ends\nbool isCyclic(vector<vector<int>> &adj)\n{\n    int V = adj.size();\n    // Array to store in-degree of each vertex\n    vector<int> inDegree(V, 0);\n    queue<int> q;\n    // Count of visited (processed) nodes\n    int visited = 0;\n    //Compute in-degrees of all vertices\n    for (int u = 0; u < V; ++u)\n    {\n        for (int v : adj[u])\n        {\n            inDegree[v]++;\n        }\n    }\n    //  Add all vertices with in-degree 0 to the queue\n    for (int u = 0; u < V; ++u)\n    {\n        if (inDegree[u] == 0)\n        {\n            q.push(u);\n        }\n    }\n    // Perform BFS (Topological Sort)\n    while (!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n        visited++;\n        // Reduce in-degree of neighbors\n        for (int v : adj[u])\n        {\n            inDegree[v]--;\n            if (inDegree[v] == 0)\n            {\n                // Add to queue when in-degree becomes 0\n                q.push(v);\n            }\n        }\n    }\n    //  If visited nodes != total nodes, a cycle exists\n    return visited != V;\n}\n//Driver Code Starts\nint main()\n{\n    vector<vector<int>> adj = {{1},{2},{0, 3}};\n    cout << (isCyclic(adj) ? \"true\" : \"false\") << endl;\n    return 0;\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nbool isCyclic(vector<vector<int>> &adj)\n{\n    int V = adj.size();\n\n    vector<int> inDegree(V, 0);\n    queue<int> q;\n\n    int visited = 0;\n\n    for (int u = 0; u < V; ++u)\n    {\n        for (int v : adj[u])\n        {\n            inDegree[v]++;\n        }\n    }\n\n    for (int u = 0; u < V; ++u)\n    {\n        if (inDegree[u] == 0)\n        {\n            q.push(u);\n        }\n    }\n\n    while (!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n        visited++;\n\n        for (int v : adj[u])\n        {\n            inDegree[v]--;\n            if (inDegree[v] == 0)\n            {\n\n                q.push(v);\n            }\n        }\n    }\n\n    return visited != V;\n}\n\nint main()\n{\n    vector<vector<int>> adj = {{1},{2},{0, 3}};\n    cout << (isCyclic(adj) ? \"true\" : \"false\") << endl;\n    return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/detect-cycle-in-a-graph/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#Driver Code Starts\nfrom collections import deque\n#Driver Code Ends\ndef isCyclic(adj):\n    V = max(max(sub) if sub else 0 for sub in adj) + 1\n    # Array to store in-degree of each vertex\n    inDegree = [0] * V\n    q = deque()\n    # Count of visited (processed) nodes\n    visited = 0\n    # Compute in-degrees of all vertices\n    for u in range(V):\n        for v in adj[u]:\n            inDegree[v] += 1\n    # Add all vertices with in-degree 0 to the queue\n    for u in range(V):\n        if inDegree[u] == 0:\n            q.append(u)\n    # Perform BFS (Topological Sort)\n    while q:\n        u = q.popleft()\n        visited += 1\n        # Reduce in-degree of neighbors\n        for v in adj[u]:\n            inDegree[v] -= 1\n            if inDegree[v] == 0:\n                # Add to queue when in-degree becomes 0\n                q.append(v)\n    # If visited nodes != total nodes, a cycle exists\n    return visited != V\n#Driver Code Starts\nif __name__ == \"__main__\":\n    adj = [[1],[2],[0, 3], []]\n    print(\"true\" if isCyclic(adj) else \"false\")\n#Driver Code Ends",
    "code_without_comments": "\nfrom collections import deque\n\ndef isCyclic(adj):\n    V = max(max(sub) if sub else 0 for sub in adj) + 1\n\n    inDegree = [0] * V\n    q = deque()\n\n    visited = 0\n\n    for u in range(V):\n        for v in adj[u]:\n            inDegree[v] += 1\n\n    for u in range(V):\n        if inDegree[u] == 0:\n            q.append(u)\n\n    while q:\n        u = q.popleft()\n        visited += 1\n\n        for v in adj[u]:\n            inDegree[v] -= 1\n            if inDegree[v] == 0:\n\n                q.append(v)\n\n    return visited != V\n\nif __name__ == \"__main__\":\n    adj = [[1],[2],[0, 3], []]\n    print(\"true\" if isCyclic(adj) else \"false\")\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/detect-cycle-in-a-graph/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <iostream>\n#include<vector>\nusing namespace std;\n//Driver Code Ends\nbool dfs(int v, vector<vector<int>> &adj, vector<bool> &visited, int parent)\n{\n    // Mark the current node as visited\n    visited[v] = true;\n    // Recur for all the vertices adjacent to this vertex\n    for (int i : adj[v])\n    {\n        // If an adjacent vertex is not visited,\n        //then recur for that adjacent\n        if (!visited[i])\n        {\n            if (dfs(i, adj, visited, v))\n                return true;\n        }\n        // If an adjacent vertex is visited and is not\n        //parent of current vertex,\n        // then there exists a cycle in the graph.\n        else if (i != parent)\n            return true;\n    }\n    return false;\n}\n// Returns true if the graph contains a cycle, else false.\nbool isCycle(vector<vector<int>> &adj)\n{\n    int V= adj.size();\n    // Mark all the vertices as not visited\n    vector<bool> visited(V, false);\n    for (int u = 0; u < V; u++)\n    {\n        if (!visited[u])\n        {\n            if (dfs(u, adj, visited, -1))\n                return true;\n        }\n    }\n    return false;\n}\n//Driver Code Starts\nint main()\n{\n    vector<vector<int>> adj = {{1, 2}, {0, 2}, {0, 1, 3}, {2}};\n    isCycle(adj) ? cout << \"true\" : cout << \"false\";\n    return 0;\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <iostream>\n#include<vector>\nusing namespace std;\n\nbool dfs(int v, vector<vector<int>> &adj, vector<bool> &visited, int parent)\n{\n\n    visited[v] = true;\n\n    for (int i : adj[v])\n    {\n\n\n        if (!visited[i])\n        {\n            if (dfs(i, adj, visited, v))\n                return true;\n        }\n\n\n\n        else if (i != parent)\n            return true;\n    }\n    return false;\n}\n\nbool isCycle(vector<vector<int>> &adj)\n{\n    int V= adj.size();\n\n    vector<bool> visited(V, false);\n    for (int u = 0; u < V; u++)\n    {\n        if (!visited[u])\n        {\n            if (dfs(u, adj, visited, -1))\n                return true;\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    vector<vector<int>> adj = {{1, 2}, {0, 2}, {0, 1, 3}, {2}};\n    isCycle(adj) ? cout << \"true\" : cout << \"false\";\n    return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/detect-cycle-undirected-graph/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "def dfs(v, adj, visited, parent):\n    # Mark the current node as visited\n    visited[v] = True\n    # Recur for all the vertices adjacent to this vertex\n    for neighbor in adj[v]:\n        # If an adjacent vertex is not visited,\n        # then recur for that adjacent\n        if not visited[neighbor]:\n            if dfs(neighbor, adj, visited, v):\n                return True\n        # If an adjacent vertex is visited and is not\n        # parent of current vertex,\n        # then there exists a cycle in the graph.\n        elif neighbor != parent:\n            return True\n    return False\n# Returns true if the graph contains a cycle, else false.\ndef isCycle(adj):\n    V = len(adj)\n    # Mark all the vertices as not visited\n    visited = [False] * V\n    for u in range(V):\n        if not visited[u]:\n            if dfs(u, adj, visited, -1):\n                return True\n    return False\n#Driver Code Starts\nif __name__ == \"__main__\":\n    adj = [[1, 2],[0, 2],[0, 1, 3],[2]]\n    print(\"true\" if isCycle(adj) else \"false\")\n#Driver Code Ends",
    "code_without_comments": "def dfs(v, adj, visited, parent):\n\n    visited[v] = True\n\n    for neighbor in adj[v]:\n\n\n        if not visited[neighbor]:\n            if dfs(neighbor, adj, visited, v):\n                return True\n\n\n\n        elif neighbor != parent:\n            return True\n    return False\n\ndef isCycle(adj):\n    V = len(adj)\n\n    visited = [False] * V\n    for u in range(V):\n        if not visited[u]:\n            if dfs(u, adj, visited, -1):\n                return True\n    return False\n\nif __name__ == \"__main__\":\n    adj = [[1, 2],[0, 2],[0, 1, 3],[2]]\n    print(\"true\" if isCycle(adj) else \"false\")\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/detect-cycle-undirected-graph/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n//Driver Code Ends\n// Function to perform BFS from node 'start' to detect cycle\nbool bfs(int start, vector<vector<int>>& adj, vector<bool>& visited) {\n    // Queue stores {current node, parent node}\n    queue<pair<int, int>> q;\n     // Start node has no parent\n    q.push({start, -1});\n    visited[start] = true;\n    while (!q.empty()) {\n        int node = q.front().first;\n        int parent = q.front().second;\n        q.pop();\n        // Traverse all neighbors of current node\n        for (int neighbor : adj[node]) {\n            // If neighbor is not visited, mark it visited and push to queue\n            if (!visited[neighbor]) {\n                visited[neighbor] = true;\n                q.push({neighbor, node});\n            }\n            // If neighbor is visited and not parent, a cycle is detected\n            else if (neighbor != parent) {\n                return true;\n            }\n        }\n    }\n    // No cycle found starting from this node\n    return false;\n}\n// Function to check if the undirected graph contains a cycle\nbool isCycle(vector<vector<int>>& adj) {\n    int V= adj.size();\n    // Keep track of visited vertices\n    vector<bool> visited(V, false);\n    // Perform BFS from every unvisited node\n    for (int i = 0; i < V; i++) {\n        if (!visited[i]) {\n            // If BFS finds a cycle\n            if (bfs(i, adj, visited)) {\n                return true;\n            }\n        }\n    }\n    // If no cycle is found in any component\n    return false;\n}\n//Driver Code Starts\nint main() {\n    vector<vector<int>> adj = {{1, 2}, {0, 2}, {0, 1, 3}, {2}};\n    isCycle(adj) ? cout << \"true\" : cout << \"false\";\n    return 0;\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\n\nbool bfs(int start, vector<vector<int>>& adj, vector<bool>& visited) {\n\n    queue<pair<int, int>> q;\n\n    q.push({start, -1});\n    visited[start] = true;\n    while (!q.empty()) {\n        int node = q.front().first;\n        int parent = q.front().second;\n        q.pop();\n\n        for (int neighbor : adj[node]) {\n\n            if (!visited[neighbor]) {\n                visited[neighbor] = true;\n                q.push({neighbor, node});\n            }\n\n            else if (neighbor != parent) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nbool isCycle(vector<vector<int>>& adj) {\n    int V= adj.size();\n\n    vector<bool> visited(V, false);\n\n    for (int i = 0; i < V; i++) {\n        if (!visited[i]) {\n\n            if (bfs(i, adj, visited)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    vector<vector<int>> adj = {{1, 2}, {0, 2}, {0, 1, 3}, {2}};\n    isCycle(adj) ? cout << \"true\" : cout << \"false\";\n    return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/detect-cycle-undirected-graph/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "from collections import deque\n# Function to perform BFS from node 'start' to detect cycle\ndef bfs(start, adj, visited):\n    # Queue stores [current node, parent node]\n    q = deque()\n     # Start node has no parent\n    q.append([start, -1])\n    visited[start] = True\n    while q:\n        node = q[0][0]\n        parent = q[0][1]\n        q.popleft()\n        # Traverse all neighbors of current node\n        for neighbor in adj[node]:\n            # If neighbor is not visited, mark it visited and push to queue\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                q.append([neighbor, node])\n            # If neighbor is visited and not parent, a cycle is detected\n            elif neighbor != parent:\n                return True\n    # No cycle found starting from this node\n    return False\n# Function to check if the undirected graph contains a cycle\ndef isCycle(adj):\n    V = len(adj)\n    # Keep track of visited vertices\n    visited = [False] * V\n    # Perform BFS from every unvisited node\n    for i in range(V):\n        if not visited[i]:\n            # If BFS finds a cycle\n            if bfs(i, adj, visited):\n                return True\n    # If no cycle is found in any component\n    return False\n#Driver Code Starts\nif __name__ == \"__main__\":\n    adj = [[1, 2],[0, 2],[0, 1, 3],[2]]\n    print(\"true\" if isCycle(adj) else \"false\")\n#Driver Code Ends",
    "code_without_comments": "from collections import deque\n# Function to perform BFS from node 'start' to detect cycle\ndef bfs(start, adj, visited):\n\n    q = deque()\n\n    q.append([start, -1])\n    visited[start] = True\n    while q:\n        node = q[0][0]\n        parent = q[0][1]\n        q.popleft()\n\n        for neighbor in adj[node]:\n\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                q.append([neighbor, node])\n\n            elif neighbor != parent:\n                return True\n\n    return False\n\ndef isCycle(adj):\n    V = len(adj)\n\n    visited = [False] * V\n\n    for i in range(V):\n        if not visited[i]:\n\n            if bfs(i, adj, visited):\n                return True\n\n    return False\n\nif __name__ == \"__main__\":\n    adj = [[1, 2],[0, 2],[0, 1, 3],[2]]\n    print(\"true\" if isCycle(adj) else \"false\")\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/detect-cycle-undirected-graph/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int>> constructadj(int V, vector<vector<int>> &edges){\n    vector<vector<int>> adj(V);\n    for(auto it:edges){\n        adj[it[0]].push_back(it[1]);\n        adj[it[1]].push_back(it[0]);\n    }\n    return adj;\n}\n// Function to check if the graph is Bipartite using BFS\n//Driver Code Ends\nbool isBipartite(int V, vector<vector<int>> &edges) {\n    // Vector to store colors of vertices.\n    // Initialize all as -1 (uncolored)\n    vector<int> color(V, -1);\n    //create adjacency list\n    vector<vector<int>> adj = constructadj(V,edges);\n    // Queue for BFS\n    queue<int> q;\n    // Iterate through all vertices to handle disconnected graphs\n    for(int i = 0; i < V; i++) {\n        // If the vertex is uncolored, start BFS from it\n        if(color[i] == -1) {\n            // Assign first color (0) to the starting vertex\n            color[i] = 0;\n            q.push(i);\n            // Perform BFS\n            while(!q.empty()) {\n                int u = q.front();\n                q.pop();\n                // Traverse all adjacent vertices\n                for(auto &v : adj[u]) {\n                    // If the adjacent vertex is uncolored,\n                    // assign alternate color\n                    if(color[v] == -1) {\n                        color[v] = 1 - color[u];\n                        q.push(v);\n                    }\n                    // If the adjacent vertex has the same color,\n                    // graph is not bipartite\n                    else if(color[v] == color[u]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    // If no conflicts in coloring, graph is bipartite\n//Driver Code Starts\n    return true;\n}\nint main() {\n    int V = 4;\n    vector<vector<int>> edges = {{0, 1}, {0, 2}, {1, 2}, {2, 3}};\n    if(isBipartite(V, edges))\n        cout << \"true\";\n    else\n        cout << \"false\";\n    return 0;\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int>> constructadj(int V, vector<vector<int>> &edges){\n    vector<vector<int>> adj(V);\n    for(auto it:edges){\n        adj[it[0]].push_back(it[1]);\n        adj[it[1]].push_back(it[0]);\n    }\n    return adj;\n}\n\n\nbool isBipartite(int V, vector<vector<int>> &edges) {\n\n\n    vector<int> color(V, -1);\n\n    vector<vector<int>> adj = constructadj(V,edges);\n\n    queue<int> q;\n\n    for(int i = 0; i < V; i++) {\n\n        if(color[i] == -1) {\n\n            color[i] = 0;\n            q.push(i);\n\n            while(!q.empty()) {\n                int u = q.front();\n                q.pop();\n\n                for(auto &v : adj[u]) {\n\n\n                    if(color[v] == -1) {\n                        color[v] = 1 - color[u];\n                        q.push(v);\n                    }\n\n\n                    else if(color[v] == color[u]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n\n    return true;\n}\nint main() {\n    int V = 4;\n    vector<vector<int>> edges = {{0, 1}, {0, 2}, {1, 2}, {2, 3}};\n    if(isBipartite(V, edges))\n        cout << \"true\";\n    else\n        cout << \"false\";\n    return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/bipartite-graph/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#Driver Code Starts\nfrom collections import deque\n# Function to construct the adjacency list from edges\ndef constructadj(V, edges):\n    adj = [[] for _ in range(V)]\n    for edge in edges:\n        u, v = edge\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n# Function to check if the graph is Bipartite using BFS\n#Driver Code Ends\ndef isBipartite(V, adj):\n    # Initialize all as uncolored\n    color = [-1] * V\n    # create adjacency list\n    adj = constructadj(V,edges)\n    for i in range(V):\n        if color[i] == -1:\n            color[i] = 0\n            q = deque([i])\n            while q:\n                u = q.popleft()\n                for v in adj[u]:\n                    if color[v] == -1:\n                        color[v] = 1 - color[u]\n                        q.append(v)\n                    elif color[v] == color[u]:\n                        return False  # Conflict found\n#Driver Code Starts\n     # No conflict, graph is bipartite\n    return True\nif __name__ == \"__main__\":\n    V = 4\n    edges = [[0, 1], [0, 2], [1, 2], [2, 3]]\n    print(\"true\" if isBipartite(V, edges) else \"false\")\n#Driver Code Ends",
    "code_without_comments": "\nfrom collections import deque\n\ndef constructadj(V, edges):\n    adj = [[] for _ in range(V)]\n    for edge in edges:\n        u, v = edge\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\n\ndef isBipartite(V, adj):\n\n    color = [-1] * V\n\n    adj = constructadj(V,edges)\n    for i in range(V):\n        if color[i] == -1:\n            color[i] = 0\n            q = deque([i])\n            while q:\n                u = q.popleft()\n                for v in adj[u]:\n                    if color[v] == -1:\n                        color[v] = 1 - color[u]\n                        q.append(v)\n                    elif color[v] == color[u]:\n                        return False\n\n\n    return True\nif __name__ == \"__main__\":\n    V = 4\n    edges = [[0, 1], [0, 2], [1, 2], [2, 3]]\n    print(\"true\" if isBipartite(V, edges) else \"false\")\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/bipartite-graph/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n// dfs Function to reach destination\nbool dfs(int curr, int des, vector<vector<int> >& adj,\n         vector<int>& vis)\n{\n    // If curr node is destination return true\n    if (curr == des) {\n        return true;\n    }\n    vis[curr] = 1;\n    for (auto x : adj[curr]) {\n        if (!vis[x]) {\n            if (dfs(x, des, adj, vis)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n// To tell whether there is path from source to\n// destination\nbool isPath(int src, int des, vector<vector<int> >& adj)\n{\n    vector<int> vis(adj.size() + 1, 0);\n    return dfs(src, des, adj, vis);\n}\n// Function to return all the strongly connected\n// component of a graph.\nvector<vector<int> > findSCC(int n,\n                             vector<vector<int> >& a)\n{\n    // Stores all the strongly connected components.\n    vector<vector<int> > ans;\n    // Stores whether a vertex is a part of any Strongly\n    // Connected Component\n    vector<int> is_scc(n + 1, 0);\n    vector<vector<int> > adj(n + 1);\n    for (int i = 0; i < a.size(); i++) {\n        adj[a[i][0]].push_back(a[i][1]);\n    }\n    // Traversing all the vertices\n    for (int i = 1; i <= n; i++) {\n        if (!is_scc[i]) {\n            // If a vertex i is not a part of any SCC\n            // insert it into a new SCC list and check\n            // for other vertices whether they can be\n            // thr part of thidl ist.\n            vector<int> scc;\n            scc.push_back(i);\n            for (int j = i + 1; j <= n; j++) {\n                // If there is a path from vertex i to\n                // vertex j and vice versa put vertex j\n                // into the current SCC list.\n                if (!is_scc[j] && isPath(i, j, adj)\n                    && isPath(j, i, adj)) {\n                    is_scc[j] = 1;\n                    scc.push_back(j);\n                }\n            }\n            // Insert the SCC containing vertex i into\n            // the final list.\n            ans.push_back(scc);\n        }\n    }\n    return ans;\n}\nint main()\n{\n    int V = 5;\n    vector<vector<int> > edges{\n        { 1, 3 }, { 1, 4 }, { 2, 1 }, { 3, 2 }, { 4, 5 }\n    };\n    vector<vector<int> > ans = findSCC(V, edges);\n    cout << \"Strongly Connected Components are:\\n\";\n    for (int i=0;i<ans.size();i++) {\n        for (int j =0; j< ans[i].size();j++) {\n            cout << ans[i][j] << \" \";\n        }\n        cout << \"\\n\";\n    }\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool dfs(int curr, int des, vector<vector<int> >& adj,\n         vector<int>& vis)\n{\n\n    if (curr == des) {\n        return true;\n    }\n    vis[curr] = 1;\n    for (auto x : adj[curr]) {\n        if (!vis[x]) {\n            if (dfs(x, des, adj, vis)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n\nbool isPath(int src, int des, vector<vector<int> >& adj)\n{\n    vector<int> vis(adj.size() + 1, 0);\n    return dfs(src, des, adj, vis);\n}\n\n\nvector<vector<int> > findSCC(int n,\n                             vector<vector<int> >& a)\n{\n\n    vector<vector<int> > ans;\n\n\n    vector<int> is_scc(n + 1, 0);\n    vector<vector<int> > adj(n + 1);\n    for (int i = 0; i < a.size(); i++) {\n        adj[a[i][0]].push_back(a[i][1]);\n    }\n\n    for (int i = 1; i <= n; i++) {\n        if (!is_scc[i]) {\n\n\n\n\n            vector<int> scc;\n            scc.push_back(i);\n            for (int j = i + 1; j <= n; j++) {\n\n\n\n                if (!is_scc[j] && isPath(i, j, adj)\n                    && isPath(j, i, adj)) {\n                    is_scc[j] = 1;\n                    scc.push_back(j);\n                }\n            }\n\n\n            ans.push_back(scc);\n        }\n    }\n    return ans;\n}\nint main()\n{\n    int V = 5;\n    vector<vector<int> > edges{\n        { 1, 3 }, { 1, 4 }, { 2, 1 }, { 3, 2 }, { 4, 5 }\n    };\n    vector<vector<int> > ans = findSCC(V, edges);\n    cout << \"Strongly Connected Components are:\\n\";\n    for (int i=0;i<ans.size();i++) {\n        for (int j =0; j< ans[i].size();j++) {\n            cout << ans[i][j] << \" \";\n        }\n        cout << \"\\n\";\n    }\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/strongly-connected-components/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "class GfG:\n    # dfs Function to reach destination\n    def dfs(self, curr, des, adj, vis):\n        # If current node is the destination, return True\n        if curr == des:\n            return True\n        vis[curr] = 1\n        for x in adj[curr]:\n            if not vis[x]:\n                if self.dfs(x, des, adj, vis):\n                    return True\n        return False\n    # To tell whether there is a path from source to destination\n    def isPath(self, src, des, adj):\n        vis = [0] * (len(adj) + 1)\n        return self.dfs(src, des, adj, vis)\n    # Function to return all the strongly connected components of a graph.\n    def findSCC(self, n, a):\n        # Stores all the strongly connected components.\n        ans = []\n        # Stores whether a vertex is a part of any Strongly Connected Component\n        is_scc = [0] * (n + 1)\n        adj = [[] for _ in range(n + 1)]\n        for i in range(len(a)):\n            adj[a[i][0]].append(a[i][1])\n        # Traversing all the vertices\n        for i in range(1, n + 1):\n            if not is_scc[i]:\n                # If a vertex i is not a part of any SCC, insert it into a new SCC list\n                # and check for other vertices whether they can be part of this list.\n                scc = [i]\n                for j in range(i + 1, n + 1):\n                    # If there is a path from vertex i to vertex j and vice versa,\n                    # put vertex j into the current SCC list.\n                    if not is_scc[j] and self.isPath(i, j, adj) and self.isPath(j, i, adj):\n                        is_scc[j] = 1\n                        scc.append(j)\n                # Insert the SCC containing vertex i into the final list.\n                ans.append(scc)\n        return ans\nif __name__ == \"__main__\":\n    obj = GfG()\n    V = 5\n    edges = [\n        [1, 3], [1, 4], [2, 1], [3, 2], [4, 5]\n    ]\n    ans = obj.findSCC(V, edges)\n    print(\"Strongly Connected Components are:\")\n    for x in ans:\n        for y in x:\n            print(y, end=\" \")\n        print()",
    "code_without_comments": "class GfG:\n\n    def dfs(self, curr, des, adj, vis):\n\n        if curr == des:\n            return True\n        vis[curr] = 1\n        for x in adj[curr]:\n            if not vis[x]:\n                if self.dfs(x, des, adj, vis):\n                    return True\n        return False\n\n    def isPath(self, src, des, adj):\n        vis = [0] * (len(adj) + 1)\n        return self.dfs(src, des, adj, vis)\n\n    def findSCC(self, n, a):\n\n        ans = []\n\n        is_scc = [0] * (n + 1)\n        adj = [[] for _ in range(n + 1)]\n        for i in range(len(a)):\n            adj[a[i][0]].append(a[i][1])\n\n        for i in range(1, n + 1):\n            if not is_scc[i]:\n\n\n                scc = [i]\n                for j in range(i + 1, n + 1):\n\n\n                    if not is_scc[j] and self.isPath(i, j, adj) and self.isPath(j, i, adj):\n                        is_scc[j] = 1\n                        scc.append(j)\n\n                ans.append(scc)\n        return ans\nif __name__ == \"__main__\":\n    obj = GfG()\n    V = 5\n    edges = [\n        [1, 3], [1, 4], [2, 1], [3, 2], [4, 5]\n    ]\n    ans = obj.findSCC(V, edges)\n    print(\"Strongly Connected Components are:\")\n    for x in ans:\n        for y in x:\n            print(y, end=\" \")\n        print()",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/strongly-connected-components/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "using System;\nclass GfG\n{\n    // DFS function to reach destination\n    public bool dfs(int curr, int des, int[,] adj, int[] vis, int n)\n    {\n        if (curr == des) return true;\n        vis[curr] = 1;\n        for (int i = 1; i <= n; i++)\n        {\n            if (adj[curr, i] == 1 && vis[i] == 0)\n            {\n                if (dfs(i, des, adj, vis, n)) return true;\n            }\n        }\n        return false;\n    }\n    // To tell whether there is a path from source to destination\n    public bool isPath(int src, int des, int[,] adj, int n)\n    {\n        int[] vis = new int[n + 1];\n        return dfs(src, des, adj, vis, n);\n    }\n    // Function to return all the strongly connected components of a graph\n    public int[][] findSCC(int n, int[,] edges, int m)\n    {\n        int[,] adj = new int[n + 1, n + 1];\n        for (int i = 0; i < m; i++)\n        {\n            int u = edges[i, 0];\n            int v = edges[i, 1];\n            adj[u, v] = 1;\n        }\n        int[] isScc = new int[n + 1];\n        int[][] result = new int[n][];\n        int sccIndex = 0;\n        for (int i = 1; i <= n; i++)\n        {\n            if (isScc[i] == 0)\n            {\n                int[] temp = new int[n + 1]; // [0] stores size\n                int size = 0;\n                temp[++size] = i;\n                for (int j = i + 1; j <= n; j++)\n                {\n                    if (isScc[j] == 0 && isPath(i, j, adj, n) && isPath(j, i, adj, n))\n                    {\n                        isScc[j] = 1;\n                        temp[++size] = j;\n                    }\n                }\n                isScc[i] = 1;\n                temp[0] = size;\n                int[] scc = new int[size];\n                for (int k = 0; k < size; k++)\n                {\n                    scc[k] = temp[k + 1];\n                }\n                result[sccIndex++] = scc;\n            }\n        }\n        // Trim result to actual number of SCCs\n        int[][] finalResult = new int[sccIndex][];\n        for (int i = 0; i < sccIndex; i++)\n        {\n            finalResult[i] = result[i];\n        }\n        return finalResult;\n    }\n}\nclass Program\n{\n    static void Main()\n    {\n        GfG obj = new GfG();\n        int V = 5;\n        int[,] edges = {\n            { 1, 3 },\n            { 1, 4 },\n            { 2, 1 },\n            { 3, 2 },\n            { 4, 5 }\n        };\n        int M = edges.GetLength(0);\n        int[][] ans = obj.findSCC(V, edges, M);\n        Console.WriteLine(\"Strongly Connected Components are:\");\n        foreach (int[] scc in ans)\n        {\n            foreach (int node in scc)\n            {\n                Console.Write(node + \" \");\n            }\n            Console.WriteLine();\n        }\n    }\n}",
    "code_without_comments": "using System;\nclass GfG\n{\n\n    public bool dfs(int curr, int des, int[,] adj, int[] vis, int n)\n    {\n        if (curr == des) return true;\n        vis[curr] = 1;\n        for (int i = 1; i <= n; i++)\n        {\n            if (adj[curr, i] == 1 && vis[i] == 0)\n            {\n                if (dfs(i, des, adj, vis, n)) return true;\n            }\n        }\n        return false;\n    }\n\n    public bool isPath(int src, int des, int[,] adj, int n)\n    {\n        int[] vis = new int[n + 1];\n        return dfs(src, des, adj, vis, n);\n    }\n\n    public int[][] findSCC(int n, int[,] edges, int m)\n    {\n        int[,] adj = new int[n + 1, n + 1];\n        for (int i = 0; i < m; i++)\n        {\n            int u = edges[i, 0];\n            int v = edges[i, 1];\n            adj[u, v] = 1;\n        }\n        int[] isScc = new int[n + 1];\n        int[][] result = new int[n][];\n        int sccIndex = 0;\n        for (int i = 1; i <= n; i++)\n        {\n            if (isScc[i] == 0)\n            {\n                int[] temp = new int[n + 1];\n                int size = 0;\n                temp[++size] = i;\n                for (int j = i + 1; j <= n; j++)\n                {\n                    if (isScc[j] == 0 && isPath(i, j, adj, n) && isPath(j, i, adj, n))\n                    {\n                        isScc[j] = 1;\n                        temp[++size] = j;\n                    }\n                }\n                isScc[i] = 1;\n                temp[0] = size;\n                int[] scc = new int[size];\n                for (int k = 0; k < size; k++)\n                {\n                    scc[k] = temp[k + 1];\n                }\n                result[sccIndex++] = scc;\n            }\n        }\n\n        int[][] finalResult = new int[sccIndex][];\n        for (int i = 0; i < sccIndex; i++)\n        {\n            finalResult[i] = result[i];\n        }\n        return finalResult;\n    }\n}\nclass Program\n{\n    static void Main()\n    {\n        GfG obj = new GfG();\n        int V = 5;\n        int[,] edges = {\n            { 1, 3 },\n            { 1, 4 },\n            { 2, 1 },\n            { 3, 2 },\n            { 4, 5 }\n        };\n        int M = edges.GetLength(0);\n        int[][] ans = obj.findSCC(V, edges, M);\n        Console.WriteLine(\"Strongly Connected Components are:\");\n        foreach (int[] scc in ans)\n        {\n            foreach (int node in scc)\n            {\n                Console.Write(node + \" \");\n            }\n            Console.WriteLine();\n        }\n    }\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/strongly-connected-components/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\nclass GfG{\npublic:\n// Run a dfs on the original graph\nvoid DFS1(int u, vector<vector<int>>& adj, vector<bool>& visited, stack<int>& st) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) DFS1(v, adj, visited, st);\n    }\n    st.push(u);\n}\n// DFS on reversed graph to collect SCC\nvoid DFS2(int u, vector<vector<int>>& revAdj, vector<bool>& visited, vector<int>& scc) {\n    visited[u] = true;\n    scc.push_back(u);\n    for (int v : revAdj[u]) {\n        if (!visited[v]) DFS2(v, revAdj, visited, scc);\n    }\n}\nvector<vector<int>> kosaraju(int V, vector<vector<int>>& adj) {\n    vector<bool> visited(V , false);\n    stack<int> st;\n    // Fill stack with finish time order\n    for (int i = 0; i < V ; i++) {\n        if (!visited[i]) DFS1(i, adj, visited, st);\n    }\n    // Reverse the graph\n    vector<vector<int>> revAdj(V);\n    for (int u = 0; u < V; u++) {\n        for (int v : adj[u]) {\n            revAdj[v].push_back(u);\n        }\n    }\n    // Process reversed graph in order of stack\n    fill(visited.begin(), visited.end(), false);\n    vector<vector<int>> SCCs;\n    while (!st.empty()) {\n        int u = st.top(); st.pop();\n        if (!visited[u]) {\n            vector<int> scc;\n            DFS2(u, revAdj, visited, scc);\n            SCCs.push_back(scc);\n        }\n    }\n    return SCCs;\n}\n};\nint main() {\n    GfG obj;\n     int V = 5;\n    vector<vector<int> > edges{\n        { 1, 3 }, { 1, 4 }, { 2, 1 }, { 3, 2 }, { 4, 5 }\n    };\n    vector<vector<int>> adj(V + 1);\n    for (int i = 0; i < edges.size(); i++) {\n        int u = edges[i][0];\n        int v = edges[i][1];\n        adj[u].push_back(v);\n    }\n    vector<vector<int>> SCCs = obj.kosaraju(V + 1, adj);\n    cout << \"Strongly Connected Components:\\n\";\n    for (int i = 0; i < SCCs.size() - 1; i++) {\n        for (int node : SCCs[i]) {\n            cout << node << \" \";\n        }\n        cout << \"\\n\";\n    }\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\nclass GfG{\npublic:\n\nvoid DFS1(int u, vector<vector<int>>& adj, vector<bool>& visited, stack<int>& st) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) DFS1(v, adj, visited, st);\n    }\n    st.push(u);\n}\n\nvoid DFS2(int u, vector<vector<int>>& revAdj, vector<bool>& visited, vector<int>& scc) {\n    visited[u] = true;\n    scc.push_back(u);\n    for (int v : revAdj[u]) {\n        if (!visited[v]) DFS2(v, revAdj, visited, scc);\n    }\n}\nvector<vector<int>> kosaraju(int V, vector<vector<int>>& adj) {\n    vector<bool> visited(V , false);\n    stack<int> st;\n\n    for (int i = 0; i < V ; i++) {\n        if (!visited[i]) DFS1(i, adj, visited, st);\n    }\n\n    vector<vector<int>> revAdj(V);\n    for (int u = 0; u < V; u++) {\n        for (int v : adj[u]) {\n            revAdj[v].push_back(u);\n        }\n    }\n\n    fill(visited.begin(), visited.end(), false);\n    vector<vector<int>> SCCs;\n    while (!st.empty()) {\n        int u = st.top(); st.pop();\n        if (!visited[u]) {\n            vector<int> scc;\n            DFS2(u, revAdj, visited, scc);\n            SCCs.push_back(scc);\n        }\n    }\n    return SCCs;\n}\n};\nint main() {\n    GfG obj;\n     int V = 5;\n    vector<vector<int> > edges{\n        { 1, 3 }, { 1, 4 }, { 2, 1 }, { 3, 2 }, { 4, 5 }\n    };\n    vector<vector<int>> adj(V + 1);\n    for (int i = 0; i < edges.size(); i++) {\n        int u = edges[i][0];\n        int v = edges[i][1];\n        adj[u].push_back(v);\n    }\n    vector<vector<int>> SCCs = obj.kosaraju(V + 1, adj);\n    cout << \"Strongly Connected Components:\\n\";\n    for (int i = 0; i < SCCs.size() - 1; i++) {\n        for (int node : SCCs[i]) {\n            cout << node << \" \";\n        }\n        cout << \"\\n\";\n    }\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/strongly-connected-components/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "from collections import defaultdict\nclass GfG:\n    # Run a dfs on the original graph\n    def DFS1(self, u, adj, visited, st):\n        visited[u] = True\n        for v in adj[u]:\n            if not visited[v]:\n                self.DFS1(v, adj, visited, st)\n        st.append(u)\n    # DFS on reversed graph to collect SCC\n    def DFS2(self, u, revAdj, visited, scc):\n        visited[u] = True\n        scc.append(u)\n        for v in revAdj[u]:\n            if not visited[v]:\n                self.DFS2(v, revAdj, visited, scc)\n    def kosaraju(self, V, adj):\n        visited = [False] * V\n        st = []\n        # Fill stack with finish time order\n        for i in range(V):\n            if not visited[i]:\n                self.DFS1(i, adj, visited, st)\n        # Reverse the graph\n        revAdj = [[] for _ in range(V)]\n        for u in range(V):\n            for v in adj[u]:\n                revAdj[v].append(u)\n        # Process reversed graph in order of stack\n        visited = [False] * V\n        SCCs = []\n        while st:\n            u = st.pop()\n            if not visited[u]:\n                scc = []\n                self.DFS2(u, revAdj, visited, scc)\n                SCCs.append(scc)\n        return SCCs\nif __name__ == \"__main__\":\n    obj = GfG()\n    V = 5\n    edges = [\n        [1, 3], [1, 4], [2, 1], [3, 2], [4, 5]\n    ]\n    adj = [[] for _ in range(V + 1)]\n    for u, v in edges:\n        adj[u].append(v)\n    SCCs = obj.kosaraju(V + 1, adj)\n    print(\"Strongly Connected Components:\")\n    for i in range(len(SCCs) - 1):\n        for node in SCCs[i]:\n            print(node, end=\" \")\n        print()",
    "code_without_comments": "from collections import defaultdict\nclass GfG:\n\n    def DFS1(self, u, adj, visited, st):\n        visited[u] = True\n        for v in adj[u]:\n            if not visited[v]:\n                self.DFS1(v, adj, visited, st)\n        st.append(u)\n\n    def DFS2(self, u, revAdj, visited, scc):\n        visited[u] = True\n        scc.append(u)\n        for v in revAdj[u]:\n            if not visited[v]:\n                self.DFS2(v, revAdj, visited, scc)\n    def kosaraju(self, V, adj):\n        visited = [False] * V\n        st = []\n\n        for i in range(V):\n            if not visited[i]:\n                self.DFS1(i, adj, visited, st)\n\n        revAdj = [[] for _ in range(V)]\n        for u in range(V):\n            for v in adj[u]:\n                revAdj[v].append(u)\n\n        visited = [False] * V\n        SCCs = []\n        while st:\n            u = st.pop()\n            if not visited[u]:\n                scc = []\n                self.DFS2(u, revAdj, visited, scc)\n                SCCs.append(scc)\n        return SCCs\nif __name__ == \"__main__\":\n    obj = GfG()\n    V = 5\n    edges = [\n        [1, 3], [1, 4], [2, 1], [3, 2], [4, 5]\n    ]\n    adj = [[] for _ in range(V + 1)]\n    for u, v in edges:\n        adj[u].append(v)\n    SCCs = obj.kosaraju(V + 1, adj)\n    print(\"Strongly Connected Components:\")\n    for i in range(len(SCCs) - 1):\n        for node in SCCs[i]:\n            print(node, end=\" \")\n        print()",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/strongly-connected-components/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "// C++ program to find articulation points using a naive DFS approach\n#include <bits/stdc++.h>\nusing namespace std;\n// Standard DFS to mark all reachable nodes\nvoid dfs(int node, vector<vector<int>> &adj, vector<bool> &visited) {\n    visited[node] = true;\n    for (int neighbor : adj[node]) {\n        if (!visited[neighbor]) {\n            dfs(neighbor, adj, visited);\n        }\n    }\n}\n// Builds adjacency list from edge list\nvector<vector<int>> constructadj(int V, vector<vector<int>> &edges) {\n    vector<vector<int>> adj(V);\n    for (auto it : edges) {\n        adj[it[0]].push_back(it[1]);\n        adj[it[1]].push_back(it[0]);\n    }\n    return adj;\n}\n// Finds articulation points using naive DFS approach\nvector<int> articulationPoints(int V, vector<vector<int>> &edges) {\n    vector<vector<int>> adj = constructadj(V, edges);\n    vector<int> res;\n    // Try removing each node one by one\n    for (int i = 0; i < V; ++i) {\n        vector<bool> visited(V, false);\n        visited[i] = true;\n        // count DFS calls from i's neighbors\n        int comp = 0;\n        for (auto it : adj[i]) {\n            // early stop if already more than 1 component\n            if (comp > 1) break;\n            if (!visited[it]) {\n                // explore connected part\n                dfs(it, adj, visited);\n                comp++;\n            }\n        }\n        // if more than one component forms, it's an articulation point\n        if (comp > 1)\n            res.push_back(i);\n    }\n    if (res.empty())\n        return {-1};\n    return res;\n}\nint main() {\n    int V = 5;\n    vector<vector<int>> edges = {{0, 1}, {1, 4}, {2, 3}, {2, 4}, {3, 4}};\n    vector<int> ans = articulationPoints(V, edges);\n    for (auto it : ans) {\n        cout << it << \" \";\n    }\n    return 0;\n}",
    "code_without_comments": "\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid dfs(int node, vector<vector<int>> &adj, vector<bool> &visited) {\n    visited[node] = true;\n    for (int neighbor : adj[node]) {\n        if (!visited[neighbor]) {\n            dfs(neighbor, adj, visited);\n        }\n    }\n}\n\nvector<vector<int>> constructadj(int V, vector<vector<int>> &edges) {\n    vector<vector<int>> adj(V);\n    for (auto it : edges) {\n        adj[it[0]].push_back(it[1]);\n        adj[it[1]].push_back(it[0]);\n    }\n    return adj;\n}\n\nvector<int> articulationPoints(int V, vector<vector<int>> &edges) {\n    vector<vector<int>> adj = constructadj(V, edges);\n    vector<int> res;\n\n    for (int i = 0; i < V; ++i) {\n        vector<bool> visited(V, false);\n        visited[i] = true;\n\n        int comp = 0;\n        for (auto it : adj[i]) {\n\n            if (comp > 1) break;\n            if (!visited[it]) {\n\n                dfs(it, adj, visited);\n                comp++;\n            }\n        }\n\n        if (comp > 1)\n            res.push_back(i);\n    }\n    if (res.empty())\n        return {-1};\n    return res;\n}\nint main() {\n    int V = 5;\n    vector<vector<int>> edges = {{0, 1}, {1, 4}, {2, 3}, {2, 4}, {3, 4}};\n    vector<int> ans = articulationPoints(V, edges);\n    for (auto it : ans) {\n        cout << it << \" \";\n    }\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/articulation-points-or-cut-vertices-in-a-graph/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "# Python program to find articulation points using a naive DFS approach\ndef dfs(node, adj, visited):\n    # Standard DFS to mark all reachable nodes\n    visited[node] = True\n    for neighbor in adj[node]:\n        if not visited[neighbor]:\n            dfs(neighbor, adj, visited)\ndef constructadj(V, edges):\n    # Builds adjacency list from edge list\n    adj = [[] for _ in range(V)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\ndef articulationPoints(V, edges):\n    # Finds articulation points using naive DFS approach\n    adj = constructadj(V, edges)\n    res = []\n    # Try removing each node one by one\n    for i in range(V):\n        visited = [False] * V\n        visited[i] = True\n        # count DFS calls from i's neighbors\n        comp = 0\n        for it in adj[i]:\n            if comp > 1:\n                break\n            if not visited[it]:\n                # explore connected part\n                dfs(it, adj, visited)\n                comp += 1\n        # if more than one component forms, it's an articulation point\n        if comp > 1:\n            res.append(i)\n    if not res:\n        return [-1]\n    return res\nif __name__ == \"__main__\":\n    V = 5\n    edges = [[0, 1], [1, 4], [2, 3], [2, 4], [3, 4]]\n    ans = articulationPoints(V, edges)\n    for it in ans:\n        print(it, end=\" \")",
    "code_without_comments": "\ndef dfs(node, adj, visited):\n\n    visited[node] = True\n    for neighbor in adj[node]:\n        if not visited[neighbor]:\n            dfs(neighbor, adj, visited)\ndef constructadj(V, edges):\n\n    adj = [[] for _ in range(V)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\ndef articulationPoints(V, edges):\n\n    adj = constructadj(V, edges)\n    res = []\n\n    for i in range(V):\n        visited = [False] * V\n        visited[i] = True\n        # count DFS calls from i's neighbors\n        comp = 0\n        for it in adj[i]:\n            if comp > 1:\n                break\n            if not visited[it]:\n\n                dfs(it, adj, visited)\n                comp += 1\n        # if more than one component forms, it's an articulation point\n        if comp > 1:\n            res.append(i)\n    if not res:\n        return [-1]\n    return res\nif __name__ == \"__main__\":\n    V = 5\n    edges = [[0, 1], [1, 4], [2, 3], [2, 4], [3, 4]]\n    ans = articulationPoints(V, edges)\n    for it in ans:\n        print(it, end=\" \")",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/articulation-points-or-cut-vertices-in-a-graph/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int>> constructAdj(int V, vector<vector<int>> &edges) {\n    vector<vector<int>> adj(V);\n    for (auto &edge : edges) {\n        adj[edge[0]].push_back(edge[1]);\n        adj[edge[1]].push_back(edge[0]);\n    }\n    return adj;\n}\n// Helper function to perform DFS and find articulation points\n// using Tarjan's algorithm.\nvoid findPoints(vector<vector<int>> &adj, int u, vector<int> &visited,\n                vector<int> &disc, vector<int> &low,\n                int &time, int parent, vector<int> &isAP) {\n    // Mark vertex u as visited and assign discovery\n    // time and low value\n    visited[u] = 1;\n    disc[u] = low[u] = ++time;\n    int children = 0;\n    // Process all adjacent vertices of u\n    for (int v : adj[u]) {\n        // If v is not visited, then recursively visit it\n        if (!visited[v]) {\n            children++;\n            findPoints(adj, v, visited, disc, low, time, u, isAP);\n            // Check if the subtree rooted at v has a\n            // connection to one of the ancestors of u\n            low[u] = min(low[u], low[v]);\n            // If u is not a root and low[v] is greater than or equal to disc[u],\n            // then u is an articulation point\n            if (parent != -1 && low[v] >= disc[u]) {\n                isAP[u] = 1;\n            }\n        }\n        // Update low value of u for back edge\n        else if (v != parent) {\n            low[u] = min(low[u], disc[v]);\n        }\n    }\n    // If u is root of DFS tree and has more than\n    // one child, it is an articulation point\n    if (parent == -1 && children > 1) {\n        isAP[u] = 1;\n    }\n}\n// Main function to find articulation points in the graph\nvector<int> articulationPoints(int V, vector<vector<int>> &edges) {\n    vector<vector<int>> adj = constructAdj(V, edges);\n    vector<int> disc(V, 0), low(V, 0), visited(V, 0), isAP(V, 0);\n    int time = 0;\n    // Run DFS from each vertex if not\n    // already visited (to handle disconnected graphs)\n    for (int u = 0; u < V; u++) {\n        if (!visited[u]) {\n            findPoints(adj, u, visited, disc, low, time, -1, isAP);\n        }\n    }\n    // Collect all vertices that are articulation points\n    vector<int> result;\n    for (int u = 0; u < V; u++) {\n        if (isAP[u]) {\n            result.push_back(u);\n        }\n    }\n    // If no articulation points are found, return vector containing -1\n    return result.empty() ? vector<int>{-1} : result;\n}\nint main() {\n    int V = 5;\n    vector<vector<int>> edges = {{0, 1}, {1, 4}, {2, 3}, {2, 4}, {3, 4}};\n    vector<int> ans = articulationPoints(V, edges);\n    for (int u : ans) {\n        cout << u << \" \";\n    }\n    cout << endl;\n    return 0;\n}",
    "code_without_comments": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int>> constructAdj(int V, vector<vector<int>> &edges) {\n    vector<vector<int>> adj(V);\n    for (auto &edge : edges) {\n        adj[edge[0]].push_back(edge[1]);\n        adj[edge[1]].push_back(edge[0]);\n    }\n    return adj;\n}\n\n\nvoid findPoints(vector<vector<int>> &adj, int u, vector<int> &visited,\n                vector<int> &disc, vector<int> &low,\n                int &time, int parent, vector<int> &isAP) {\n\n\n    visited[u] = 1;\n    disc[u] = low[u] = ++time;\n    int children = 0;\n\n    for (int v : adj[u]) {\n\n        if (!visited[v]) {\n            children++;\n            findPoints(adj, v, visited, disc, low, time, u, isAP);\n\n\n            low[u] = min(low[u], low[v]);\n\n\n            if (parent != -1 && low[v] >= disc[u]) {\n                isAP[u] = 1;\n            }\n        }\n\n        else if (v != parent) {\n            low[u] = min(low[u], disc[v]);\n        }\n    }\n\n\n    if (parent == -1 && children > 1) {\n        isAP[u] = 1;\n    }\n}\n\nvector<int> articulationPoints(int V, vector<vector<int>> &edges) {\n    vector<vector<int>> adj = constructAdj(V, edges);\n    vector<int> disc(V, 0), low(V, 0), visited(V, 0), isAP(V, 0);\n    int time = 0;\n\n\n    for (int u = 0; u < V; u++) {\n        if (!visited[u]) {\n            findPoints(adj, u, visited, disc, low, time, -1, isAP);\n        }\n    }\n\n    vector<int> result;\n    for (int u = 0; u < V; u++) {\n        if (isAP[u]) {\n            result.push_back(u);\n        }\n    }\n\n    return result.empty() ? vector<int>{-1} : result;\n}\nint main() {\n    int V = 5;\n    vector<vector<int>> edges = {{0, 1}, {1, 4}, {2, 3}, {2, 4}, {3, 4}};\n    vector<int> ans = articulationPoints(V, edges);\n    for (int u : ans) {\n        cout << u << \" \";\n    }\n    cout << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/articulation-points-or-cut-vertices-in-a-graph/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "def constructAdj(V, edges):\n    adj = [[] for _ in range(V)]\n    for edge in edges:\n        adj[edge[0]].append(edge[1])\n        adj[edge[1]].append(edge[0])\n    return adj\n# Helper function to perform DFS and find articulation points\n# using Tarjan's algorithm.\ndef findPoints(adj, u, visited, disc, low, time, parent, isAP):\n    # Mark vertex u as visited and assign discovery\n    # time and low value\n    visited[u] = 1\n    time[0] += 1\n    disc[u] = low[u] = time[0]\n    children = 0\n    # Process all adjacent vertices of u\n    for v in adj[u]:\n        # If v is not visited, then recursively visit it\n        if not visited[v]:\n            children += 1\n            findPoints(adj, v, visited, disc, low, time, u, isAP)\n            # Check if the subtree rooted at v has a\n            # connection to one of the ancestors of u\n            low[u] = min(low[u], low[v])\n            # If u is not a root and low[v] is greater than or equal to disc[u],\n            # then u is an articulation point\n            if parent != -1 and low[v] >= disc[u]:\n                isAP[u] = 1\n        # Update low value of u for back edge\n        elif v != parent:\n            low[u] = min(low[u], disc[v])\n    # If u is root of DFS tree and has more than\n    # one child, it is an articulation point\n    if parent == -1 and children > 1:\n        isAP[u] = 1\n# Main function to find articulation points in the graph\ndef articulationPoints(V, edges):\n    adj = constructAdj(V, edges)\n    disc = [0] * V\n    low = [0] * V\n    visited = [0] * V\n    isAP = [0] * V\n    time = [0]\n    # Run DFS from each vertex if not\n    # already visited (to handle disconnected graphs)\n    for u in range(V):\n        if not visited[u]:\n            findPoints(adj, u, visited, disc, low, time, -1, isAP)\n    # Collect all vertices that are articulation points\n    result = [u for u in range(V) if isAP[u]]\n    # If no articulation points are found, return list containing -1\n    return result if result else [-1]\nif __name__ == \"__main__\":\n    V = 5\n    edges = [[0, 1], [1, 4], [2, 3], [2, 4], [3, 4]]\n    ans = articulationPoints(V, edges)\n    for u in ans:\n        print(u, end=' ')\n    print()",
    "code_without_comments": "def constructAdj(V, edges):\n    adj = [[] for _ in range(V)]\n    for edge in edges:\n        adj[edge[0]].append(edge[1])\n        adj[edge[1]].append(edge[0])\n    return adj\n\n# using Tarjan's algorithm.\ndef findPoints(adj, u, visited, disc, low, time, parent, isAP):\n\n\n    visited[u] = 1\n    time[0] += 1\n    disc[u] = low[u] = time[0]\n    children = 0\n\n    for v in adj[u]:\n\n        if not visited[v]:\n            children += 1\n            findPoints(adj, v, visited, disc, low, time, u, isAP)\n\n\n            low[u] = min(low[u], low[v])\n\n\n            if parent != -1 and low[v] >= disc[u]:\n                isAP[u] = 1\n\n        elif v != parent:\n            low[u] = min(low[u], disc[v])\n\n\n    if parent == -1 and children > 1:\n        isAP[u] = 1\n\ndef articulationPoints(V, edges):\n    adj = constructAdj(V, edges)\n    disc = [0] * V\n    low = [0] * V\n    visited = [0] * V\n    isAP = [0] * V\n    time = [0]\n\n\n    for u in range(V):\n        if not visited[u]:\n            findPoints(adj, u, visited, disc, low, time, -1, isAP)\n\n    result = [u for u in range(V) if isAP[u]]\n\n    return result if result else [-1]\nif __name__ == \"__main__\":\n    V = 5\n    edges = [[0, 1], [1, 4], [2, 3], [2, 4], [3, 4]]\n    ans = articulationPoints(V, edges)\n    for u in ans:\n        print(u, end=' ')\n    print()",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/articulation-points-or-cut-vertices-in-a-graph/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "// A C++ program to find bridges in a given undirected graph\n#include<bits/stdc++.h>\nusing namespace std;\n// A class that represents an undirected graph\nclass Graph\n{\n    int V;    // No. of vertices\n    list<int> *adj;    // A dynamic array of adjacency lists\n    void bridgeUtil(int u, vector<bool>& visited, vector<int>& disc,\n                                  vector<int>& low, int parent);\npublic:\n    Graph(int V);   // Constructor\n    void addEdge(int v, int w);   // to add an edge to graph\n    void bridge();    // prints all bridges\n};\nGraph::Graph(int V)\n{\n    this->V = V;\n    adj = new list<int>[V];\n}\nvoid Graph::addEdge(int v, int w)\n{\n    adj[v].push_back(w);\n    adj[w].push_back(v);  // Note: the graph is undirected\n}\n// A recursive function that finds and prints bridges using\n// DFS traversal\n// u --> The vertex to be visited next\n// visited[] --> keeps track of visited vertices\n// disc[] --> Stores discovery times of visited vertices\n// parent[] --> Stores parent vertices in DFS tree\nvoid Graph::bridgeUtil(int u, vector<bool>& visited, vector<int>& disc,\n                                  vector<int>& low, int parent)\n{\n    // A static variable is used for simplicity, we can\n    // avoid use of static variable by passing a pointer.\n    static int time = 0;\n    // Mark the current node as visited\n    visited[u] = true;\n    // Initialize discovery time and low value\n    disc[u] = low[u] = ++time;\n    // Go through all vertices adjacent to this\n    list<int>::iterator i;\n    for (i = adj[u].begin(); i != adj[u].end(); ++i)\n    {\n        int v = *i;  // v is current adjacent of u\n          // 1. If v is parent\n          if(v==parent)\n            continue;\n          //2. If v is visited\n          if(visited[v]){\n          low[u]  = min(low[u], disc[v]);\n        }\n          //3. If v is not visited\n          else{\n          parent = u;\n          bridgeUtil(v, visited, disc, low, parent);\n          // update the low of u as it's quite possible\n          // a connection exists from v's descendants to u\n          low[u]  = min(low[u], low[v]);\n          // if the lowest possible time to reach vertex v\n          // is greater than discovery time of u it means\n          // that v can be only be reached by vertex above v\n          // so if that edge is removed v can't be reached so it's a bridge\n          if (low[v] > disc[u])\n              cout << u <<\" \" << v << endl;\n        }\n    }\n}\n// DFS based function to find all bridges. It uses recursive\n// function bridgeUtil()\nvoid Graph::bridge()\n{\n    // Mark all the vertices as not visited disc and low as -1\n    vector<bool> visited (V,false);\n    vector<int> disc (V,-1);\n      vector<int> low (V,-1);\n      // Initially there is no parent so let it be -1\n      int parent = -1;\n    // Call the recursive helper function to find Bridges\n    // in DFS tree rooted with vertex 'i'\n    for (int i = 0; i < V; i++)\n        if (visited[i] == false)\n            bridgeUtil(i, visited, disc, low, parent);\n}\n// Driver program to test above function\nint main()\n{\n    // Create graphs given in above diagrams\n    cout << \"\\nBridges in first graph \\n\";\n    Graph g1(5);\n    g1.addEdge(1, 0);\n    g1.addEdge(0, 2);\n    g1.addEdge(2, 1);\n    g1.addEdge(0, 3);\n    g1.addEdge(3, 4);\n    g1.bridge();\n    cout << \"\\nBridges in second graph \\n\";\n    Graph g2(4);\n    g2.addEdge(0, 1);\n    g2.addEdge(1, 2);\n    g2.addEdge(2, 3);\n    g2.bridge();\n    cout << \"\\nBridges in third graph \\n\";\n    Graph g3(7);\n    g3.addEdge(0, 1);\n    g3.addEdge(1, 2);\n    g3.addEdge(2, 0);\n    g3.addEdge(1, 3);\n    g3.addEdge(1, 4);\n    g3.addEdge(1, 6);\n    g3.addEdge(3, 5);\n    g3.addEdge(4, 5);\n    g3.bridge();\n    return 0;\n}",
    "code_without_comments": "\n#include<bits/stdc++.h>\nusing namespace std;\n\nclass Graph\n{\n    int V;\n    list<int> *adj;\n    void bridgeUtil(int u, vector<bool>& visited, vector<int>& disc,\n                                  vector<int>& low, int parent);\npublic:\n    Graph(int V);\n    void addEdge(int v, int w);\n    void bridge();\n};\nGraph::Graph(int V)\n{\n    this->V = V;\n    adj = new list<int>[V];\n}\nvoid Graph::addEdge(int v, int w)\n{\n    adj[v].push_back(w);\n    adj[w].push_back(v);\n}\n\n\n\n\n\n\nvoid Graph::bridgeUtil(int u, vector<bool>& visited, vector<int>& disc,\n                                  vector<int>& low, int parent)\n{\n\n\n    static int time = 0;\n\n    visited[u] = true;\n\n    disc[u] = low[u] = ++time;\n\n    list<int>::iterator i;\n    for (i = adj[u].begin(); i != adj[u].end(); ++i)\n    {\n        int v = *i;\n\n          if(v==parent)\n            continue;\n\n          if(visited[v]){\n          low[u]  = min(low[u], disc[v]);\n        }\n\n          else{\n          parent = u;\n          bridgeUtil(v, visited, disc, low, parent);\n\n\n          low[u]  = min(low[u], low[v]);\n\n\n\n\n          if (low[v] > disc[u])\n              cout << u <<\" \" << v << endl;\n        }\n    }\n}\n\n\nvoid Graph::bridge()\n{\n\n    vector<bool> visited (V,false);\n    vector<int> disc (V,-1);\n      vector<int> low (V,-1);\n\n      int parent = -1;\n\n\n    for (int i = 0; i < V; i++)\n        if (visited[i] == false)\n            bridgeUtil(i, visited, disc, low, parent);\n}\n\nint main()\n{\n\n    cout << \"\\nBridges in first graph \\n\";\n    Graph g1(5);\n    g1.addEdge(1, 0);\n    g1.addEdge(0, 2);\n    g1.addEdge(2, 1);\n    g1.addEdge(0, 3);\n    g1.addEdge(3, 4);\n    g1.bridge();\n    cout << \"\\nBridges in second graph \\n\";\n    Graph g2(4);\n    g2.addEdge(0, 1);\n    g2.addEdge(1, 2);\n    g2.addEdge(2, 3);\n    g2.bridge();\n    cout << \"\\nBridges in third graph \\n\";\n    Graph g3(7);\n    g3.addEdge(0, 1);\n    g3.addEdge(1, 2);\n    g3.addEdge(2, 0);\n    g3.addEdge(1, 3);\n    g3.addEdge(1, 4);\n    g3.addEdge(1, 6);\n    g3.addEdge(3, 5);\n    g3.addEdge(4, 5);\n    g3.bridge();\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/bridge-in-a-graph/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "# Python program to find bridges in a given undirected graph\n#Complexity : O(V+E)\nfrom collections import defaultdict\n#This class represents an undirected graph using adjacency list representation\nclass Graph:\n    def __init__(self,vertices):\n        self.V= vertices #No. of vertices\n        self.graph = defaultdict(list) # default dictionary to store graph\n        self.Time = 0\n    # function to add an edge to graph\n    def addEdge(self,u,v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n    '''A recursive function that finds and prints bridges\n    using DFS traversal\n    u --> The vertex to be visited next\n    visited[] --> keeps track of visited vertices\n    disc[] --> Stores discovery times of visited vertices\n    parent[] --> Stores parent vertices in DFS tree'''\n    def bridgeUtil(self,u, visited, parent, low, disc):\n        # Mark the current node as visited and print it\n        visited[u]= True\n        # Initialize discovery time and low value\n        disc[u] = self.Time\n        low[u] = self.Time\n        self.Time += 1\n        #Recur for all the vertices adjacent to this vertex\n        for v in self.graph[u]:\n            # If v is not visited yet, then make it a child of u\n            # in DFS tree and recur for it\n            if visited[v] == False :\n                parent[v] = u\n                self.bridgeUtil(v, visited, parent, low, disc)\n                # Check if the subtree rooted with v has a connection to\n                # one of the ancestors of u\n                low[u] = min(low[u], low[v])\n                ''' If the lowest vertex reachable from subtree\n                under v is below u in DFS tree, then u-v is\n                a bridge'''\n                if low[v] > disc[u]:\n                    print (\"%d %d\" %(u,v))\n            elif v != parent[u]: # Update low value of u for parent function calls.\n                low[u] = min(low[u], disc[v])\n    # DFS based function to find all bridges. It uses recursive\n    # function bridgeUtil()\n    def bridge(self):\n        # Mark all the vertices as not visited and Initialize parent and visited,\n        # and ap(articulation point) arrays\n        visited = [False] * (self.V)\n        disc = [float(\"Inf\")] * (self.V)\n        low = [float(\"Inf\")] * (self.V)\n        parent = [-1] * (self.V)\n        # Call the recursive helper function to find bridges\n        # in DFS tree rooted with vertex 'i'\n        for i in range(self.V):\n            if visited[i] == False:\n                self.bridgeUtil(i, visited, parent, low, disc)\n# Create a graph given in the above diagram\ng1 = Graph(5)\ng1.addEdge(1, 0)\ng1.addEdge(0, 2)\ng1.addEdge(2, 1)\ng1.addEdge(0, 3)\ng1.addEdge(3, 4)\nprint (\"Bridges in first graph \")\ng1.bridge()\ng2 = Graph(4)\ng2.addEdge(0, 1)\ng2.addEdge(1, 2)\ng2.addEdge(2, 3)\nprint (\"\\nBridges in second graph \")\ng2.bridge()\ng3 = Graph (7)\ng3.addEdge(0, 1)\ng3.addEdge(1, 2)\ng3.addEdge(2, 0)\ng3.addEdge(1, 3)\ng3.addEdge(1, 4)\ng3.addEdge(1, 6)\ng3.addEdge(3, 5)\ng3.addEdge(4, 5)\nprint (\"\\nBridges in third graph \")\ng3.bridge()\n#This code is contributed by Neelam Yadav",
    "code_without_comments": "\n\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self,vertices):\n        self.V= vertices\n        self.graph = defaultdict(list)\n        self.Time = 0\n\n    def addEdge(self,u,v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n    '''A recursive function that finds and prints bridges\n    using DFS traversal\n    u --> The vertex to be visited next\n    visited[] --> keeps track of visited vertices\n    disc[] --> Stores discovery times of visited vertices\n    parent[] --> Stores parent vertices in DFS tree'''\n    def bridgeUtil(self,u, visited, parent, low, disc):\n\n        visited[u]= True\n\n        disc[u] = self.Time\n        low[u] = self.Time\n        self.Time += 1\n\n        for v in self.graph[u]:\n\n\n            if visited[v] == False :\n                parent[v] = u\n                self.bridgeUtil(v, visited, parent, low, disc)\n\n\n                low[u] = min(low[u], low[v])\n                ''' If the lowest vertex reachable from subtree\n                under v is below u in DFS tree, then u-v is\n                a bridge'''\n                if low[v] > disc[u]:\n                    print (\"%d %d\" %(u,v))\n            elif v != parent[u]:\n                low[u] = min(low[u], disc[v])\n\n\n    def bridge(self):\n\n\n        visited = [False] * (self.V)\n        disc = [float(\"Inf\")] * (self.V)\n        low = [float(\"Inf\")] * (self.V)\n        parent = [-1] * (self.V)\n\n        # in DFS tree rooted with vertex 'i'\n        for i in range(self.V):\n            if visited[i] == False:\n                self.bridgeUtil(i, visited, parent, low, disc)\n\ng1 = Graph(5)\ng1.addEdge(1, 0)\ng1.addEdge(0, 2)\ng1.addEdge(2, 1)\ng1.addEdge(0, 3)\ng1.addEdge(3, 4)\nprint (\"Bridges in first graph \")\ng1.bridge()\ng2 = Graph(4)\ng2.addEdge(0, 1)\ng2.addEdge(1, 2)\ng2.addEdge(2, 3)\nprint (\"\\nBridges in second graph \")\ng2.bridge()\ng3 = Graph (7)\ng3.addEdge(0, 1)\ng3.addEdge(1, 2)\ng3.addEdge(2, 0)\ng3.addEdge(1, 3)\ng3.addEdge(1, 4)\ng3.addEdge(1, 6)\ng3.addEdge(3, 5)\ng3.addEdge(4, 5)\nprint (\"\\nBridges in third graph \")\ng3.bridge()\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/bridge-in-a-graph/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\nusing namespace std;\n// A recursive DFS based function used by getSCCs()\n// u        -> The vertex to be visited next\n// disc[]   -> Stores discovery times of visited vertices\n// low[]    -> Earliest visited vertex that can be reached\n//             from subtree rooted with current vertex\n// st       -> Stack to store all active DFS vertices\n// inSt[]   -> Boolean array to check whether a node is in stack\n// timer    -> Global time counter for discovery times\n// allSCCs  -> Stores all strongly connected components\nvoid findSCC(int u, vector<vector<int>> &adj, vector<int> &disc, vector<int> &low,\n             vector<bool> &inSt, stack<int> &st, int &timer, vector<vector<int>> &allSCCs) {\n    // Initialize discovery time and low value\n    disc[u] = low[u] = ++timer;\n    // Push current vertex to stack and mark it as in stack\n    st.push(u);\n    inSt[u] = true;\n    // Go through all vertices adjacent to this\n    for (int v : adj[u]) {\n        // If v is not visited yet, then recur for it\n        // Case 1: Tree edge\n        if (disc[v] == -1) {\n            findSCC(v, adj, disc, low, inSt, st, timer, allSCCs);\n            // Check if the subtree rooted with v has a\n            // connection to one of the ancestors of u\n            low[u] = min(low[u], low[v]);\n        }\n        // Update low value of u only if v is still in stack\n        // Case 2: Back edge (not cross edge)\n        else if (inSt[v]) {\n            low[u] = min(low[u], disc[v]);\n        }\n    }\n    // If u is head node of SCC, pop the stack and store the SCC\n    if (low[u] == disc[u]) {\n        vector<int> scc;\n        // Pop all vertices from stack till u is found\n        while (true) {\n            int x = st.top();\n            st.pop();\n            inSt[x] = false;\n            scc.push_back(x);\n            if (x == u)\n                break;\n        }\n        // Store one strongly connected component\n        allSCCs.push_back(scc);\n    }\n}\n// The function to do DFS traversal.\n// It uses findSCC() to find all strongly connected components\nvector<vector<int>> getSCCs(vector<vector<int>> &adj) {\n    int n = adj.size();\n    vector<int> disc(n, -1);\n    vector<int> low(n, -1);\n    vector<bool> inSt(n, false);\n    stack<int> st;\n    int timer = 0;\n    vector<vector<int>> allSCCs;\n    // Call the recursive helper function to find SCCs\n    // in DFS tree with vertex i\n    for (int i = 0; i < n; i++) {\n        if (disc[i] == -1) {\n            findSCC(i, adj, disc, low, inSt, st, timer, allSCCs);\n        }\n    }\n    return allSCCs;\n}\nint main() {\n    int n = 6;\n    vector<vector<int>> adj(n);\n    // Graph construction\n    adj[0].push_back(1);\n    adj[1].push_back(2);\n    adj[2].push_back(0);\n    adj[2].push_back(3);\n    adj[3].push_back(4);\n    adj[4].push_back(3);\n    adj[4].push_back(5);\n    vector<vector<int>> sccs = getSCCs(adj);\n    cout << \"Strongly Connected Components:\\n\";\n    for (auto &scc : sccs) {\n        for (int node : scc) {\n            cout << node << \" \";\n        }\n        cout << \"\\n\";\n    }\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\nusing namespace std;\n\n\n\n\n\n\n\n\n\nvoid findSCC(int u, vector<vector<int>> &adj, vector<int> &disc, vector<int> &low,\n             vector<bool> &inSt, stack<int> &st, int &timer, vector<vector<int>> &allSCCs) {\n\n    disc[u] = low[u] = ++timer;\n\n    st.push(u);\n    inSt[u] = true;\n\n    for (int v : adj[u]) {\n\n\n        if (disc[v] == -1) {\n            findSCC(v, adj, disc, low, inSt, st, timer, allSCCs);\n\n\n            low[u] = min(low[u], low[v]);\n        }\n\n\n        else if (inSt[v]) {\n            low[u] = min(low[u], disc[v]);\n        }\n    }\n\n    if (low[u] == disc[u]) {\n        vector<int> scc;\n\n        while (true) {\n            int x = st.top();\n            st.pop();\n            inSt[x] = false;\n            scc.push_back(x);\n            if (x == u)\n                break;\n        }\n\n        allSCCs.push_back(scc);\n    }\n}\n\n\nvector<vector<int>> getSCCs(vector<vector<int>> &adj) {\n    int n = adj.size();\n    vector<int> disc(n, -1);\n    vector<int> low(n, -1);\n    vector<bool> inSt(n, false);\n    stack<int> st;\n    int timer = 0;\n    vector<vector<int>> allSCCs;\n\n\n    for (int i = 0; i < n; i++) {\n        if (disc[i] == -1) {\n            findSCC(i, adj, disc, low, inSt, st, timer, allSCCs);\n        }\n    }\n    return allSCCs;\n}\nint main() {\n    int n = 6;\n    vector<vector<int>> adj(n);\n\n    adj[0].push_back(1);\n    adj[1].push_back(2);\n    adj[2].push_back(0);\n    adj[2].push_back(3);\n    adj[3].push_back(4);\n    adj[4].push_back(3);\n    adj[4].push_back(5);\n    vector<vector<int>> sccs = getSCCs(adj);\n    cout << \"Strongly Connected Components:\\n\";\n    for (auto &scc : sccs) {\n        for (int node : scc) {\n            cout << node << \" \";\n        }\n        cout << \"\\n\";\n    }\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/tarjan-algorithm-find-strongly-connected-components/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "# A recursive DFS based function used by getSCCs()\n# u        -> The vertex to be visited next\n# disc[]   -> Stores discovery times of visited vertices\n# low[]    -> Earliest visited vertex that can be reached\n#             from subtree rooted with current vertex\n# st       -> Stack to store all active DFS vertices\n# inSt[]   -> Boolean array to check whether a node is in stack\n# timer    -> Global time counter for discovery times\n# allSCCs  -> Stores all strongly connected components\ndef findSCC(u, adj, disc, low, inSt, st, timer, allSCCs):\n    # Initialize discovery time and low value\n    timer[0] += 1\n    disc[u] = low[u] = timer[0]\n    # Push current vertex to stack and mark it as in stack\n    st.append(u)\n    inSt[u] = True\n    # Go through all vertices adjacent to this\n    for v in adj[u]:\n        # If v is not visited yet, then recur for it\n        # Case 1: Tree edge\n        if disc[v] == -1:\n            findSCC(v, adj, disc, low, inSt, st, timer, allSCCs)\n            # Check if the subtree rooted with v has a\n            # connection to one of the ancestors of u\n            low[u] = min(low[u], low[v])\n        # Update low value of u only if v is still in stack\n        # Case 2: Back edge (not cross edge)\n        elif inSt[v]:\n            low[u] = min(low[u], disc[v])\n    # If u is head node of SCC, pop the stack and store the SCC\n    if low[u] == disc[u]:\n        scc = []\n        # Pop all vertices from stack till u is found\n        while True:\n            x = st.pop()\n            inSt[x] = False\n            scc.append(x)\n            if x == u:\n                break\n        # Store one strongly connected component\n        allSCCs.append(scc)\n# The function to do DFS traversal.\n# It uses findSCC() to find all strongly connected components\ndef getSCCs(adj):\n    n = len(adj)\n    disc = [-1] * n\n    low = [-1] * n\n    inSt = [False] * n\n    st = []\n    timer = [0]\n    allSCCs = []\n    # Call the recursive helper function to find SCCs\n    # in DFS tree with vertex i\n    for i in range(n):\n        if disc[i] == -1:\n            findSCC(i, adj, disc, low, inSt, st, timer, allSCCs)\n    return allSCCs\nif __name__ == \"__main__\":\n    adj = [[] for _ in range(6)]\n    # Graph construction\n    adj[0].append(1)\n    adj[1].append(2)\n    adj[2].append(0)\n    adj[2].append(3)\n    adj[3].append(4)\n    adj[4].append(3)\n    adj[4].append(5)\n    sccs = getSCCs(adj)\n    print(\"Strongly Connected Components:\")\n    for scc in sccs:\n        print(*scc)",
    "code_without_comments": "\n\n\n\n\n\n\n\n\ndef findSCC(u, adj, disc, low, inSt, st, timer, allSCCs):\n\n    timer[0] += 1\n    disc[u] = low[u] = timer[0]\n\n    st.append(u)\n    inSt[u] = True\n\n    for v in adj[u]:\n\n\n        if disc[v] == -1:\n            findSCC(v, adj, disc, low, inSt, st, timer, allSCCs)\n\n\n            low[u] = min(low[u], low[v])\n\n\n        elif inSt[v]:\n            low[u] = min(low[u], disc[v])\n\n    if low[u] == disc[u]:\n        scc = []\n\n        while True:\n            x = st.pop()\n            inSt[x] = False\n            scc.append(x)\n            if x == u:\n                break\n\n        allSCCs.append(scc)\n\n\ndef getSCCs(adj):\n    n = len(adj)\n    disc = [-1] * n\n    low = [-1] * n\n    inSt = [False] * n\n    st = []\n    timer = [0]\n    allSCCs = []\n\n\n    for i in range(n):\n        if disc[i] == -1:\n            findSCC(i, adj, disc, low, inSt, st, timer, allSCCs)\n    return allSCCs\nif __name__ == \"__main__\":\n    adj = [[] for _ in range(6)]\n\n    adj[0].append(1)\n    adj[1].append(2)\n    adj[2].append(0)\n    adj[2].append(3)\n    adj[3].append(4)\n    adj[4].append(3)\n    adj[4].append(5)\n    sccs = getSCCs(adj)\n    print(\"Strongly Connected Components:\")\n    for scc in sccs:\n        print(*scc)",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/tarjan-algorithm-find-strongly-connected-components/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <iostream>\n#include<vector>\nusing namespace std;\n//Driver Code Ends\n// Returns the maximum value that\n// can be put in a knapsack of capacity W\nint knapsackRec(int W, vector<int> &val, vector<int> &wt, int n) {\n    // Base Case\n    if (n == 0 || W == 0)\n        return 0;\n    int pick = 0;\n    // Pick nth item if it does not exceed the capacity of knapsack\n    if (wt[n - 1] <= W)\n        pick = val[n - 1] + knapsackRec(W - wt[n - 1], val, wt, n - 1);\n    // Don't pick the nth item\n    int notPick = knapsackRec(W, val, wt, n - 1);\n    return max(pick, notPick);\n}\nint knapsack(int W, vector<int> &val, vector<int> &wt) {\n    int n = val.size();\n    return knapsackRec(W, val, wt, n);\n}\n//Driver Code Starts\nint main() {\n    vector<int> val = {1, 2, 3};\n    vector<int> wt = {4, 5, 1};\n    int W = 4;\n    cout << knapsack(W, val, wt) << endl;\n    return 0;\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <iostream>\n#include<vector>\nusing namespace std;\n\n\n\nint knapsackRec(int W, vector<int> &val, vector<int> &wt, int n) {\n\n    if (n == 0 || W == 0)\n        return 0;\n    int pick = 0;\n\n    if (wt[n - 1] <= W)\n        pick = val[n - 1] + knapsackRec(W - wt[n - 1], val, wt, n - 1);\n\n    int notPick = knapsackRec(W, val, wt, n - 1);\n    return max(pick, notPick);\n}\nint knapsack(int W, vector<int> &val, vector<int> &wt) {\n    int n = val.size();\n    return knapsackRec(W, val, wt, n);\n}\n\nint main() {\n    vector<int> val = {1, 2, 3};\n    vector<int> wt = {4, 5, 1};\n    int W = 4;\n    cout << knapsack(W, val, wt) << endl;\n    return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "# Returns the maximum value that\n# can be put in a knapsack of capacity W\ndef knapsackRec(W, val, wt, n):\n    # Base Case\n    if n == 0 or W == 0:\n        return 0\n    pick = 0\n    # Pick nth item if it does not exceed the capacity of knapsack\n    if wt[n - 1] <= W:\n        pick = val[n - 1] + knapsackRec(W - wt[n - 1], val, wt, n - 1)\n    # Don't pick the nth item\n    notPick = knapsackRec(W, val, wt, n - 1)\n    return max(pick, notPick)\ndef knapsack(W, val, wt):\n    n = len(val)\n    return knapsackRec(W, val, wt, n)\nif __name__ == \"__main__\":\n//Driver Code Starts\n    val = [1, 2, 3]\n    wt = [4, 5, 1]\n    W = 4\n    print(knapsack(W, val, wt))\n//Driver Code Ends",
    "code_without_comments": "\n\ndef knapsackRec(W, val, wt, n):\n\n    if n == 0 or W == 0:\n        return 0\n    pick = 0\n\n    if wt[n - 1] <= W:\n        pick = val[n - 1] + knapsackRec(W - wt[n - 1], val, wt, n - 1)\n    # Don't pick the nth item\n    notPick = knapsackRec(W, val, wt, n - 1)\n    return max(pick, notPick)\ndef knapsack(W, val, wt):\n    n = len(val)\n    return knapsackRec(W, val, wt, n)\nif __name__ == \"__main__\":\n//Driver Code Starts\n    val = [1, 2, 3]\n    wt = [4, 5, 1]\n    W = 4\n    print(knapsack(W, val, wt))\n//Driver Code Ends",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <iostream>\n#include<vector>\nusing namespace std;\n//Driver Code Ends\n// Returns the maximum value that\n// can be put in a knapsack of capacity W\nint knapsackRec(int W, vector<int> &val, vector<int> &wt, int n,\n                                        vector<vector<int>> &memo) {\n    // Base Case\n    if (n == 0 || W == 0)\n        return 0;\n    // Check if we have previously calculated the same subproblem\n    if(memo[n][W] != -1)\n        return memo[n][W];\n    int pick = 0;\n    // Pick nth item if it does not exceed the capacity of knapsack\n    if (wt[n - 1] <= W)\n        pick = val[n - 1] + knapsackRec(W - wt[n - 1], val, wt, n - 1, memo);\n    // Don't pick the nth item\n    int notPick = knapsackRec(W, val, wt, n - 1, memo);\n    // Store the result in memo[n][W] and return it\n    return memo[n][W] = max(pick, notPick);\n}\nint knapsack(int W, vector<int> &val, vector<int> &wt) {\n    int n = val.size();\n    // Memoization table to store the results\n    vector<vector<int>> memo(n + 1, vector<int>(W + 1, -1));\n    return knapsackRec(W, val, wt, n, memo);\n}\n//Driver Code Starts\nint main() {\n    vector<int> val = {1, 2, 3};\n    vector<int> wt = {4, 5, 1};\n    int W = 4;\n    cout << knapsack(W, val, wt) << endl;\n    return 0;\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <iostream>\n#include<vector>\nusing namespace std;\n\n\n\nint knapsackRec(int W, vector<int> &val, vector<int> &wt, int n,\n                                        vector<vector<int>> &memo) {\n\n    if (n == 0 || W == 0)\n        return 0;\n\n    if(memo[n][W] != -1)\n        return memo[n][W];\n    int pick = 0;\n\n    if (wt[n - 1] <= W)\n        pick = val[n - 1] + knapsackRec(W - wt[n - 1], val, wt, n - 1, memo);\n\n    int notPick = knapsackRec(W, val, wt, n - 1, memo);\n\n    return memo[n][W] = max(pick, notPick);\n}\nint knapsack(int W, vector<int> &val, vector<int> &wt) {\n    int n = val.size();\n\n    vector<vector<int>> memo(n + 1, vector<int>(W + 1, -1));\n    return knapsackRec(W, val, wt, n, memo);\n}\n\nint main() {\n    vector<int> val = {1, 2, 3};\n    vector<int> wt = {4, 5, 1};\n    int W = 4;\n    cout << knapsack(W, val, wt) << endl;\n    return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "# Returns the maximum value that\n# can be put in a knapsack of capacity W\ndef knapsackRec(W, val, wt, n, memo):\n    # Base Case\n    if n == 0 or W == 0:\n        return 0\n    # Check if we have previously calculated the same subproblem\n    if memo[n][W] != -1:\n        return memo[n][W]\n    pick = 0\n    # Pick nth item if it does not exceed the capacity of knapsack\n    if wt[n - 1] <= W:\n        pick = val[n - 1] + knapsackRec(W - wt[n - 1], val, wt, n - 1, memo)\n    # Don't pick the nth item\n    notPick = knapsackRec(W, val, wt, n - 1, memo)\n    # Store the result in memo[n][W] and return it\n    memo[n][W] = max(pick, notPick)\n    return memo[n][W]\ndef knapsack(W, val, wt):\n    n = len(val)\n    # Memoization table to store the results\n    memo = [[-1] * (W + 1) for _ in range(n + 1)]\n    return knapsackRec(W, val, wt, n, memo)\nif __name__ == \"__main__\":\n#Driver Code Starts\n    val = [1, 2, 3]\n    wt = [4, 5, 1]\n    W = 4\n    print(knapsack(W, val, wt))\n#Driver Code Ends",
    "code_without_comments": "\n\ndef knapsackRec(W, val, wt, n, memo):\n\n    if n == 0 or W == 0:\n        return 0\n\n    if memo[n][W] != -1:\n        return memo[n][W]\n    pick = 0\n\n    if wt[n - 1] <= W:\n        pick = val[n - 1] + knapsackRec(W - wt[n - 1], val, wt, n - 1, memo)\n    # Don't pick the nth item\n    notPick = knapsackRec(W, val, wt, n - 1, memo)\n\n    memo[n][W] = max(pick, notPick)\n    return memo[n][W]\ndef knapsack(W, val, wt):\n    n = len(val)\n\n    memo = [[-1] * (W + 1) for _ in range(n + 1)]\n    return knapsackRec(W, val, wt, n, memo)\nif __name__ == \"__main__\":\n\n    val = [1, 2, 3]\n    wt = [4, 5, 1]\n    W = 4\n    print(knapsack(W, val, wt))\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <iostream>\n#include<vector>\nusing namespace std;\n//Driver Code Ends\nint knapsack(int W, vector<int> &val, vector<int> &wt) {\n    int n = wt.size();\n    vector<vector<int>> dp(n + 1, vector<int>(W + 1));\n    // Build table dp[][] in bottom-up manner\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= W; j++) {\n            // If there is no item or the knapsack's capacity is 0\n            if (i == 0 || j == 0)\n                dp[i][j] = 0;\n            else {\n                int pick = 0;\n                // Pick ith item if it does not exceed the capacity of knapsack\n                if(wt[i - 1] <= j)\n                    pick = val[i - 1] + dp[i - 1][j - wt[i - 1]];\n                // Don't pick the ith item\n                int notPick = dp[i - 1][j];\n                dp[i][j] = max(pick, notPick);\n            }\n        }\n    }\n    return dp[n][W];\n}\n//Driver Code Starts\nint main() {\n    vector<int> val = {1, 2, 3};\n    vector<int> wt = {4, 5, 1};\n    int W = 4;\n    cout << knapsack(W, val, wt) << endl;\n    return 0;\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <iostream>\n#include<vector>\nusing namespace std;\n\nint knapsack(int W, vector<int> &val, vector<int> &wt) {\n    int n = wt.size();\n    vector<vector<int>> dp(n + 1, vector<int>(W + 1));\n\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= W; j++) {\n\n            if (i == 0 || j == 0)\n                dp[i][j] = 0;\n            else {\n                int pick = 0;\n\n                if(wt[i - 1] <= j)\n                    pick = val[i - 1] + dp[i - 1][j - wt[i - 1]];\n\n                int notPick = dp[i - 1][j];\n                dp[i][j] = max(pick, notPick);\n            }\n        }\n    }\n    return dp[n][W];\n}\n\nint main() {\n    vector<int> val = {1, 2, 3};\n    vector<int> wt = {4, 5, 1};\n    int W = 4;\n    cout << knapsack(W, val, wt) << endl;\n    return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "def knapsack(W, val, wt):\n    n = len(wt)\n    dp = [[0 for _ in range(W + 1)] for _ in range(n + 1)]\n    # Build table dp[][] in bottom-up manner\n    for i in range(n + 1):\n        for j in range(W + 1):\n            # If there is no item or the knapsack's capacity is 0\n            if i == 0 or j == 0:\n                dp[i][j] = 0\n            else:\n                pick = 0\n                # Pick ith item if it does not exceed the capacity of knapsack\n                if wt[i - 1] <= j:\n                    pick = val[i - 1] + dp[i - 1][j - wt[i - 1]]\n                # Don't pick the ith item\n                notPick = dp[i - 1][j]\n                dp[i][j] = max(pick, notPick)\n    return dp[n][W]\nif __name__ == \"__main__\":\n#Driver Code Starts\n    val = [1, 2, 3]\n    wt = [4, 5, 1]\n    W = 4\n    print(knapsack(W, val, wt))\n#Driver Code Ends",
    "code_without_comments": "def knapsack(W, val, wt):\n    n = len(wt)\n    dp = [[0 for _ in range(W + 1)] for _ in range(n + 1)]\n\n    for i in range(n + 1):\n        for j in range(W + 1):\n            # If there is no item or the knapsack's capacity is 0\n            if i == 0 or j == 0:\n                dp[i][j] = 0\n            else:\n                pick = 0\n\n                if wt[i - 1] <= j:\n                    pick = val[i - 1] + dp[i - 1][j - wt[i - 1]]\n                # Don't pick the ith item\n                notPick = dp[i - 1][j]\n                dp[i][j] = max(pick, notPick)\n    return dp[n][W]\nif __name__ == \"__main__\":\n\n    val = [1, 2, 3]\n    wt = [4, 5, 1]\n    W = 4\n    print(knapsack(W, val, wt))\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <iostream>\n#include<vector>\nusing namespace std;\n//Driver Code Ends\nint knapsack(int W, vector<int> &val, vector<int> &wt) {\n    // Initializing dp vector\n    vector<int> dp(W + 1, 0);\n    // Taking first i elements\n    for (int i = 1; i <= wt.size(); i++) {\n        // Starting from back, so that we also have data of\n        // previous computation of i-1 items\n        for (int j = W; j >= wt[i - 1]; j--) {\n            dp[j] = max(dp[j], dp[j - wt[i - 1]] + val[i - 1]);\n        }\n    }\n    return dp[W];\n}\n//Driver Code Starts\nint main() {\n    vector<int> val = {1, 2, 3};\n    vector<int> wt = {4, 5, 1};\n    int W = 4;\n    cout << knapsack(W, val, wt) << endl;\n    return 0;\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <iostream>\n#include<vector>\nusing namespace std;\n\nint knapsack(int W, vector<int> &val, vector<int> &wt) {\n\n    vector<int> dp(W + 1, 0);\n\n    for (int i = 1; i <= wt.size(); i++) {\n\n\n        for (int j = W; j >= wt[i - 1]; j--) {\n            dp[j] = max(dp[j], dp[j - wt[i - 1]] + val[i - 1]);\n        }\n    }\n    return dp[W];\n}\n\nint main() {\n    vector<int> val = {1, 2, 3};\n    vector<int> wt = {4, 5, 1};\n    int W = 4;\n    cout << knapsack(W, val, wt) << endl;\n    return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "def knapsack(W, val, wt):\n    # Initializing dp list\n    dp = [0] * (W + 1)\n    # Taking first i elements\n    for i in range(1, len(wt) + 1):\n        # Starting from back, so that we also have data of\n        # previous computation of i-1 items\n        for j in range(W, wt[i - 1] - 1, -1):\n            dp[j] = max(dp[j], dp[j - wt[i - 1]] + val[i - 1])\n    return dp[W]\nif __name__ == \"__main__\":\n#Driver Code Starts\n    val = [1, 2, 3]\n    wt = [4, 5, 1]\n    W = 4\n    print(knapsack(W, val, wt))\n#Driver Code Ends",
    "code_without_comments": "def knapsack(W, val, wt):\n\n    dp = [0] * (W + 1)\n\n    for i in range(1, len(wt) + 1):\n\n\n        for j in range(W, wt[i - 1] - 1, -1):\n            dp[j] = max(dp[j], dp[j - wt[i - 1]] + val[i - 1])\n    return dp[W]\nif __name__ == \"__main__\":\n\n    val = [1, 2, 3]\n    wt = [4, 5, 1]\n    W = 4\n    print(knapsack(W, val, wt))\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "// A Naive recursive implementation of LCS problem\n#include <bits/stdc++.h>\nusing namespace std;\n// Returns length of LCS for s1[0..m-1], s2[0..n-1]\nint lcsRec(string &s1, string &s2,int m,int n) {\n    // Base case: If either string is empty, the length of LCS is 0\n    if (m == 0 || n == 0)\n        return 0;\n    // If the last characters of both substrings match\n    if (s1[m - 1] == s2[n - 1])\n        // Include this character in LCS and recur for remaining substrings\n        return 1 + lcsRec(s1, s2, m - 1, n - 1);\n    else\n        // If the last characters do not match\n        // Recur for two cases:\n        // 1. Exclude the last character of s1\n        // 2. Exclude the last character of s2\n        // Take the maximum of these two recursive calls\n        return max(lcsRec(s1, s2, m, n - 1), lcsRec(s1, s2, m - 1, n));\n}\nint lcs(string &s1,string &s2){\n    int m = s1.size(), n = s2.size();\n    return lcsRec(s1,s2,m,n);\n}\nint main() {\n    string s1 = \"AGGTAB\";\n    string s2 = \"GXTXAYB\";\n    int m = s1.size();\n    int n = s2.size();\n    cout << lcs(s1, s2) << endl;\n    return 0;\n}",
    "code_without_comments": "\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lcsRec(string &s1, string &s2,int m,int n) {\n\n    if (m == 0 || n == 0)\n        return 0;\n\n    if (s1[m - 1] == s2[n - 1])\n\n        return 1 + lcsRec(s1, s2, m - 1, n - 1);\n    else\n\n\n\n\n\n        return max(lcsRec(s1, s2, m, n - 1), lcsRec(s1, s2, m - 1, n));\n}\nint lcs(string &s1,string &s2){\n    int m = s1.size(), n = s2.size();\n    return lcsRec(s1,s2,m,n);\n}\nint main() {\n    string s1 = \"AGGTAB\";\n    string s2 = \"GXTXAYB\";\n    int m = s1.size();\n    int n = s2.size();\n    cout << lcs(s1, s2) << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/longest-common-subsequence-dp-4/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "// A Naive recursive implementation of LCS problem\n#include <stdio.h>\n#include <string.h>\nint max(int x, int y) {\n  \treturn x > y ? x : y;\n}\n// Returns length of LCS for s1[0..m-1], s2[0..n-1]\nint lcsRec(char s1[], char s2[], int m, int n) {\n    // Base case: If either string is empty, the length of LCS is 0\n    if (m == 0 || n == 0)\n        return 0;\n    // If the last characters of both substrings match\n    if (s1[m - 1] == s2[n - 1])\n        // Include this character in LCS and recur for remaining substrings\n        return 1 + lcsRec(s1, s2, m - 1, n - 1);\n    else\n        // If the last characters do not match\n        // Recur for two cases:\n        // 1. Exclude the last character of S1\n        // 2. Exclude the last character of S2\n        // Take the maximum of these two recursive calls\n        return max(lcsRec(s1, s2, m, n - 1), lcsRec(s1, s2, m - 1, n));\n}\nint lcs(char s1[],char s2[]){\n    int m = strlen(s1);\n    int n = strlen(s2);\n    return lcsRec(s1,s2,m,n);\n}\nint main() {\n    char s1[] = \"AGGTAB\";\n    char s2[] = \"GXTXAYB\";\n    printf(\"%d\\n\", lcs(s1, s2));\n    return 0;\n}",
    "code_without_comments": "\n#include <stdio.h>\n#include <string.h>\nint max(int x, int y) {\n  \treturn x > y ? x : y;\n}\n\nint lcsRec(char s1[], char s2[], int m, int n) {\n\n    if (m == 0 || n == 0)\n        return 0;\n\n    if (s1[m - 1] == s2[n - 1])\n\n        return 1 + lcsRec(s1, s2, m - 1, n - 1);\n    else\n\n\n\n\n\n        return max(lcsRec(s1, s2, m, n - 1), lcsRec(s1, s2, m - 1, n));\n}\nint lcs(char s1[],char s2[]){\n    int m = strlen(s1);\n    int n = strlen(s2);\n    return lcsRec(s1,s2,m,n);\n}\nint main() {\n    char s1[] = \"AGGTAB\";\n    char s2[] = \"GXTXAYB\";\n    printf(\"%d\\n\", lcs(s1, s2));\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/longest-common-subsequence-dp-4/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "# A Naive recursive implementation of LCS problem\n# Returns length of LCS for s1[0..m-1], s2[0..n-1]\ndef lcsRec(s1, s2, m, n):\n    # Base case: If either string is empty, the length of LCS is 0\n    if m == 0 or n == 0:\n        return 0\n    # If the last characters of both substrings match\n    if s1[m - 1] == s2[n - 1]:\n        # Include this character in LCS and recur for remaining substrings\n        return 1 + lcsRec(s1, s2, m - 1, n - 1)\n    else:\n        # If the last characters do not match\n        # Recur for two cases:\n        # 1. Exclude the last character of S1\n        # 2. Exclude the last character of S2\n        # Take the maximum of these two recursive calls\n        return max(lcsRec(s1, s2, m, n - 1), lcsRec(s1, s2, m - 1, n))\ndef lcs(s1,s2):\n    m = len(s1)\n    n = len(s2)\n    return lcsRec(s1,s2,m,n)\nif __name__ == \"__main__\":\n    s1 = \"AGGTAB\"\n    s2 = \"GXTXAYB\"\n    print(lcs(s1, s2))",
    "code_without_comments": "\n\ndef lcsRec(s1, s2, m, n):\n\n    if m == 0 or n == 0:\n        return 0\n\n    if s1[m - 1] == s2[n - 1]:\n\n        return 1 + lcsRec(s1, s2, m - 1, n - 1)\n    else:\n\n\n\n\n\n        return max(lcsRec(s1, s2, m, n - 1), lcsRec(s1, s2, m - 1, n))\ndef lcs(s1,s2):\n    m = len(s1)\n    n = len(s2)\n    return lcsRec(s1,s2,m,n)\nif __name__ == \"__main__\":\n    s1 = \"AGGTAB\"\n    s2 = \"GXTXAYB\"\n    print(lcs(s1, s2))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/longest-common-subsequence-dp-4/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "// C++ implementation of Top-Down DP\n// of LCS problem\n#include <bits/stdc++.h>\nusing namespace std;\n// Returns length of LCS for s1[0..m-1], s2[0..n-1]\nint lcsRec(string &s1, string &s2, int m, int n, vector<vector<int>> &memo) {\n    // Base Case\n    if (m == 0 || n == 0)\n        return 0;\n    // Already exists in the memo table\n    if (memo[m][n] != -1)\n        return memo[m][n];\n    // Match\n    if (s1[m - 1] == s2[n - 1])\n        return memo[m][n] = 1 + lcsRec(s1, s2, m - 1, n - 1, memo);\n    // Do not match\n    return memo[m][n] = max(lcsRec(s1, s2, m, n - 1, memo), lcsRec(s1, s2, m - 1, n, memo));\n}\nint lcs(string &s1,string &s2){\n    int m = s1.length();\n    int n = s2.length();\n    vector<vector<int>> memo(m + 1, vector<int>(n + 1, -1));\n    return lcsRec(s1, s2, m, n, memo);\n}\nint main() {\n    string s1 = \"AGGTAB\";\n    string s2 = \"GXTXAYB\";\n    cout << lcs(s1, s2) << endl;\n    return 0;\n}",
    "code_without_comments": "\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lcsRec(string &s1, string &s2, int m, int n, vector<vector<int>> &memo) {\n\n    if (m == 0 || n == 0)\n        return 0;\n\n    if (memo[m][n] != -1)\n        return memo[m][n];\n\n    if (s1[m - 1] == s2[n - 1])\n        return memo[m][n] = 1 + lcsRec(s1, s2, m - 1, n - 1, memo);\n\n    return memo[m][n] = max(lcsRec(s1, s2, m, n - 1, memo), lcsRec(s1, s2, m - 1, n, memo));\n}\nint lcs(string &s1,string &s2){\n    int m = s1.length();\n    int n = s2.length();\n    vector<vector<int>> memo(m + 1, vector<int>(n + 1, -1));\n    return lcsRec(s1, s2, m, n, memo);\n}\nint main() {\n    string s1 = \"AGGTAB\";\n    string s2 = \"GXTXAYB\";\n    cout << lcs(s1, s2) << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/longest-common-subsequence-dp-4/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "// C implementation of Top-Down DP\n// of LCS problem\n#include <stdio.h>\n#include <string.h>\n// Define a maximum size for the strings\n#define MAX 1000\n// Function to find the maximum of two integers\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n// Returns length of LCS for s1[0..m-1], s2[0..n-1]\nint lcsRec(const char *s1, const char *s2, int m, int n, int memo[MAX][MAX]) {\n    // Base Case\n    if (m == 0 || n == 0) {\n        return 0;\n    }\n    // Already exists in the memo table\n    if (memo[m][n] != -1) {\n        return memo[m][n];\n    }\n    // Match\n    if (s1[m - 1] == s2[n - 1]) {\n        return memo[m][n] = 1 + lcsRec(s1, s2, m - 1, n - 1, memo);\n    }\n    // Do not match\n    return memo[m][n] = max(lcsRec(s1, s2, m, n - 1, memo), lcsRec(s1, s2, m - 1, n, memo));\n}\nint lcs(char s1[],char s2[]){\n      int m = strlen(s1);\n    int n = strlen(s2);\n    // Create memo table with fixed size\n    int memo[MAX][MAX];\n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            // Initialize memo table with -1\n            memo[i][j] = -1;\n        }\n    }\n    return lcsRec(s1, s2, m, n, memo);\n}\nint main() {\n    const char *s1 = \"AGGTAB\";\n    const char *s2 = \"GXTXAYB\";\n    printf(\"%d\\n\", lcs(s1, s2));\n    return 0;\n}",
    "code_without_comments": "\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 1000\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nint lcsRec(const char *s1, const char *s2, int m, int n, int memo[MAX][MAX]) {\n\n    if (m == 0 || n == 0) {\n        return 0;\n    }\n\n    if (memo[m][n] != -1) {\n        return memo[m][n];\n    }\n\n    if (s1[m - 1] == s2[n - 1]) {\n        return memo[m][n] = 1 + lcsRec(s1, s2, m - 1, n - 1, memo);\n    }\n\n    return memo[m][n] = max(lcsRec(s1, s2, m, n - 1, memo), lcsRec(s1, s2, m - 1, n, memo));\n}\nint lcs(char s1[],char s2[]){\n      int m = strlen(s1);\n    int n = strlen(s2);\n\n    int memo[MAX][MAX];\n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n\n            memo[i][j] = -1;\n        }\n    }\n    return lcsRec(s1, s2, m, n, memo);\n}\nint main() {\n    const char *s1 = \"AGGTAB\";\n    const char *s2 = \"GXTXAYB\";\n    printf(\"%d\\n\", lcs(s1, s2));\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/longest-common-subsequence-dp-4/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "def lcsRec(s1, s2, m, n, memo):\n    # Base Case\n    if m == 0 or n == 0:\n        return 0\n    # Already exists in the memo table\n    if memo[m][n] != -1:\n        return memo[m][n]\n    # Match\n    if s1[m - 1] == s2[n - 1]:\n        memo[m][n] = 1 + lcsRec(s1, s2, m - 1, n - 1, memo)\n        return memo[m][n]\n    # Do not match\n    memo[m][n] = max(lcsRec(s1, s2, m, n - 1, memo),\n                     lcsRec(s1, s2, m - 1, n, memo))\n    return memo[m][n]\ndef lcs(s1, s2):\n    m = len(s1)\n    n = len(s2)\n    memo = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return lcsRec(s1,s2,m,n,memo)\nif __name__ == \"__main__\":\n    s1 = \"AGGTAB\"\n    s2 = \"GXTXAYB\"\n    print(lcs(s1, s2))",
    "code_without_comments": "def lcsRec(s1, s2, m, n, memo):\n\n    if m == 0 or n == 0:\n        return 0\n\n    if memo[m][n] != -1:\n        return memo[m][n]\n\n    if s1[m - 1] == s2[n - 1]:\n        memo[m][n] = 1 + lcsRec(s1, s2, m - 1, n - 1, memo)\n        return memo[m][n]\n\n    memo[m][n] = max(lcsRec(s1, s2, m, n - 1, memo),\n                     lcsRec(s1, s2, m - 1, n, memo))\n    return memo[m][n]\ndef lcs(s1, s2):\n    m = len(s1)\n    n = len(s2)\n    memo = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return lcsRec(s1,s2,m,n,memo)\nif __name__ == \"__main__\":\n    s1 = \"AGGTAB\"\n    s2 = \"GXTXAYB\"\n    print(lcs(s1, s2))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/longest-common-subsequence-dp-4/",
    "complexity_weight": 3.0
  }
]