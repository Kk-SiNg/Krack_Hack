[
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\n// Returns length of LCS for s1[0..m-1], s2[0..n-1]\nint lcs(string &s1, string &s2) {\n    int m = s1.size();\n    int n = s2.size();\n    // Initializing a matrix of size (m+1)*(n+1)\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n    // Building dp[m+1][n+1] in bottom-up fashion\n    for (int i = 1; i <= m; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            if (s1[i - 1] == s2[j - 1])\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            else\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    // dp[m][n] contains length of LCS for s1[0..m-1]\n    // and s2[0..n-1]\n    return dp[m][n];\n}\nint main() {\n    string s1 = \"AGGTAB\";\n    string s2 = \"GXTXAYB\";\n    cout << lcs(s1, s2) << endl;\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint lcs(string &s1, string &s2) {\n    int m = s1.size();\n    int n = s2.size();\n\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n\n    for (int i = 1; i <= m; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            if (s1[i - 1] == s2[j - 1])\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            else\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n\n\n    return dp[m][n];\n}\nint main() {\n    string s1 = \"AGGTAB\";\n    string s2 = \"GXTXAYB\";\n    cout << lcs(s1, s2) << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/longest-common-subsequence-dp-4/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nint max(int x, int y);\n// Function to find length of LCS for s1[0..m-1], s2[0..n-1]\nint lcs(const char *S1, const char *S2) {\n    int m = strlen(S1);\n    int n = strlen(S2);\n    // Initializing a matrix of size (m+1)*(n+1)\n    int dp[m + 1][n + 1];\n    // Building dp[m+1][n+1] in bottom-up fashion\n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i == 0 || j == 0)\n                dp[i][j] = 0;\n            else if (S1[i - 1] == S2[j - 1])\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            else\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    return dp[m][n];\n}\nint max(int x, int y) {\n    return (x > y) ? x : y;\n}\nint main() {\n    const char *S1 = \"AGGTAB\";\n    const char *S2 = \"GXTXAYB\";\n    printf(\"%d\\n\", lcs(S1, S2));\n    return 0;\n}",
    "code_without_comments": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nint max(int x, int y);\n\nint lcs(const char *S1, const char *S2) {\n    int m = strlen(S1);\n    int n = strlen(S2);\n\n    int dp[m + 1][n + 1];\n\n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i == 0 || j == 0)\n                dp[i][j] = 0;\n            else if (S1[i - 1] == S2[j - 1])\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            else\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    return dp[m][n];\n}\nint max(int x, int y) {\n    return (x > y) ? x : y;\n}\nint main() {\n    const char *S1 = \"AGGTAB\";\n    const char *S2 = \"GXTXAYB\";\n    printf(\"%d\\n\", lcs(S1, S2));\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/longest-common-subsequence-dp-4/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "def lcs(S1, S2):\n    m = len(S1)\n    n = len(S2)\n    # Initializing a matrix of size (m+1)*(n+1)\n    dp = [[0] * (n + 1) for x in range(m + 1)]\n    # Building dp[m+1][n+1] in bottom-up fashion\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if S1[i - 1] == S2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j],\n                               dp[i][j - 1])\n    # dp[m][n] contains length of LCS for S1[0..m-1]\n    # and S2[0..n-1]\n    return dp[m][n]\nif __name__ == \"__main__\":\n    S1 = \"AGGTAB\"\n    S2 = \"GXTXAYB\"\n    print(lcs(S1, S2))",
    "code_without_comments": "def lcs(S1, S2):\n    m = len(S1)\n    n = len(S2)\n\n    dp = [[0] * (n + 1) for x in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if S1[i - 1] == S2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j],\n                               dp[i][j - 1])\n\n\n    return dp[m][n]\nif __name__ == \"__main__\":\n    S1 = \"AGGTAB\"\n    S2 = \"GXTXAYB\"\n    print(lcs(S1, S2))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/longest-common-subsequence-dp-4/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "// Cpp program to find lis using recursion\n// in Exponential Time and Linear Space\n#include <bits/stdc++.h>\nusing namespace std;\n// Returns LIS of subarray ending with index i.\nint lisEndingAtIdx(vector<int>& arr, int idx) {\n    // Base case\n    if (idx == 0)\n        return 1;\n    // Consider all elements on the left of i,\n    // recursively compute LISs ending with\n    // them and consider the largest\n    int mx = 1;\n    for (int prev = 0; prev < idx; prev++)\n        if (arr[prev] < arr[idx])\n            mx = max(mx, lisEndingAtIdx(arr, prev) + 1);\n    return mx;\n}\nint lis(vector<int>& arr) {\n    int n = arr.size();\n    int res = 1;\n    for (int i = 1; i < n; i++)\n        res = max(res, lisEndingAtIdx(arr, i));\n    return res;\n}\nint main() {\n    vector<int> arr = { 10, 22, 9, 33, 21, 50, 41, 60 };\n    cout << lis(arr);\n    return 0;\n}",
    "code_without_comments": "\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lisEndingAtIdx(vector<int>& arr, int idx) {\n\n    if (idx == 0)\n        return 1;\n\n\n\n    int mx = 1;\n    for (int prev = 0; prev < idx; prev++)\n        if (arr[prev] < arr[idx])\n            mx = max(mx, lisEndingAtIdx(arr, prev) + 1);\n    return mx;\n}\nint lis(vector<int>& arr) {\n    int n = arr.size();\n    int res = 1;\n    for (int i = 1; i < n; i++)\n        res = max(res, lisEndingAtIdx(arr, i));\n    return res;\n}\nint main() {\n    vector<int> arr = { 10, 22, 9, 33, 21, 50, 41, 60 };\n    cout << lis(arr);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/longest-increasing-subsequence-dp-3/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "# Python program to find lis using recursion\n# in Exponential Time and Linear Space\ndef lisEndingAtIdx(arr, idx):\n    # Base case\n    if idx == 0:\n        return 1\n    # Consider all elements on the left of i,\n    # recursively compute LISs ending with\n    # them and consider the largest\n    mx = 1\n    for prev in range(idx):\n        if arr[prev] < arr[idx]:\n            mx = max(mx, lisEndingAtIdx(arr, prev) + 1)\n    return mx\ndef lis(arr):\n    n = len(arr)\n    res = 1\n    for idx in range(1, n):\n        res = max(res, lisEndingAtIdx(arr, idx))\n    return res\nif __name__ == \"__main__\":\n    arr = [10, 22, 9, 33, 21, 50, 41, 60]\n    print(lis(arr))",
    "code_without_comments": "\n\ndef lisEndingAtIdx(arr, idx):\n\n    if idx == 0:\n        return 1\n\n\n\n    mx = 1\n    for prev in range(idx):\n        if arr[prev] < arr[idx]:\n            mx = max(mx, lisEndingAtIdx(arr, prev) + 1)\n    return mx\ndef lis(arr):\n    n = len(arr)\n    res = 1\n    for idx in range(1, n):\n        res = max(res, lisEndingAtIdx(arr, idx))\n    return res\nif __name__ == \"__main__\":\n    arr = [10, 22, 9, 33, 21, 50, 41, 60]\n    print(lis(arr))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/longest-increasing-subsequence-dp-3/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "#include <bits/stdc++.h>\nusing namespace std;\nint lisEndingAtIdx(vector<int>& arr, int idx, vector<int>& memo) {\n    // Base case\n    if (idx == 0)\n        return 1;\n    // Check if the result is already computed\n    if (memo[idx] != -1)\n        return memo[idx];\n    // Consider all elements on left of i,\n    // recursively compute LISs ending with\n    // them and consider the largest\n    int mx = 1;\n    for (int prev = 0; prev < idx; prev++)\n        if (arr[prev] < arr[idx])\n            mx = max(mx, lisEndingAtIdx(arr, prev, memo) + 1);\n    // Store the result in the memo array\n    memo[idx] = mx;\n    return memo[idx];\n}\nint lis(vector<int>& arr) {\n    int n = arr.size();\n    vector<int> memo(n, -1);\n    int res = 1;\n    for (int i = 1; i < n; i++)\n        res = max(res, lisEndingAtIdx(arr, i, memo));\n    return res;\n}\nint main() {\n    vector<int> arr = { 10, 22, 9, 33, 21, 50, 41, 60 };\n    cout << lis(arr);\n    return 0;\n}",
    "code_without_comments": "#include <bits/stdc++.h>\nusing namespace std;\nint lisEndingAtIdx(vector<int>& arr, int idx, vector<int>& memo) {\n\n    if (idx == 0)\n        return 1;\n\n    if (memo[idx] != -1)\n        return memo[idx];\n\n\n\n    int mx = 1;\n    for (int prev = 0; prev < idx; prev++)\n        if (arr[prev] < arr[idx])\n            mx = max(mx, lisEndingAtIdx(arr, prev, memo) + 1);\n\n    memo[idx] = mx;\n    return memo[idx];\n}\nint lis(vector<int>& arr) {\n    int n = arr.size();\n    vector<int> memo(n, -1);\n    int res = 1;\n    for (int i = 1; i < n; i++)\n        res = max(res, lisEndingAtIdx(arr, i, memo));\n    return res;\n}\nint main() {\n    vector<int> arr = { 10, 22, 9, 33, 21, 50, 41, 60 };\n    cout << lis(arr);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/longest-increasing-subsequence-dp-3/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "def lisEndingAtIdx(arr, idx, memo):\n    # Base case\n    if idx == 0:\n        return 1\n    # Check if the result is already computed\n    if memo[idx] != -1:\n        return memo[idx]\n    # Consider all elements on left of i,\n    # recursively compute LISs ending with\n    # them and consider the largest\n    mx = 1\n    for prev in range(idx):\n        if arr[prev] < arr[idx]:\n            mx = max(mx, lisEndingAtIdx(arr, prev, memo) + 1)\n    # Store the result in the memo array\n    memo[idx] = mx\n    return memo[idx]\ndef lis(arr):\n    n = len(arr)\n    memo = [-1] * n\n    res = 1\n    for idx in range(1, n):\n        res = max(res, lisEndingAtIdx(arr, idx, memo))\n    return res\nif __name__ == \"__main__\":\n    arr = [10, 22, 9, 33, 21, 50, 41, 60]\n    print(lis(arr))",
    "code_without_comments": "def lisEndingAtIdx(arr, idx, memo):\n\n    if idx == 0:\n        return 1\n\n    if memo[idx] != -1:\n        return memo[idx]\n\n\n\n    mx = 1\n    for prev in range(idx):\n        if arr[prev] < arr[idx]:\n            mx = max(mx, lisEndingAtIdx(arr, prev, memo) + 1)\n\n    memo[idx] = mx\n    return memo[idx]\ndef lis(arr):\n    n = len(arr)\n    memo = [-1] * n\n    res = 1\n    for idx in range(1, n):\n        res = max(res, lisEndingAtIdx(arr, idx, memo))\n    return res\nif __name__ == \"__main__\":\n    arr = [10, 22, 9, 33, 21, 50, 41, 60]\n    print(lis(arr))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/longest-increasing-subsequence-dp-3/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "#include <bits/stdc++.h>\nusing namespace std;\n// lis() returns the length of the longest\n// increasing subsequence in arr of size n\nint lis(vector<int>& arr) {\n    int n = arr.size();\n    vector<int> lis(n, 1);\n    // Compute optimized LIS values in\n    // bottom-up manner\n    for (int i = 1; i < n; i++) {\n        for (int prev = 0; prev < i; prev++) {\n            if (arr[i] > arr[prev] && lis[i] < lis[prev] + 1) {\n                lis[i] = lis[prev] + 1;\n            }\n        }\n    }\n    // Return maximum value in lis\n    return *max_element(lis.begin(), lis.end());\n}\nint main() {\n    vector<int> arr = { 10, 22, 9, 33, 21, 50, 41, 60 };\n    cout << lis(arr) << endl;\n    return 0;\n}",
    "code_without_comments": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint lis(vector<int>& arr) {\n    int n = arr.size();\n    vector<int> lis(n, 1);\n\n\n    for (int i = 1; i < n; i++) {\n        for (int prev = 0; prev < i; prev++) {\n            if (arr[i] > arr[prev] && lis[i] < lis[prev] + 1) {\n                lis[i] = lis[prev] + 1;\n            }\n        }\n    }\n\n    return *max_element(lis.begin(), lis.end());\n}\nint main() {\n    vector<int> arr = { 10, 22, 9, 33, 21, 50, 41, 60 };\n    cout << lis(arr) << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/longest-increasing-subsequence-dp-3/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "# lis returns length of the longest\n# increasing subsequence in arr of size n\ndef lis(arr):\n    n = len(arr)\n    # Declare the list (array) for LIS and\n    # initialize LIS values for all indexes\n    lis = [1] * n\n    # Compute optimized LIS values in bottom\n    # -up manner\n    for i in range(1, n):\n        for prev in range(0, i):\n            if arr[i] > arr[prev]:\n                lis[i] = max(lis[i], lis[prev] + 1)\n    # Return the maximum of all LIS values\n    return max(lis)\nif __name__ == '__main__':\n    arr = [10, 22, 9, 33, 21, 50, 41, 60]\n    print(lis(arr))",
    "code_without_comments": "\n\ndef lis(arr):\n    n = len(arr)\n\n\n    lis = [1] * n\n\n\n    for i in range(1, n):\n        for prev in range(0, i):\n            if arr[i] > arr[prev]:\n                lis[i] = max(lis[i], lis[prev] + 1)\n\n    return max(lis)\nif __name__ == '__main__':\n    arr = [10, 22, 9, 33, 21, 50, 41, 60]\n    print(lis(arr))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/longest-increasing-subsequence-dp-3/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <iostream>\n#include<vector>\nusing namespace std;\n//Driver Code Ends\nint countRecur(vector<int>& coins, int n, int sum) {\n    // If sum is 0 then there is 1 solution\n    if (sum == 0) return 1;\n    if (sum < 0 || n == 0) return 0;\n    // count is sum of solutions\n    // (i)including coins[n-1] (ii) excluding coins[n-1]\n    return countRecur(coins, n, sum - coins[n - 1]) +\n            countRecur(coins, n - 1, sum);\n}\nint count(vector<int> &coins, int sum) {\n    return countRecur(coins, coins.size(), sum);\n}\n//Driver Code Starts\nint main() {\n    vector<int> coins = {1, 2, 3};\n    int sum = 5;\n    cout << count(coins, sum);\n    return 0;\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <iostream>\n#include<vector>\nusing namespace std;\n\nint countRecur(vector<int>& coins, int n, int sum) {\n\n    if (sum == 0) return 1;\n    if (sum < 0 || n == 0) return 0;\n\n\n    return countRecur(coins, n, sum - coins[n - 1]) +\n            countRecur(coins, n - 1, sum);\n}\nint count(vector<int> &coins, int sum) {\n    return countRecur(coins, coins.size(), sum);\n}\n\nint main() {\n    vector<int> coins = {1, 2, 3};\n    int sum = 5;\n    cout << count(coins, sum);\n    return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/coin-change-dp-7/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "def countRecur(coins, n, sum):\n    # If sum is 0 then there is 1 solution\n    if sum == 0:\n        return 1\n    if sum < 0 or n == 0:\n        return 0\n    # count is sum of solutions\n    # (i) including coins[n-1] (ii) excluding coins[n-1]\n    return countRecur(coins, n, sum - coins[n - 1]) + \\\n           countRecur(coins, n - 1, sum)\ndef count(coins, sum):\n    return countRecur(coins, len(coins), sum)\n#Driver Code Starts\nif __name__ == \"__main__\":\n    coins = [1, 2, 3]\n    sum = 5\n    print(count(coins, sum))\n#Driver Code Ends",
    "code_without_comments": "def countRecur(coins, n, sum):\n\n    if sum == 0:\n        return 1\n    if sum < 0 or n == 0:\n        return 0\n\n\n    return countRecur(coins, n, sum - coins[n - 1]) + \\\n           countRecur(coins, n - 1, sum)\ndef count(coins, sum):\n    return countRecur(coins, len(coins), sum)\n\nif __name__ == \"__main__\":\n    coins = [1, 2, 3]\n    sum = 5\n    print(count(coins, sum))\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/coin-change-dp-7/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <iostream>\n#include<vector>\nusing namespace std;\n//Driver Code Ends\nint countRecur(vector<int>& coins, int n, int sum,\n               vector<vector<int>> &dp) {\n    // If sum is 0 then there is 1 solution\n    if (sum == 0) return 1;\n    if (sum < 0 || n == 0) return 0;\n    // If the subproblem is previously calculated then\n    // simply return the result\n    if (dp[n-1][sum]!=-1) return dp[n-1][sum];\n    // count is sum of solutions (i)\n    // including coins[n-1] (ii) excluding coins[n-1]\n    return dp[n-1][sum] =\n        countRecur(coins, n, sum - coins[n-1], dp) +\n        countRecur(coins, n - 1, sum, dp);\n}\nint count(vector<int> &coins, int sum) {\n    vector<vector<int>> dp(coins.size(), vector<int>(sum+1, -1));\n    return countRecur(coins, coins.size(), sum, dp);\n}\n//Driver Code Starts\nint main() {\n    vector<int> coins = {1, 2, 3};\n    int sum = 5;\n    cout << count(coins, sum);\n    return 0;\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <iostream>\n#include<vector>\nusing namespace std;\n\nint countRecur(vector<int>& coins, int n, int sum,\n               vector<vector<int>> &dp) {\n\n    if (sum == 0) return 1;\n    if (sum < 0 || n == 0) return 0;\n\n\n    if (dp[n-1][sum]!=-1) return dp[n-1][sum];\n\n\n    return dp[n-1][sum] =\n        countRecur(coins, n, sum - coins[n-1], dp) +\n        countRecur(coins, n - 1, sum, dp);\n}\nint count(vector<int> &coins, int sum) {\n    vector<vector<int>> dp(coins.size(), vector<int>(sum+1, -1));\n    return countRecur(coins, coins.size(), sum, dp);\n}\n\nint main() {\n    vector<int> coins = {1, 2, 3};\n    int sum = 5;\n    cout << count(coins, sum);\n    return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/coin-change-dp-7/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "def countRecur(coins, n, sum, dp):\n    # If sum is 0 then there is 1 solution\n    if sum == 0:\n        return 1\n    if sum < 0 or n == 0:\n        return 0\n    # If the subproblem is previously calculated then\n    # simply return the result\n    if dp[n-1][sum] != -1:\n        return dp[n-1][sum]\n    # count is sum of solutions (i)\n    # including coins[n-1] (ii) excluding coins[n-1]\n    dp[n-1][sum] = (\n        countRecur(coins, n, sum - coins[n-1], dp) +\n        countRecur(coins, n - 1, sum, dp)\n    )\n    return dp[n-1][sum]\ndef count(coins, sum):\n    dp = [[-1 for _ in range(sum + 1)] for _ in range(len(coins))]\n    return countRecur(coins, len(coins), sum, dp)\n#Driver Code Starts\nif __name__ == \"__main__\":\n    coins = [1, 2, 3]\n    sum = 5\n    print(count(coins, sum))\n#Driver Code Ends",
    "code_without_comments": "def countRecur(coins, n, sum, dp):\n\n    if sum == 0:\n        return 1\n    if sum < 0 or n == 0:\n        return 0\n\n\n    if dp[n-1][sum] != -1:\n        return dp[n-1][sum]\n\n\n    dp[n-1][sum] = (\n        countRecur(coins, n, sum - coins[n-1], dp) +\n        countRecur(coins, n - 1, sum, dp)\n    )\n    return dp[n-1][sum]\ndef count(coins, sum):\n    dp = [[-1 for _ in range(sum + 1)] for _ in range(len(coins))]\n    return countRecur(coins, len(coins), sum, dp)\n\nif __name__ == \"__main__\":\n    coins = [1, 2, 3]\n    sum = 5\n    print(count(coins, sum))\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/coin-change-dp-7/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <iostream>\nusing namespace std;\n//Driver Code Ends\nint count(vector<int>& coins, int sum) {\n    int n = coins.size();\n    vector<vector<int> > dp(n + 1, vector<int>(sum + 1, 0));\n    dp[0][0] = 1;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= sum; j++) {\n            // Add the number of ways to make change without\n            // using the current coin,\n            dp[i][j] += dp[i - 1][j];\n            if ((j - coins[i - 1]) >= 0) {\n                // Add the number of ways to make change\n                // using the current coin\n                dp[i][j] += dp[i][j - coins[i - 1]];\n            }\n        }\n    }\n    return dp[n][sum];\n}\n//Driver Code Starts\nint main() {\n    vector<int> coins = {1, 2, 3};\n    int sum = 5;\n    cout << count(coins, sum);\n    return 0;\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <iostream>\nusing namespace std;\n\nint count(vector<int>& coins, int sum) {\n    int n = coins.size();\n    vector<vector<int> > dp(n + 1, vector<int>(sum + 1, 0));\n    dp[0][0] = 1;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= sum; j++) {\n\n\n            dp[i][j] += dp[i - 1][j];\n            if ((j - coins[i - 1]) >= 0) {\n\n\n                dp[i][j] += dp[i][j - coins[i - 1]];\n            }\n        }\n    }\n    return dp[n][sum];\n}\n\nint main() {\n    vector<int> coins = {1, 2, 3};\n    int sum = 5;\n    cout << count(coins, sum);\n    return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/coin-change-dp-7/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "def count(coins, sum):\n    n = len(coins)\n    # Initialize DP table\n    dp = [[0] * (sum + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(sum + 1):\n            # Add the number of ways to make change without\n            # using the current coin,\n            dp[i][j] += dp[i - 1][j]\n            if j - coins[i - 1] >= 0:\n                # Add the number of ways to make change\n                # using the current coin\n                dp[i][j] += dp[i][j - coins[i - 1]]\n    return dp[n][sum]\n#Driver Code Starts\nif __name__ == \"__main__\":\n    coins = [1, 2, 3]\n    sum = 5\n    print(count(coins, sum))\n#Driver Code Ends",
    "code_without_comments": "def count(coins, sum):\n    n = len(coins)\n\n    dp = [[0] * (sum + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(sum + 1):\n\n\n            dp[i][j] += dp[i - 1][j]\n            if j - coins[i - 1] >= 0:\n\n\n                dp[i][j] += dp[i][j - coins[i - 1]]\n    return dp[n][sum]\n\nif __name__ == \"__main__\":\n    coins = [1, 2, 3]\n    sum = 5\n    print(count(coins, sum))\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/coin-change-dp-7/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <iostream>\n#include<vector>\nusing namespace std;\n//Driver Code Ends\nint count(vector<int> &coins, int sum) {\n    int n = coins.size();\n    // dp[i] will be storing the number of solutions for\n    // value i.\n    vector<int> dp(sum + 1);\n    dp[0] = 1;\n    // Pick all coins one by one and update the table[]\n    // values after the index greater than or equal to the\n    // value of the picked coin\n    for (int i = 0; i < n; i++)\n        for (int j = coins[i]; j <= sum; j++)\n            dp[j] += dp[j - coins[i]];\n    return dp[sum];\n}\n//Driver Code Starts\nint main() {\n    vector<int> coins = {1, 2, 3};\n    int sum = 5;\n    cout << count(coins, sum);\n    return 0;\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <iostream>\n#include<vector>\nusing namespace std;\n\nint count(vector<int> &coins, int sum) {\n    int n = coins.size();\n\n\n    vector<int> dp(sum + 1);\n    dp[0] = 1;\n\n\n\n    for (int i = 0; i < n; i++)\n        for (int j = coins[i]; j <= sum; j++)\n            dp[j] += dp[j - coins[i]];\n    return dp[sum];\n}\n\nint main() {\n    vector<int> coins = {1, 2, 3};\n    int sum = 5;\n    cout << count(coins, sum);\n    return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/coin-change-dp-7/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "def count(coins, sum):\n    n = len(coins)\n    # dp[i] will be storing the number of solutions for\n    # value i.\n    dp = [0] * (sum + 1)\n    dp[0] = 1\n    # Pick all coins one by one and update the table[]\n    # values after the index greater than or equal to the\n    # value of the picked coin\n    for i in range(n):\n        for j in range(coins[i], sum + 1):\n            dp[j] += dp[j - coins[i]]\n    return dp[sum]\n//Driver Code Starts\nif __name__ == \"__main__\":\n    coins = [1, 2, 3]\n    sum = 5\n    print(count(coins, sum))\n//Driver Code Ends",
    "code_without_comments": "def count(coins, sum):\n    n = len(coins)\n\n\n    dp = [0] * (sum + 1)\n    dp[0] = 1\n\n\n\n    for i in range(n):\n        for j in range(coins[i], sum + 1):\n            dp[j] += dp[j - coins[i]]\n    return dp[sum]\n//Driver Code Starts\nif __name__ == \"__main__\":\n    coins = [1, 2, 3]\n    sum = 5\n    print(count(coins, sum))\n//Driver Code Ends",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/coin-change-dp-7/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "// C++ code to implement the\n// matrix chain multiplication using recursion\n#include <bits/stdc++.h>\nusing namespace std;\n// Matrix Ai has dimension arr[i-1] x arr[i]\nint minMultRec(vector<int> &arr, int i, int j)\n{\n    // If there is only one matrix\n    if (i + 1 == j)\n        return 0;\n    int res = INT_MAX;\n    // Place the first bracket at different\n    // positions or k and for every placed\n    // first bracket, recursively compute\n    // minimum cost for remaining brackets\n    // (or subproblems)\n    for (int k = i + 1; k < j; k++)\n    {\n        int curr = minMultRec(arr, i, k) + minMultRec(arr, k, j) + arr[i] * arr[k] * arr[j];\n        res = min(curr, res);\n    }\n    // Return minimum count\n    return res;\n}\nint matrixMultiplication(vector<int> &arr)\n{\n    int n = arr.size();\n    return minMultRec(arr, 0, n - 1);\n}\nint main()\n{\n    vector<int> arr = {2, 1, 3, 4};\n    cout << matrixMultiplication(arr);\n    return 0;\n}",
    "code_without_comments": "\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minMultRec(vector<int> &arr, int i, int j)\n{\n\n    if (i + 1 == j)\n        return 0;\n    int res = INT_MAX;\n\n\n\n\n\n    for (int k = i + 1; k < j; k++)\n    {\n        int curr = minMultRec(arr, i, k) + minMultRec(arr, k, j) + arr[i] * arr[k] * arr[j];\n        res = min(curr, res);\n    }\n\n    return res;\n}\nint matrixMultiplication(vector<int> &arr)\n{\n    int n = arr.size();\n    return minMultRec(arr, 0, n - 1);\n}\nint main()\n{\n    vector<int> arr = {2, 1, 3, 4};\n    cout << matrixMultiplication(arr);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/matrix-chain-multiplication-dp-8/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "# Python code to implement the\n# matrix chain multiplication using recursion\nimport sys\n# Matrix Ai has dimension arr[i-1] x arr[i]\ndef minMultRec(arr, i, j):\n    # If there is only one matrix\n    if i + 1 == j:\n        return 0\n    res = sys.maxsize\n    # Place the first bracket at different\n    # positions or k and for every placed\n    # first bracket, recursively compute\n    # minimum cost for remaining brackets\n    # (or subproblems)\n    for k in range(i + 1, j):\n        curr = minMultRec(arr, i, k) \\\n            + minMultRec(arr, k, j) \\\n            + arr[i] * arr[k] * arr[j]\n        res = min(curr, res)\n    # Return minimum count\n    return res\ndef matrixMultiplication(arr):\n    n = len(arr)\n    return minMultRec(arr, 0, n - 1)\nif __name__ == \"__main__\":\n    arr = [2, 1, 3, 4]\n    res = matrixMultiplication(arr)\n    print(res)",
    "code_without_comments": "\n\nimport sys\n\ndef minMultRec(arr, i, j):\n\n    if i + 1 == j:\n        return 0\n    res = sys.maxsize\n\n\n\n\n\n    for k in range(i + 1, j):\n        curr = minMultRec(arr, i, k) \\\n            + minMultRec(arr, k, j) \\\n            + arr[i] * arr[k] * arr[j]\n        res = min(curr, res)\n\n    return res\ndef matrixMultiplication(arr):\n    n = len(arr)\n    return minMultRec(arr, 0, n - 1)\nif __name__ == \"__main__\":\n    arr = [2, 1, 3, 4]\n    res = matrixMultiplication(arr)\n    print(res)",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/matrix-chain-multiplication-dp-8/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "// C++ code to implement the\n// matrix chain multiplication using memoization\n#include <bits/stdc++.h>\nusing namespace std;\nint minMultRec(vector<int> &arr, int i, int j, vector<vector<int>> &memo)\n{\n    // If there is only one matrix\n    if (i + 1 == j)\n        return 0;\n    // Check if the result is already\n    // computed\n    if (memo[i][j] != -1)\n        return memo[i][j];\n    int res = INT_MAX;\n    // Place the first bracket at different positions or k and\n    // for every placed first bracket, recursively compute\n    // minimum cost for remaining brackets (or subproblems)\n    for (int k = i + 1; k < j; k++)\n    {\n        int curr = minMultRec(arr, i, k, memo) + minMultRec(arr, k, j, memo) + arr[i] * arr[k] * arr[j];\n        res = min(curr, res);\n    }\n    // Store the result in memo table\n    memo[i][j] = res;\n    return res;\n}\nint matrixMultiplication(vector<int> &arr)\n{\n    int n = arr.size();\n    vector<vector<int>> memo(n, vector<int>(n, -1));\n    return minMultRec(arr, 0, n - 1, memo);\n}\nint main()\n{\n    vector<int> arr = {2, 1, 3, 4};\n    int res = matrixMultiplication(arr);\n    cout << res << endl;\n    return 0;\n}",
    "code_without_comments": "\n\n#include <bits/stdc++.h>\nusing namespace std;\nint minMultRec(vector<int> &arr, int i, int j, vector<vector<int>> &memo)\n{\n\n    if (i + 1 == j)\n        return 0;\n\n\n    if (memo[i][j] != -1)\n        return memo[i][j];\n    int res = INT_MAX;\n\n\n\n    for (int k = i + 1; k < j; k++)\n    {\n        int curr = minMultRec(arr, i, k, memo) + minMultRec(arr, k, j, memo) + arr[i] * arr[k] * arr[j];\n        res = min(curr, res);\n    }\n\n    memo[i][j] = res;\n    return res;\n}\nint matrixMultiplication(vector<int> &arr)\n{\n    int n = arr.size();\n    vector<vector<int>> memo(n, vector<int>(n, -1));\n    return minMultRec(arr, 0, n - 1, memo);\n}\nint main()\n{\n    vector<int> arr = {2, 1, 3, 4};\n    int res = matrixMultiplication(arr);\n    cout << res << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/matrix-chain-multiplication-dp-8/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "# Python code to implement the\n# matrix chain multiplication using memoization\nimport sys\n# Function to compute minimum multiplication\n# recursively\ndef minMultRec(arr, i, j, memo):\n    # If there is only one matrix\n    if i + 1 == j:\n        return 0\n    # Check if the result is already computed\n    if memo[i][j] != -1:\n        return memo[i][j]\n    res = sys.maxsize\n    # Place the first bracket at different positions or k\n    # and for every placed first bracket, recursively compute\n    # minimum cost for remaining brackets (or subproblems)\n    for k in range(i + 1, j):\n        curr = (minMultRec(arr, i, k, memo) +\n                minMultRec(arr, k, j, memo) +\n                arr[i] * arr[k] * arr[j])\n        res = min(res, curr)\n    # Store the result in memo table\n    memo[i][j] = res\n    return res\ndef matrixMultiplication(arr):\n    n = len(arr)\n    memo = [[-1 for _ in range(n)] for _ in range(n)]\n    return minMultRec(arr, 0, n - 1, memo)\nif __name__ == \"__main__\":\n    arr = [2, 1, 3, 4]\n    res = matrixMultiplication(arr)\n    print(res)",
    "code_without_comments": "\n\nimport sys\n\n\ndef minMultRec(arr, i, j, memo):\n\n    if i + 1 == j:\n        return 0\n\n    if memo[i][j] != -1:\n        return memo[i][j]\n    res = sys.maxsize\n\n\n\n    for k in range(i + 1, j):\n        curr = (minMultRec(arr, i, k, memo) +\n                minMultRec(arr, k, j, memo) +\n                arr[i] * arr[k] * arr[j])\n        res = min(res, curr)\n\n    memo[i][j] = res\n    return res\ndef matrixMultiplication(arr):\n    n = len(arr)\n    memo = [[-1 for _ in range(n)] for _ in range(n)]\n    return minMultRec(arr, 0, n - 1, memo)\nif __name__ == \"__main__\":\n    arr = [2, 1, 3, 4]\n    res = matrixMultiplication(arr)\n    print(res)",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/matrix-chain-multiplication-dp-8/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "// C++ code to implement the\n// matrix chain multiplication using tabulation\n#include <bits/stdc++.h>\nusing namespace std;\nint matrixMultiplication(vector<int> &arr)\n{\n    int n = arr.size();\n    // Create a 2D DP array to store the minimum\n    // multiplication costs\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n    // Fill the DP array.\n    // Here, len is the chain length\n    for (int len = 2; len < n; len++)\n    {\n        for (int i = 0; i < n - len; i++)\n        {\n            int j = i + len;\n            dp[i][j] = INT_MAX;\n            for (int k = i + 1; k < j; k++)\n            {\n                int cost = dp[i][k] + dp[k][j] + arr[i] * arr[k] * arr[j];\n                dp[i][j] = min(dp[i][j], cost);\n            }\n        }\n    }\n    // The minimum cost is stored in dp[0][n-1]\n    return dp[0][n - 1];\n}\nint main()\n{\n    vector<int> arr = {2, 1, 3, 4};\n    cout << matrixMultiplication(arr);\n    return 0;\n}",
    "code_without_comments": "\n\n#include <bits/stdc++.h>\nusing namespace std;\nint matrixMultiplication(vector<int> &arr)\n{\n    int n = arr.size();\n\n\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n\n\n    for (int len = 2; len < n; len++)\n    {\n        for (int i = 0; i < n - len; i++)\n        {\n            int j = i + len;\n            dp[i][j] = INT_MAX;\n            for (int k = i + 1; k < j; k++)\n            {\n                int cost = dp[i][k] + dp[k][j] + arr[i] * arr[k] * arr[j];\n                dp[i][j] = min(dp[i][j], cost);\n            }\n        }\n    }\n\n    return dp[0][n - 1];\n}\nint main()\n{\n    vector<int> arr = {2, 1, 3, 4};\n    cout << matrixMultiplication(arr);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/matrix-chain-multiplication-dp-8/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "# Python code to implement the\n# matrix chain multiplication using tabulation\ndef matrixMultiplication(arr):\n    n = len(arr)\n    # Create a 2D DP array to store min\n    # multiplication costs\n    dp = [[0] * n for _ in range(n)]\n    # Fill the DP array\n    # length is the chain length\n    for length in range(2, n):\n        for i in range(n - length):\n            j = i + length\n            dp[i][j] = float('inf')\n            for k in range(i + 1, j):\n                cost = dp[i][k] + dp[k][j] + arr[i] * arr[k] * arr[j]\n                dp[i][j] = min(dp[i][j], cost)\n    # Minimum cost is in dp[0][n-1]\n    return dp[0][n - 1]\narr = [2, 1, 3, 4]\nprint(matrixMultiplication(arr))",
    "code_without_comments": "\n\ndef matrixMultiplication(arr):\n    n = len(arr)\n\n\n    dp = [[0] * n for _ in range(n)]\n\n\n    for length in range(2, n):\n        for i in range(n - length):\n            j = i + length\n            dp[i][j] = float('inf')\n            for k in range(i + 1, j):\n                cost = dp[i][k] + dp[k][j] + arr[i] * arr[k] * arr[j]\n                dp[i][j] = min(dp[i][j], cost)\n\n    return dp[0][n - 1]\narr = [2, 1, 3, 4]\nprint(matrixMultiplication(arr))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/matrix-chain-multiplication-dp-8/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "// A Naive recursive C++ program to find minimum number\n// of operations to convert s1 to s2\n#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n// Recursive function to find number of operations\n// needed to convert s1 into s2.\nint editDistRec(string& s1, string& s2, int m, int n) {\n    // If first string is empty, the only option is to\n    // insert all characters of second string into first\n    if (m == 0) return n;\n    // If second string is empty, the only option is to\n    // remove all characters of first string\n    if (n == 0) return m;\n    // If last characters of two strings are same, nothing\n    // much to do. Get the count for\n    // remaining strings.\n    if (s1[m - 1] == s2[n - 1])\n      return editDistRec(s1, s2, m - 1, n - 1);\n    // If last characters are not same, consider all three\n    // operations on last character of first string,\n    // recursively compute minimum cost for all three\n    // operations and take minimum of three values.\n    return 1 + min({editDistRec(s1, s2, m, n - 1),\n                    editDistRec(s1, s2, m - 1, n),\n                    editDistRec(s1, s2, m - 1, n - 1)});\n}\n// Wrapper function to initiate the recursive calculation\nint editDistance(string& s1, string& s2) {\n    return editDistRec(s1, s2, s1.length(), s2.length());\n}\nint main() {\n    string s1 = \"abcd\";\n    string s2 = \"bcfe\";\n    cout << editDistance(s1, s2);\n    return 0;\n}",
    "code_without_comments": "\n\n#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n\nint editDistRec(string& s1, string& s2, int m, int n) {\n\n\n    if (m == 0) return n;\n\n\n    if (n == 0) return m;\n\n\n\n    if (s1[m - 1] == s2[n - 1])\n      return editDistRec(s1, s2, m - 1, n - 1);\n\n\n\n\n    return 1 + min({editDistRec(s1, s2, m, n - 1),\n                    editDistRec(s1, s2, m - 1, n),\n                    editDistRec(s1, s2, m - 1, n - 1)});\n}\n\nint editDistance(string& s1, string& s2) {\n    return editDistRec(s1, s2, s1.length(), s2.length());\n}\nint main() {\n    string s1 = \"abcd\";\n    string s2 = \"bcfe\";\n    cout << editDistance(s1, s2);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/edit-distance-dp-5/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "#include <stdio.h>\n#include <string.h>\n// Function to find minimum of three numbers\nint min(int x, int y, int z) {\n    return (x < y) ? (x < z ? x : z) : (y < z ? y : z);\n}\n// A Naive recursive C program to find minimum number\n// of operations to convert s1 to s2\nint editDistRec(char *s1, char *s2, int m, int n) {\n    // If first string is empty, the only option is to\n    // insert all characters of second string into first\n    if (m == 0) return n;\n    // If second string is empty, the only option is to\n    // remove all characters of first string\n    if (n == 0) return m;\n    // If last characters of two strings are same, nothing\n    // much to do. Get the count for\n    // remaining strings.\n    if (s1[m - 1] == s2[n - 1])\n        return editDistRec(s1, s2, m - 1, n - 1);\n    // If last characters are not same, consider all three\n    // operations on last character of first string,\n    // recursively compute minimum cost for all three\n    // operations and take minimum of three values.\n    return 1 + min(editDistRec(s1, s2, m, n - 1),    // Insert\n                   editDistRec(s1, s2, m - 1, n),    // Remove\n                   editDistRec(s1, s2, m - 1, n - 1) // Replace\n                   );\n}\nint main() {\n    char s1[] = \"abcd\";\n    char s2[] = \"bcfe\";\n    printf(\"%d\\n\", editDistRec(s1, s2, strlen(s1), strlen(s2)));\n    return 0;\n}",
    "code_without_comments": "#include <stdio.h>\n#include <string.h>\n\nint min(int x, int y, int z) {\n    return (x < y) ? (x < z ? x : z) : (y < z ? y : z);\n}\n\n\nint editDistRec(char *s1, char *s2, int m, int n) {\n\n\n    if (m == 0) return n;\n\n\n    if (n == 0) return m;\n\n\n\n    if (s1[m - 1] == s2[n - 1])\n        return editDistRec(s1, s2, m - 1, n - 1);\n\n\n\n\n    return 1 + min(editDistRec(s1, s2, m, n - 1),\n                   editDistRec(s1, s2, m - 1, n),\n                   editDistRec(s1, s2, m - 1, n - 1)\n                   );\n}\nint main() {\n    char s1[] = \"abcd\";\n    char s2[] = \"bcfe\";\n    printf(\"%d\\n\", editDistRec(s1, s2, strlen(s1), strlen(s2)));\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/edit-distance-dp-5/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "# A Naive recursive Python program to find minimum number\n# of operations to convert s1 to s2.\n# Recursive function to find number of operations\n# needed to convert s1 into s2.\ndef editDistRec(s1, s2, m, n):\n    # If first string is empty, the only option is to\n    # insert all characters of second string into first\n    if m == 0:\n        return n\n    # If second string is empty, the only option is to\n    # remove all characters of first string\n    if n == 0:\n        return m\n    # If last characters of two strings are same, nothing\n    # much to do. Get the count for\n    # remaining strings.\n    if s1[m - 1] == s2[n - 1]:\n        return editDistRec(s1, s2, m - 1, n - 1)\n    # If last characters are not same, consider all three\n    # operations on last character of first string,\n    # recursively compute minimum cost for all three\n    # operations and take minimum of three values.\n    return 1 + min(editDistRec(s1, s2, m, n - 1),\n                   editDistRec(s1, s2, m - 1, n),\n                   editDistRec(s1, s2, m - 1, n - 1))\n# Wrapper function to initiate\n# the recursive calculation\ndef editDistance(s1, s2):\n    return editDistRec(s1, s2, len(s1), len(s2))\nif __name__ == \"__main__\":\n    s1 = \"abcd\"\n    s2 = \"bcfe\"\n    print(editDistance(s1, s2))",
    "code_without_comments": "\n\n\n\ndef editDistRec(s1, s2, m, n):\n\n\n    if m == 0:\n        return n\n\n\n    if n == 0:\n        return m\n\n\n\n    if s1[m - 1] == s2[n - 1]:\n        return editDistRec(s1, s2, m - 1, n - 1)\n\n\n\n\n    return 1 + min(editDistRec(s1, s2, m, n - 1),\n                   editDistRec(s1, s2, m - 1, n),\n                   editDistRec(s1, s2, m - 1, n - 1))\n\n\ndef editDistance(s1, s2):\n    return editDistRec(s1, s2, len(s1), len(s2))\nif __name__ == \"__main__\":\n    s1 = \"abcd\"\n    s2 = \"bcfe\"\n    print(editDistance(s1, s2))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/edit-distance-dp-5/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "// C++ program to find minimum number\n// of operations to convert s1 to s2\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n// Recursive function to find number of operations\n// needed to convert s1 into s2.\nint editDistRec(string& s1, string& s2, int m, int n, vector<vector<int>> &memo) {\n    // If first string is empty, the only option is to\n    // insert all characters of second string into first\n    if (m == 0) return n;\n    // If second string is empty, the only option is to\n    // remove all characters of first string\n    if (n == 0) return m;\n    // If value is memoized\n    if (memo[m][n]!=-1) return memo[m][n];\n    // If last characters of two strings are same, nothing\n    // much to do. Get the count for\n    // remaining strings.\n    if (s1[m - 1] == s2[n - 1])\n      return memo[m][n] = editDistRec(s1, s2, m - 1, n - 1, memo);\n    // If last characters are not same, consider all three\n    // operations on last character of first string,\n    // recursively compute minimum cost for all three\n    // operations and take minimum of three values.\n    return memo[m][n] =\n            1 + min({editDistRec(s1, s2, m, n - 1, memo),\n                    editDistRec(s1, s2, m - 1, n, memo),\n                    editDistRec(s1, s2, m - 1, n - 1, memo)});\n}\n// Wrapper function to initiate the recursive calculation\nint editDistance(string& s1, string& s2) {\n    int m = s1.length(), n = s2.length();\n    vector<vector<int>> memo(m+1, vector<int>(n+1, -1));\n    return editDistRec(s1, s2, m, n, memo);\n}\nint main() {\n    string s1 = \"abcd\";\n    string s2 = \"bcfe\";\n    cout << editDistance(s1, s2);\n    return 0;\n}",
    "code_without_comments": "\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n\nint editDistRec(string& s1, string& s2, int m, int n, vector<vector<int>> &memo) {\n\n\n    if (m == 0) return n;\n\n\n    if (n == 0) return m;\n\n    if (memo[m][n]!=-1) return memo[m][n];\n\n\n\n    if (s1[m - 1] == s2[n - 1])\n      return memo[m][n] = editDistRec(s1, s2, m - 1, n - 1, memo);\n\n\n\n\n    return memo[m][n] =\n            1 + min({editDistRec(s1, s2, m, n - 1, memo),\n                    editDistRec(s1, s2, m - 1, n, memo),\n                    editDistRec(s1, s2, m - 1, n - 1, memo)});\n}\n\nint editDistance(string& s1, string& s2) {\n    int m = s1.length(), n = s2.length();\n    vector<vector<int>> memo(m+1, vector<int>(n+1, -1));\n    return editDistRec(s1, s2, m, n, memo);\n}\nint main() {\n    string s1 = \"abcd\";\n    string s2 = \"bcfe\";\n    cout << editDistance(s1, s2);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/edit-distance-dp-5/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "# Python program to find minimum number\n# of operations to convert s1 to s2\n# Recursive function to find number of operations\n# needed to convert s1 into s2.\ndef editDistRec(s1, s2, m, n, memo):\n    # If first string is empty, the only option is to\n    # insert all characters of second string into first\n    if m == 0:\n        return n\n    # If second string is empty, the only option is to\n    # remove all characters of first string\n    if n == 0:\n        return m\n    # If value is memoized\n    if memo[m][n] != -1:\n        return memo[m][n]\n    # If last characters of two strings are same, nothing\n    # much to do. Get the count for\n    # remaining strings.\n    if s1[m - 1] == s2[n - 1]:\n        memo[m][n] = editDistRec(s1, s2, m - 1, n - 1, memo)\n        return memo[m][n]\n    # If last characters are not same, consider all three\n    # operations on last character of first string,\n    # recursively compute minimum cost for all three\n    # operations and take minimum of three values.\n    memo[m][n] = 1 + min(\n        editDistRec(s1, s2, m, n - 1, memo),\n        editDistRec(s1, s2, m - 1, n, memo),\n        editDistRec(s1, s2, m - 1, n - 1, memo)\n    )\n    return memo[m][n]\n# Wrapper function to initiate the recursive calculation\ndef editDistance(s1, s2):\n    m, n = len(s1), len(s2)\n    memo = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return editDistRec(s1, s2, m, n, memo)\nif __name__ == \"__main__\":\n    s1 = \"abcd\"\n    s2 = \"bcfe\"\n    print(editDistance(s1, s2))",
    "code_without_comments": "\n\n\n\ndef editDistRec(s1, s2, m, n, memo):\n\n\n    if m == 0:\n        return n\n\n\n    if n == 0:\n        return m\n\n    if memo[m][n] != -1:\n        return memo[m][n]\n\n\n\n    if s1[m - 1] == s2[n - 1]:\n        memo[m][n] = editDistRec(s1, s2, m - 1, n - 1, memo)\n        return memo[m][n]\n\n\n\n\n    memo[m][n] = 1 + min(\n        editDistRec(s1, s2, m, n - 1, memo),\n        editDistRec(s1, s2, m - 1, n, memo),\n        editDistRec(s1, s2, m - 1, n - 1, memo)\n    )\n    return memo[m][n]\n\ndef editDistance(s1, s2):\n    m, n = len(s1), len(s2)\n    memo = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return editDistRec(s1, s2, m, n, memo)\nif __name__ == \"__main__\":\n    s1 = \"abcd\"\n    s2 = \"bcfe\"\n    print(editDistance(s1, s2))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/edit-distance-dp-5/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "// C++ program to find minimum number\n// of operations to convert s1 to s2\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint editDistance(string &s1, string &s2) {\n    int m = s1.length();\n    int n = s2.length();\n    // Create a table to store results of subproblems\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n    // Fill the known entries in dp[][]\n    // If one string is empty, then answer\n    // is length of the other string\n    for (int i = 0; i <= m; i++)\n        dp[i][0] = i;\n    for (int j = 0; j <= n; j++)\n        dp[0][j] = j;\n    // Fill the rest of dp[][]\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (s1[i - 1] == s2[j - 1])\n                dp[i][j] = dp[i - 1][j - 1];\n            else\n                dp[i][j] = 1 + min({dp[i][j - 1],\n                                 dp[i - 1][j],\n                                 dp[i - 1][j - 1]});\n        }\n    }\n    return dp[m][n];\n}\nint main() {\n    string s1 = \"abcd\";\n    string s2 = \"bcfe\";\n    cout << editDistance(s1, s2);\n    return 0;\n}",
    "code_without_comments": "\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint editDistance(string &s1, string &s2) {\n    int m = s1.length();\n    int n = s2.length();\n\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n\n\n\n    for (int i = 0; i <= m; i++)\n        dp[i][0] = i;\n    for (int j = 0; j <= n; j++)\n        dp[0][j] = j;\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (s1[i - 1] == s2[j - 1])\n                dp[i][j] = dp[i - 1][j - 1];\n            else\n                dp[i][j] = 1 + min({dp[i][j - 1],\n                                 dp[i - 1][j],\n                                 dp[i - 1][j - 1]});\n        }\n    }\n    return dp[m][n];\n}\nint main() {\n    string s1 = \"abcd\";\n    string s2 = \"bcfe\";\n    cout << editDistance(s1, s2);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/edit-distance-dp-5/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "# Python program to find minimum number\n# of operations to convert s1 to s2\n# Function to find the minimum number\n# of operations to convert s1 to s2\ndef editDistance(s1, s2):\n    m = len(s1)\n    n = len(s2)\n    # Create a table to store results of subproblems\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    # Fill the known entries in dp[][]\n    # If one string is empty, then answer\n    # is length of the other string\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n    # Fill the rest of dp[][]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1])\n    return dp[m][n]\nif __name__ == \"__main__\":\n    s1 = \"abcd\"\n    s2 = \"bcfe\"\n    print(editDistance(s1, s2))",
    "code_without_comments": "\n\n\n\ndef editDistance(s1, s2):\n    m = len(s1)\n    n = len(s2)\n\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n\n\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1])\n    return dp[m][n]\nif __name__ == \"__main__\":\n    s1 = \"abcd\"\n    s2 = \"bcfe\"\n    print(editDistance(s1, s2))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/edit-distance-dp-5/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "// C++ program to find minimum number\n// of operations to convert s1 to s2\n#include <bits/stdc++.h>\nusing namespace std;\nint editDistance(string &s1, string &s2) {\n    int m = s1.size();\n    int n = s2.size();\n    // prev stores results for (i-1) th row\n    // and curr for i-th row\n    vector<int> prev(n + 1, 0), curr(n + 1, 0);\n    // For 0-th row\n    for (int j = 0; j <= n; j++)\n        prev[j] = j;\n    // Rest of the rows\n    for (int i = 1; i <= m; i++)\n    {\n        curr[0] = i;  // j = 0\n        for (int j = 1; j <= n; j++)\n        {\n            if (s1[i - 1] == s2[j - 1])\n                curr[j] = prev[j - 1];\n            else\n                curr[j] = 1 + min({curr[j - 1], prev[j], prev[j - 1]});\n        }\n        prev = curr;\n    }\n    return prev[n];\n}\nint main() {\n    string s1 = \"abcd\";\n    string s2 = \"bcfe\";\n    cout << editDistance(s1, s2);\n    return 0;\n}",
    "code_without_comments": "\n\n#include <bits/stdc++.h>\nusing namespace std;\nint editDistance(string &s1, string &s2) {\n    int m = s1.size();\n    int n = s2.size();\n\n\n    vector<int> prev(n + 1, 0), curr(n + 1, 0);\n\n    for (int j = 0; j <= n; j++)\n        prev[j] = j;\n\n    for (int i = 1; i <= m; i++)\n    {\n        curr[0] = i;\n        for (int j = 1; j <= n; j++)\n        {\n            if (s1[i - 1] == s2[j - 1])\n                curr[j] = prev[j - 1];\n            else\n                curr[j] = 1 + min({curr[j - 1], prev[j], prev[j - 1]});\n        }\n        prev = curr;\n    }\n    return prev[n];\n}\nint main() {\n    string s1 = \"abcd\";\n    string s2 = \"bcfe\";\n    cout << editDistance(s1, s2);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/edit-distance-dp-5/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "# Python program to find minimum number\n# of operations to convert s1 to s2\n# Function to find the minimum number\n# of operations to convert s1 to s2\ndef editDistance(s1, s2):\n    m = len(s1)\n    n = len(s2)\n    # prev stores results for (i-1) th row\n    # and curr for i-th row\n    prev = [0] * (n + 1)\n    curr = [0] * (n + 1)\n    # For 0-th row\n    for j in range(n + 1):\n        prev[j] = j\n    # Rest of the rows\n    for i in range(1, m + 1):\n        curr[0] = i  # j = 0\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                curr[j] = prev[j - 1]\n            else:\n                curr[j] = 1 + min(curr[j - 1], prev[j], prev[j - 1])\n        prev = curr[:]\n    return prev[n]\nif __name__ == \"__main__\":\n    s1 = \"abcd\"\n    s2 = \"bcfe\"\n    print(editDistance(s1, s2))",
    "code_without_comments": "\n\n\n\ndef editDistance(s1, s2):\n    m = len(s1)\n    n = len(s2)\n\n\n    prev = [0] * (n + 1)\n    curr = [0] * (n + 1)\n\n    for j in range(n + 1):\n        prev[j] = j\n\n    for i in range(1, m + 1):\n        curr[0] = i\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                curr[j] = prev[j - 1]\n            else:\n                curr[j] = 1 + min(curr[j - 1], prev[j], prev[j - 1])\n        prev = curr[:]\n    return prev[n]\nif __name__ == \"__main__\":\n    s1 = \"abcd\"\n    s2 = \"bcfe\"\n    print(editDistance(s1, s2))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/edit-distance-dp-5/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "// C++ program to find minimum number\n// of operations to convert s1 to s2\n#include <bits/stdc++.h>\nusing namespace std;\nint editDistance(string &s1, string &s2) {\n    int m = s1.size();\n    int n = s2.size();\n    // Stores dp[i-1][j-1]\n    int prev;\n    vector<int> curr(n + 1, 0);\n    for (int j = 0; j <= n; j++)\n        curr[j] = j;\n    for (int i = 1; i <= m; i++) {\n        prev = curr[0];\n        curr[0] = i;\n        for (int j = 1; j <= n; j++) {\n            int temp = curr[j];\n            if (s1[i - 1] == s2[j - 1])\n                curr[j] = prev;\n            else\n                curr[j] = 1 + min({curr[j - 1], prev, curr[j]});\n            prev = temp;\n        }\n    }\n    return curr[n];\n}\nint main() {\n    string s1 = \"abcd\";\n    string s2 = \"bcfe\";\n    cout << editDistance(s1, s2);\n    return 0;\n}",
    "code_without_comments": "\n\n#include <bits/stdc++.h>\nusing namespace std;\nint editDistance(string &s1, string &s2) {\n    int m = s1.size();\n    int n = s2.size();\n\n    int prev;\n    vector<int> curr(n + 1, 0);\n    for (int j = 0; j <= n; j++)\n        curr[j] = j;\n    for (int i = 1; i <= m; i++) {\n        prev = curr[0];\n        curr[0] = i;\n        for (int j = 1; j <= n; j++) {\n            int temp = curr[j];\n            if (s1[i - 1] == s2[j - 1])\n                curr[j] = prev;\n            else\n                curr[j] = 1 + min({curr[j - 1], prev, curr[j]});\n            prev = temp;\n        }\n    }\n    return curr[n];\n}\nint main() {\n    string s1 = \"abcd\";\n    string s2 = \"bcfe\";\n    cout << editDistance(s1, s2);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/edit-distance-dp-5/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "# Python program to find minimum number\n# of operations to convert s1 to s2\n# Function to find the minimum number\n# of operations to convert s1 to s2\ndef editDistance(s1, s2):\n    m = len(s1)\n    n = len(s2)\n    # Stores dp[i-1][j-1]\n    prev = 0\n    curr = [0] * (n + 1)\n    for j in range(n + 1):\n        curr[j] = j\n    for i in range(1, m + 1):\n        prev = curr[0]\n        curr[0] = i\n        for j in range(1, n + 1):\n            temp = curr[j]\n            if s1[i - 1] == s2[j - 1]:\n                curr[j] = prev\n            else:\n                curr[j] = 1 + min(curr[j - 1], prev, curr[j])\n            prev = temp\n    return curr[n]\nif __name__ == \"__main__\":\n    s1 = \"abcd\"\n    s2 = \"bcfe\"\n    print(editDistance(s1, s2))",
    "code_without_comments": "\n\n\n\ndef editDistance(s1, s2):\n    m = len(s1)\n    n = len(s2)\n\n    prev = 0\n    curr = [0] * (n + 1)\n    for j in range(n + 1):\n        curr[j] = j\n    for i in range(1, m + 1):\n        prev = curr[0]\n        curr[0] = i\n        for j in range(1, n + 1):\n            temp = curr[j]\n            if s1[i - 1] == s2[j - 1]:\n                curr[j] = prev\n            else:\n                curr[j] = 1 + min(curr[j - 1], prev, curr[j])\n            prev = temp\n    return curr[n]\nif __name__ == \"__main__\":\n    s1 = \"abcd\"\n    s2 = \"bcfe\"\n    print(editDistance(s1, s2))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/edit-distance-dp-5/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "//C++ implementation for subset sum\n// problem using recursion\n#include <bits/stdc++.h>\nusing namespace std;\n// Function to check if there is a subset\n// with the given sum using recursion\nbool isSubsetSumRec(vector<int>& arr, int n, int sum) {\n    // Base Cases\n    if (sum == 0)\n        return true;\n    if (n == 0)\n        return false;\n    // If last element is greater than sum,\n    // then ignore it\n    if (arr[n - 1] > sum)\n        return isSubsetSumRec(arr, n - 1, sum);\n    // Check if sum can be obtained by including\n  \t// or excluding the last element\n    return isSubsetSumRec(arr, n - 1, sum)\n      \t\t|| isSubsetSumRec(arr, n - 1, sum - arr[n - 1]);\n}\nbool isSubsetSum(vector<int>& arr, int sum) {\n    return isSubsetSumRec(arr, arr.size(), sum);\n}\nint main() {\n    vector<int> arr = {3, 34, 4, 12, 5, 2};\n    int sum = 9;\n    if (isSubsetSum(arr, sum))\n        cout << \"True\" << endl;\n    else\n        cout << \"False\" << endl;\n    return 0;\n}",
    "code_without_comments": "\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n\nbool isSubsetSumRec(vector<int>& arr, int n, int sum) {\n\n    if (sum == 0)\n        return true;\n    if (n == 0)\n        return false;\n\n\n    if (arr[n - 1] > sum)\n        return isSubsetSumRec(arr, n - 1, sum);\n\n\n    return isSubsetSumRec(arr, n - 1, sum)\n      \t\t|| isSubsetSumRec(arr, n - 1, sum - arr[n - 1]);\n}\nbool isSubsetSum(vector<int>& arr, int sum) {\n    return isSubsetSumRec(arr, arr.size(), sum);\n}\nint main() {\n    vector<int> arr = {3, 34, 4, 12, 5, 2};\n    int sum = 9;\n    if (isSubsetSum(arr, sum))\n        cout << \"True\" << endl;\n    else\n        cout << \"False\" << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "//C implementation for subset sum\n// problem using recursion\n#include <stdio.h>\n// Function to check if there is a subset\n// with the given sum using recursion\nint isSubsetSumRec(int arr[], int n, int sum) {\n    // Base Cases\n    if (sum == 0) {\n        return 1;\n    }\n    if (n == 0) {\n        return 0;\n    }\n    // If last element is greater than sum, ignore it\n    if (arr[n - 1] > sum) {\n        return isSubsetSumRec(arr, n - 1, sum);\n    }\n    // Check if sum can be obtained by including\n    // or excluding the last element\n    return isSubsetSumRec(arr, n - 1, sum) ||\n           isSubsetSumRec(arr, n - 1, sum - arr[n - 1]);\n}\nint isSubsetSum(int arr[], int n, int sum) {\n    return isSubsetSumRec(arr, n, sum);\n}\nint main() {\n    int arr[] = {3, 34, 4, 12, 5, 2};\n    int sum = 9;\n    int n = sizeof(arr) / sizeof(arr[0]);\n    if (isSubsetSum(arr, n, sum)) {\n        printf(\"True\\n\");\n    } else {\n        printf(\"False\\n\");\n    }\n    return 0;\n}",
    "code_without_comments": "\n\n#include <stdio.h>\n\n\nint isSubsetSumRec(int arr[], int n, int sum) {\n\n    if (sum == 0) {\n        return 1;\n    }\n    if (n == 0) {\n        return 0;\n    }\n\n    if (arr[n - 1] > sum) {\n        return isSubsetSumRec(arr, n - 1, sum);\n    }\n\n\n    return isSubsetSumRec(arr, n - 1, sum) ||\n           isSubsetSumRec(arr, n - 1, sum - arr[n - 1]);\n}\nint isSubsetSum(int arr[], int n, int sum) {\n    return isSubsetSumRec(arr, n, sum);\n}\nint main() {\n    int arr[] = {3, 34, 4, 12, 5, 2};\n    int sum = 9;\n    int n = sizeof(arr) / sizeof(arr[0]);\n    if (isSubsetSum(arr, n, sum)) {\n        printf(\"True\\n\");\n    } else {\n        printf(\"False\\n\");\n    }\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "# Python implementation for subset sum\n# problem using recursion\ndef isSubsetSumRec(arr, n, sum):\n    # Base Cases\n    if sum == 0:\n        return True\n    if n == 0:\n        return False\n    # If the last element is greater\n    # than the sum, ignore it\n    if arr[n - 1] > sum:\n        return isSubsetSumRec(arr, n - 1, sum)\n    # Check if sum can be obtained by including\n    # or excluding the last element\n    return (isSubsetSumRec(arr, n - 1, sum) or\n            isSubsetSumRec(arr, n - 1, sum - arr[n - 1]))\ndef isSubsetSum(arr, sum):\n    return isSubsetSumRec(arr, len(arr), sum)\nif __name__ == \"__main__\":\n    arr = [3, 34, 4, 12, 5, 2]\n    sum = 9\n    if isSubsetSum(arr, sum):\n        print(\"True\")\n    else:\n        print(\"False\")",
    "code_without_comments": "\n\ndef isSubsetSumRec(arr, n, sum):\n\n    if sum == 0:\n        return True\n    if n == 0:\n        return False\n\n\n    if arr[n - 1] > sum:\n        return isSubsetSumRec(arr, n - 1, sum)\n\n\n    return (isSubsetSumRec(arr, n - 1, sum) or\n            isSubsetSumRec(arr, n - 1, sum - arr[n - 1]))\ndef isSubsetSum(arr, sum):\n    return isSubsetSumRec(arr, len(arr), sum)\nif __name__ == \"__main__\":\n    arr = [3, 34, 4, 12, 5, 2]\n    sum = 9\n    if isSubsetSum(arr, sum):\n        print(\"True\")\n    else:\n        print(\"False\")",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "//C++ implementation for subset sum\n// problem using memoization\n#include <bits/stdc++.h>\nusing namespace std;\n// Recursive function to check if a subset\n// with the given sum exists\nbool isSubsetSumRec(vector<int>& arr, int n, int sum,\n                   vector<vector<int>> &memo) {\n    // If the sum is zero, we found a subset\n    if (sum == 0)\n        return 1;\n    // If no elements are left\n    if (n <= 0)\n        return 0;\n    // If the value is already\n  \t// computed, return it\n    if (memo[n][sum] != -1)\n        return memo[n][sum];\n    // If the last element is greater than\n  \t// the sum, ignore it\n    if (arr[n - 1] > sum)\n        return memo[n][sum] = isSubsetSumRec(arr, n - 1, sum, memo);\n    else {\n        // Include or exclude the last element\n        return memo[n][sum] = isSubsetSumRec(arr, n - 1, sum, memo) ||\n                              isSubsetSumRec(arr, n - 1, sum - arr[n - 1], memo);\n    }\n}\n// Function to initiate the subset sum check\nbool isSubsetSum(vector<int>&arr, int sum) {\n   int n = arr.size();\n    vector<vector<int>> memo(n + 1, vector<int>(sum + 1, -1));\n    return isSubsetSumRec(arr, n, sum, memo);\n}\nint main() {\n    vector<int>arr = {1, 5, 3, 7, 4};\n    int sum = 12;\n    if (isSubsetSum(arr, sum)) {\n        cout << \"True\" << endl;\n    }\n    else {\n        cout << \"False\" << endl;\n    }\n    return 0;\n}",
    "code_without_comments": "\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n\nbool isSubsetSumRec(vector<int>& arr, int n, int sum,\n                   vector<vector<int>> &memo) {\n\n    if (sum == 0)\n        return 1;\n\n    if (n <= 0)\n        return 0;\n\n\n    if (memo[n][sum] != -1)\n        return memo[n][sum];\n\n\n    if (arr[n - 1] > sum)\n        return memo[n][sum] = isSubsetSumRec(arr, n - 1, sum, memo);\n    else {\n\n        return memo[n][sum] = isSubsetSumRec(arr, n - 1, sum, memo) ||\n                              isSubsetSumRec(arr, n - 1, sum - arr[n - 1], memo);\n    }\n}\n\nbool isSubsetSum(vector<int>&arr, int sum) {\n   int n = arr.size();\n    vector<vector<int>> memo(n + 1, vector<int>(sum + 1, -1));\n    return isSubsetSumRec(arr, n, sum, memo);\n}\nint main() {\n    vector<int>arr = {1, 5, 3, 7, 4};\n    int sum = 12;\n    if (isSubsetSum(arr, sum)) {\n        cout << \"True\" << endl;\n    }\n    else {\n        cout << \"False\" << endl;\n    }\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "# Python implementation for subset sum\n# problem using memoization\ndef isSubsetSumRec(arr, n, sum, memo):\n    # If the sum is zero, we found\n    # a subset\n    if sum == 0:\n        return True\n    # If no elements are left\n    if n <= 0:\n        return False\n    # If the value is already\n    # computed, return it\n    if memo[n][sum] != -1:\n        return memo[n][sum]\n    # If the last element is greater\n    # than the sum, ignore it\n    if arr[n - 1] > sum:\n        memo[n][sum] = isSubsetSumRec(arr, n - 1, sum, memo)\n    else:\n        # Include or exclude the last element\n        # directly\n        memo[n][sum] = (isSubsetSumRec(arr, n - 1, sum, memo)\n                        or isSubsetSumRec(arr, n - 1, sum - arr[n - 1], memo))\n    return memo[n][sum]\ndef isSubsetSum(arr, sum):\n    n = len(arr)\n    memo = [[-1 for _ in range(sum + 1)] for _ in range(n + 1)]\n    return isSubsetSumRec(arr, n, sum, memo)\nif __name__ == \"__main__\":\n    arr = [1, 5, 3, 7, 4]\n    sum = 12\n    if isSubsetSum(arr, sum):\n        print(\"True\")\n    else:\n        print(\"False\")",
    "code_without_comments": "\n\ndef isSubsetSumRec(arr, n, sum, memo):\n\n\n    if sum == 0:\n        return True\n\n    if n <= 0:\n        return False\n\n\n    if memo[n][sum] != -1:\n        return memo[n][sum]\n\n\n    if arr[n - 1] > sum:\n        memo[n][sum] = isSubsetSumRec(arr, n - 1, sum, memo)\n    else:\n\n\n        memo[n][sum] = (isSubsetSumRec(arr, n - 1, sum, memo)\n                        or isSubsetSumRec(arr, n - 1, sum - arr[n - 1], memo))\n    return memo[n][sum]\ndef isSubsetSum(arr, sum):\n    n = len(arr)\n    memo = [[-1 for _ in range(sum + 1)] for _ in range(n + 1)]\n    return isSubsetSumRec(arr, n, sum, memo)\nif __name__ == \"__main__\":\n    arr = [1, 5, 3, 7, 4]\n    sum = 12\n    if isSubsetSum(arr, sum):\n        print(\"True\")\n    else:\n        print(\"False\")",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "//C++ implementation for subset sum\n// problem using tabulation\n#include <bits/stdc++.h>\nusing namespace std;\n// Function to check if there is a subset of arr[]\n// with sum equal to the given sum using tabulation with vectors\nbool isSubsetSum(vector<int> &arr, int sum) {\n    int n = arr.size();\n    // Create a 2D vector for storing results\n  \t// of subproblems\n    vector<vector<bool>> dp(n + 1, vector<bool>(sum + 1, false));\n    // If sum is 0, then answer is true (empty subset)\n    for (int i = 0; i <= n; i++)\n        dp[i][0] = true;\n    // Fill the dp table in bottom-up manner\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= sum; j++) {\n            if (j < arr[i - 1]) {\n               // Exclude the current element\n                dp[i][j] = dp[i - 1][j];\n            }\n            else {\n               // Include or exclude\n                dp[i][j] = dp[i - 1][j]\n                || dp[i - 1][j - arr[i - 1]];\n            }\n        }\n    }\n    return dp[n][sum];\n}\nint main() {\n    vector<int> arr = {3, 34, 4, 12, 5, 2};\n    int sum = 9;\n    if (isSubsetSum(arr, sum))\n        cout << \"True\" << endl;\n    else\n        cout << \"False\" << endl;\n    return 0;\n}",
    "code_without_comments": "\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n\nbool isSubsetSum(vector<int> &arr, int sum) {\n    int n = arr.size();\n\n\n    vector<vector<bool>> dp(n + 1, vector<bool>(sum + 1, false));\n\n    for (int i = 0; i <= n; i++)\n        dp[i][0] = true;\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= sum; j++) {\n            if (j < arr[i - 1]) {\n\n                dp[i][j] = dp[i - 1][j];\n            }\n            else {\n\n                dp[i][j] = dp[i - 1][j]\n                || dp[i - 1][j - arr[i - 1]];\n            }\n        }\n    }\n    return dp[n][sum];\n}\nint main() {\n    vector<int> arr = {3, 34, 4, 12, 5, 2};\n    int sum = 9;\n    if (isSubsetSum(arr, sum))\n        cout << \"True\" << endl;\n    else\n        cout << \"False\" << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "# Python implementation for subset sum\n# problem using tabulation\ndef isSubsetSum(arr, sum):\n    n = len(arr)\n    # Create a 2D list for storing\n    # results of subproblems\n    dp = [[False] * (sum + 1) for _ in range(n + 1)]\n    # If sum is 0, then answer is\n    # true (empty subset)\n    for i in range(n + 1):\n        dp[i][0] = True\n    # Fill the dp table in bottom-up manner\n    for i in range(1, n + 1):\n        for j in range(1, sum + 1):\n            if j < arr[i - 1]:\n                # Exclude the current element\n                dp[i][j] = dp[i - 1][j]\n            else:\n                # Include or exclude\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n    return dp[n][sum]\nif __name__ == \"__main__\":\n    arr = [3, 34, 4, 12, 5, 2]\n    sum_value = 9\n    if isSubsetSum(arr, sum_value):\n        print(\"True\")\n    else:\n        print(\"False\")",
    "code_without_comments": "\n\ndef isSubsetSum(arr, sum):\n    n = len(arr)\n\n\n    dp = [[False] * (sum + 1) for _ in range(n + 1)]\n\n\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, sum + 1):\n            if j < arr[i - 1]:\n\n                dp[i][j] = dp[i - 1][j]\n            else:\n\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n    return dp[n][sum]\nif __name__ == \"__main__\":\n    arr = [3, 34, 4, 12, 5, 2]\n    sum_value = 9\n    if isSubsetSum(arr, sum_value):\n        print(\"True\")\n    else:\n        print(\"False\")",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "// C++ Program for Space Optimized Dynamic Programming\n// Solution to Subset Sum Problem\n#include <bits/stdc++.h>\nusing namespace std;\n// Returns true if there is a subset of arr[]\n// with sum equal to given sum\nbool isSubsetSum(vector<int> arr, int sum) {\n    int n = arr.size();\n    vector<bool> prev(sum + 1, false), curr(sum + 1);\n    // Mark prev[0] = true as it is true\n  \t// to make sum = 0 using 0 elements\n    prev[0] = true;\n    // Fill the subset table in\n  \t// bottom up manner\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= sum; j++) {\n            if (j < arr[i - 1])\n                curr[j] = prev[j];\n            else\n                curr[j] = (prev[j] || prev[j - arr[i - 1]]);\n        }\n        prev = curr;\n    }\n    return prev[sum];\n}\nint main() {\n    vector<int> arr = {3, 34, 4, 12, 5, 2};\n    int sum = 9;\n    if (isSubsetSum(arr, sum) == true)\n        cout << \"True\";\n    else\n        cout << \"False\";\n    return 0;\n}",
    "code_without_comments": "\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n\nbool isSubsetSum(vector<int> arr, int sum) {\n    int n = arr.size();\n    vector<bool> prev(sum + 1, false), curr(sum + 1);\n\n\n    prev[0] = true;\n\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= sum; j++) {\n            if (j < arr[i - 1])\n                curr[j] = prev[j];\n            else\n                curr[j] = (prev[j] || prev[j - arr[i - 1]]);\n        }\n        prev = curr;\n    }\n    return prev[sum];\n}\nint main() {\n    vector<int> arr = {3, 34, 4, 12, 5, 2};\n    int sum = 9;\n    if (isSubsetSum(arr, sum) == true)\n        cout << \"True\";\n    else\n        cout << \"False\";\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "# Python Program for Space Optimized Dynamic Programming\n# Solution to Subset Sum Problem\ndef isSubsetSum(arr, sum):\n    n = len(arr)\n    prev = [False] * (sum + 1)\n    curr = [False] * (sum + 1)\n    # Base case: sum 0 can always\n    # be achieved\n    prev[0] = True\n    # Fill the dp table in a\n    # bottom-up manner\n    for i in range(1, n + 1):\n        for j in range(sum + 1):\n            if j < arr[i - 1]:\n                curr[j] = prev[j]\n            else:\n                curr[j] = prev[j] or prev[j - arr[i - 1]]\n        prev = curr.copy()\n    return prev[sum]\nif __name__ == \"__main__\":\n    arr = [3, 34, 4, 12, 5, 2]\n    sum_value = 9\n    if isSubsetSum(arr, sum_value):\n        print(\"True\")\n    else:\n        print(\"False\")",
    "code_without_comments": "\n\ndef isSubsetSum(arr, sum):\n    n = len(arr)\n    prev = [False] * (sum + 1)\n    curr = [False] * (sum + 1)\n\n\n    prev[0] = True\n\n\n    for i in range(1, n + 1):\n        for j in range(sum + 1):\n            if j < arr[i - 1]:\n                curr[j] = prev[j]\n            else:\n                curr[j] = prev[j] or prev[j - arr[i - 1]]\n        prev = curr.copy()\n    return prev[sum]\nif __name__ == \"__main__\":\n    arr = [3, 34, 4, 12, 5, 2]\n    sum_value = 9\n    if isSubsetSum(arr, sum_value):\n        print(\"True\")\n    else:\n        print(\"False\")",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "// C++ Program for Palindrome Partitioning Problem\n// using Recursion\n#include <iostream>\n#include <vector>\n#include <limits.h>\nusing namespace std;\n// Function to Check if a substring is a palindrome\nbool isPalindrome(string& s, int i, int j) {\n    while (i < j) {\n        if (s[i] != s[j])\n            return false;\n        i++;\n        j--;\n    }\n    return true;\n}\n// Recursive Function to find the minimum number of\n// cuts needed for palindrome partitioning\nint palPartitionRec(string& s, int i, int j) {\n    // Base case: If the substring is empty or\n  \t// a palindrome, no cuts needed\n    if (i >= j || isPalindrome(s, i, j))\n        return 0;\n    int res = INT_MAX, cuts;\n    // Iterate through all possible partitions and\n  \t// find the minimum cuts needed\n    for (int k = i; k < j; k++) {\n        cuts = 1 + palPartitionRec(s, i, k)\n                \t+ palPartitionRec(s, k + 1, j);\n        res = min(res, cuts);\n    }\n    return res;\n}\nint palPartition(string &s) {\n  \treturn palPartitionRec(s, 0, s.size()-1);\n}\nint main() {\n    string s = \"geek\";\n    cout << palPartition(s) << endl;\n    return 0;\n}",
    "code_without_comments": "\n\n#include <iostream>\n#include <vector>\n#include <limits.h>\nusing namespace std;\n\nbool isPalindrome(string& s, int i, int j) {\n    while (i < j) {\n        if (s[i] != s[j])\n            return false;\n        i++;\n        j--;\n    }\n    return true;\n}\n\n\nint palPartitionRec(string& s, int i, int j) {\n\n\n    if (i >= j || isPalindrome(s, i, j))\n        return 0;\n    int res = INT_MAX, cuts;\n\n\n    for (int k = i; k < j; k++) {\n        cuts = 1 + palPartitionRec(s, i, k)\n                \t+ palPartitionRec(s, k + 1, j);\n        res = min(res, cuts);\n    }\n    return res;\n}\nint palPartition(string &s) {\n  \treturn palPartitionRec(s, 0, s.size()-1);\n}\nint main() {\n    string s = \"geek\";\n    cout << palPartition(s) << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/palindrome-partitioning-dp-17/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "// C Program for Palindrome Partitioning Problem\n// using Recursion\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n// Function to check if a substring is a palindrome\nint isPalindrome(char* s, int i, int j) {\n    while (i < j) {\n        if (s[i] != s[j])\n            return 0;\n        i++;\n        j--;\n    }\n    return 1;\n}\n// Recursive function to find the minimum number\n// of cuts needed for palindrome partitioning\nint palPartitionRec(char* s, int i, int j) {\n    // Base case: If the substring is empty\n  \t// or a palindrome, no cuts needed\n    if (i >= j || isPalindrome(s, i, j))\n        return 0;\n    int res = INT_MAX, cuts;\n    // Iterate through all possible partitions\n  \t// and find the minimum cuts needed\n    for (int k = i; k < j; k++) {\n        cuts = 1 + palPartitionRec(s, i, k) + palPartitionRec(s, k + 1, j);\n        if (cuts < res) res = cuts;\n    }\n    return res;\n}\nint palPartition(char* s) {\n    return palPartitionRec(s, 0, strlen(s) - 1);\n}\nint main() {\n    char s[] = \"geek\";\n    printf(\"%d\\n\", palPartition(s));\n    return 0;\n}",
    "code_without_comments": "\n\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\nint isPalindrome(char* s, int i, int j) {\n    while (i < j) {\n        if (s[i] != s[j])\n            return 0;\n        i++;\n        j--;\n    }\n    return 1;\n}\n\n\nint palPartitionRec(char* s, int i, int j) {\n\n\n    if (i >= j || isPalindrome(s, i, j))\n        return 0;\n    int res = INT_MAX, cuts;\n\n\n    for (int k = i; k < j; k++) {\n        cuts = 1 + palPartitionRec(s, i, k) + palPartitionRec(s, k + 1, j);\n        if (cuts < res) res = cuts;\n    }\n    return res;\n}\nint palPartition(char* s) {\n    return palPartitionRec(s, 0, strlen(s) - 1);\n}\nint main() {\n    char s[] = \"geek\";\n    printf(\"%d\\n\", palPartition(s));\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/palindrome-partitioning-dp-17/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "# Python Program for Palindrome Partitioning Problem\n# using Recursion\nimport sys\n# Function to check if a substring is a palindrome\ndef isPalindrome(s, i, j):\n    while i < j:\n        if s[i] != s[j]:\n            return False\n        i += 1\n        j -= 1\n    return True\n# Recursive function to find the minimum number\n# of cuts needed for palindrome partitioning\ndef palPartitionRec(s, i, j):\n    # Base case: If the substring is empty\n    # or a palindrome, no cuts needed\n    if i >= j or isPalindrome(s, i, j):\n        return 0\n    res = sys.maxsize\n    # Iterate through all possible partitions\n    # and find the minimum cuts needed\n    for k in range(i, j):\n        cuts = 1 + palPartitionRec(s, i, k) \\\n        \t\t + palPartitionRec(s, k + 1, j)\n        res = min(res, cuts)\n    return res\ndef palPartition(s):\n    return palPartitionRec(s, 0, len(s) - 1)\nif __name__ == \"__main__\":\n    s = \"geek\"\n    print(palPartition(s))",
    "code_without_comments": "\n\nimport sys\n\ndef isPalindrome(s, i, j):\n    while i < j:\n        if s[i] != s[j]:\n            return False\n        i += 1\n        j -= 1\n    return True\n\n\ndef palPartitionRec(s, i, j):\n\n\n    if i >= j or isPalindrome(s, i, j):\n        return 0\n    res = sys.maxsize\n\n\n    for k in range(i, j):\n        cuts = 1 + palPartitionRec(s, i, k) \\\n        \t\t + palPartitionRec(s, k + 1, j)\n        res = min(res, cuts)\n    return res\ndef palPartition(s):\n    return palPartitionRec(s, 0, len(s) - 1)\nif __name__ == \"__main__\":\n    s = \"geek\"\n    print(palPartition(s))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/palindrome-partitioning-dp-17/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "// C++ Program for Palindrome Partitioning Problem\n// Using Top-Down DP\n#include <iostream>\n#include <vector>\n#include <limits.h>\nusing namespace std;\n// Function to Check if a substring is a palindrome\nbool isPalindrome(string& s, int i, int j) {\n    while (i < j) {\n        if (s[i] != s[j])\n            return false;\n        i++;\n        j--;\n    }\n    return true;\n}\n// Recursive Function to find the minimum number of\n// cuts needed for palindrome partitioning\nint palPartitionRec(string& s, int i, int j,\n                    \tvector<vector<int>>& memo) {\n  \t// check in memo for\n  \tif (memo[i][j] != -1)\n      \treturn memo[i][j];\n    // Base case: If the substring is empty or\n  \t// a palindrome, no cuts needed\n    if (i >= j || isPalindrome(s, i, j))\n        return memo[i][j] = 0;\n    int res = INT_MAX, cuts;\n    // Iterate through all possible partitions and\n  \t// find the minimum cuts needed\n    for (int k = i; k < j; k++) {\n        cuts = 1 + palPartitionRec(s, i, k, memo)\n                + palPartitionRec(s, k + 1, j, memo);\n        res = min(res, cuts);\n    }\n    return memo[i][j] = res;\n}\nint palPartition(string &s) {\n  \tint n = s.size();\n  \t// declare a memo array to store the result\n  \t// and initialise it with -1\n  \tvector<vector<int>> memo(n, vector<int> (n, -1));\n  \treturn palPartitionRec(s, 0, n - 1, memo);\n}\nint main() {\n    string s = \"geek\";\n    cout << palPartition(s) << endl;\n    return 0;\n}",
    "code_without_comments": "\n\n#include <iostream>\n#include <vector>\n#include <limits.h>\nusing namespace std;\n\nbool isPalindrome(string& s, int i, int j) {\n    while (i < j) {\n        if (s[i] != s[j])\n            return false;\n        i++;\n        j--;\n    }\n    return true;\n}\n\n\nint palPartitionRec(string& s, int i, int j,\n                    \tvector<vector<int>>& memo) {\n\n  \tif (memo[i][j] != -1)\n      \treturn memo[i][j];\n\n\n    if (i >= j || isPalindrome(s, i, j))\n        return memo[i][j] = 0;\n    int res = INT_MAX, cuts;\n\n\n    for (int k = i; k < j; k++) {\n        cuts = 1 + palPartitionRec(s, i, k, memo)\n                + palPartitionRec(s, k + 1, j, memo);\n        res = min(res, cuts);\n    }\n    return memo[i][j] = res;\n}\nint palPartition(string &s) {\n  \tint n = s.size();\n\n\n  \tvector<vector<int>> memo(n, vector<int> (n, -1));\n  \treturn palPartitionRec(s, 0, n - 1, memo);\n}\nint main() {\n    string s = \"geek\";\n    cout << palPartition(s) << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/palindrome-partitioning-dp-17/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "# Python Program for Palindrome Partitioning Problem\n# Using Top-Down DP\nimport sys\n# Function to check if a substring is a palindrome\ndef isPalindrome(s, i, j):\n    while i < j:\n        if s[i] != s[j]:\n            return False\n        i += 1\n        j -= 1\n    return True\n# Recursive function to find the minimum number of\n# cuts needed for palindrome partitioning\ndef palPartitionRec(s, i, j, memo):\n    # Check memo for previously computed results\n    if memo[i][j] != -1:\n        return memo[i][j]\n    # Base case: If the substring is empty or\n    # a palindrome, no cuts needed\n    if i >= j or isPalindrome(s, i, j):\n        memo[i][j] = 0\n        return 0\n    res = sys.maxsize\n    # Iterate through all possible partitions and\n    # find the minimum cuts needed\n    for k in range(i, j):\n        cuts = 1 + palPartitionRec(s, i, k, memo) \\\n        + palPartitionRec(s, k + 1, j, memo)\n        res = min(res, cuts)\n    memo[i][j] = res\n    return res\ndef palPartition(s):\n    n = len(s)\n    memo = [[-1 for _ in range(n)] for _ in range(n)]\n    return palPartitionRec(s, 0, n - 1, memo)\nif __name__ == \"__main__\":\n    s = \"geek\"\n    print(palPartition(s))",
    "code_without_comments": "\n\nimport sys\n\ndef isPalindrome(s, i, j):\n    while i < j:\n        if s[i] != s[j]:\n            return False\n        i += 1\n        j -= 1\n    return True\n\n\ndef palPartitionRec(s, i, j, memo):\n\n    if memo[i][j] != -1:\n        return memo[i][j]\n\n\n    if i >= j or isPalindrome(s, i, j):\n        memo[i][j] = 0\n        return 0\n    res = sys.maxsize\n\n\n    for k in range(i, j):\n        cuts = 1 + palPartitionRec(s, i, k, memo) \\\n        + palPartitionRec(s, k + 1, j, memo)\n        res = min(res, cuts)\n    memo[i][j] = res\n    return res\ndef palPartition(s):\n    n = len(s)\n    memo = [[-1 for _ in range(n)] for _ in range(n)]\n    return palPartitionRec(s, 0, n - 1, memo)\nif __name__ == \"__main__\":\n    s = \"geek\"\n    print(palPartition(s))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/palindrome-partitioning-dp-17/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "// C++ Solution for Palindrome Partitioning Problem\n// using Bottom Up Dynamic Programming\n#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n// Function to find the minimum number of cuts\n// needed to partition a string such that\n// every part is a palindrome\nint palPartition(string& s) {\n    int n = s.length();\n    // dp[i][j] = Minimum number of cuts needed for\n    // palindrome partitioning of substring s[i..j]\n    int dp[n][n];\n    // isPalin[i][j] = true if substring s[i..j]\n  \t// is palindrome,else false\n    bool isPalin[n][n];\n    // Every substring of length 1 is a palindrome\n    for (int i = 0; i < n; i++) {\n        isPalin[i][i] = true;\n        dp[i][i] = 0;\n    }\n    for (int len = 2; len <= n; len++) {\n        // Build solution for all substrings s[i ... j]\n      \t// of length len\n        for (int i = 0, j = i + len - 1; j < n ; i++, j++) {\n            // If len is 2, then we just need to\n            // compare two characters.\n            if (len == 2)\n                isPalin[i][j] = (s[i] == s[j]);\n          \t// Else need to check two corner characters\n            // and value of isPalin[i+1][j-1]\n            else\n                isPalin[i][j] = (s[i] == s[j]) &&\n              \t\t\t\t\t\tisPalin[i + 1][j - 1];\n            // IF s[i..j] is palindrome, then dp[i][j] is 0\n            if (isPalin[i][j] == true)\n                dp[i][j] = 0;\n            else {\n            // Make a cut at every possible location starting\n          \t// from i to j, and get the minimum cost cut.\n                dp[i][j] = INT_MAX;\n                for (int k = i; k <= j - 1; k++)\n                    dp[i][j] = min(dp[i][j], 1 +\n                                   dp[i][k] + dp[k + 1][j]);\n            }\n        }\n    }\n    // Return the min cut value for\n    // complete string. i.e., s[0..n-1]\n    return dp[0][n - 1];\n}\nint main() {\n    string s = \"geek\";\n    cout << palPartition(s) << endl;\n    return 0;\n}",
    "code_without_comments": "\n\n#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\n\n\nint palPartition(string& s) {\n    int n = s.length();\n\n\n    int dp[n][n];\n\n\n    bool isPalin[n][n];\n\n    for (int i = 0; i < n; i++) {\n        isPalin[i][i] = true;\n        dp[i][i] = 0;\n    }\n    for (int len = 2; len <= n; len++) {\n\n\n        for (int i = 0, j = i + len - 1; j < n ; i++, j++) {\n\n\n            if (len == 2)\n                isPalin[i][j] = (s[i] == s[j]);\n\n\n            else\n                isPalin[i][j] = (s[i] == s[j]) &&\n              \t\t\t\t\t\tisPalin[i + 1][j - 1];\n\n            if (isPalin[i][j] == true)\n                dp[i][j] = 0;\n            else {\n\n\n                dp[i][j] = INT_MAX;\n                for (int k = i; k <= j - 1; k++)\n                    dp[i][j] = min(dp[i][j], 1 +\n                                   dp[i][k] + dp[k + 1][j]);\n            }\n        }\n    }\n\n\n    return dp[0][n - 1];\n}\nint main() {\n    string s = \"geek\";\n    cout << palPartition(s) << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/palindrome-partitioning-dp-17/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "# Python Solution for Palindrome Partitioning Problem\n# using Bottom Up Dynamic Programming\n# Function to find the minimum number of cuts\n# needed to partition a string such that\n# every part is a palindrome\ndef palPartition(s):\n    n = len(s)\n    # dp[i][j] = Minimum number of cuts needed for\n    # palindrome partitioning of substring s[i..j]\n    dp = [[0] * n for _ in range(n)]\n    # isPalin[i][j] = true if substring s[i..j]\n    # is palindrome, else false\n    isPalin = [[False] * n for _ in range(n)]\n    # Every substring of length 1 is a palindrome\n    for i in range(n):\n        isPalin[i][i] = True\n        dp[i][i] = 0\n    for length in range(2, n + 1):\n        # Build solution for all  substrings s[i ... j]\n        # of length len\n        for i in range(n - length + 1):\n            j = i + length - 1\n            # If len is 2, then we just need to\n            # compare two characters.\n            if length == 2:\n                isPalin[i][j] = (s[i] == s[j])\n            # Else need to check two corner characters\n            # and value of isPalin[i+1][j-1]\n            else:\n                isPalin[i][j] = (s[i] == s[j]) and isPalin[i + 1][j - 1]\n            # IF s[i..j] is palindrome, then dp[i][j] is 0\n            if isPalin[i][j]:\n                dp[i][j] = 0\n            else:\n                # Make a cut at every possible location starting\n                # from i to j, and get the minimum cost cut.\n                dp[i][j] = min(1 + dp[i][k] + dp[k + 1][j] for k in range(i, j))\n    # Return the min cut value for\n    # complete string. i.e., s[0..n-1]\n    return dp[0][n - 1]\nif __name__ == \"__main__\":\n    s = \"geek\"\n    print(palPartition(s))",
    "code_without_comments": "\n\n\n\n\ndef palPartition(s):\n    n = len(s)\n\n\n    dp = [[0] * n for _ in range(n)]\n\n\n    isPalin = [[False] * n for _ in range(n)]\n\n    for i in range(n):\n        isPalin[i][i] = True\n        dp[i][i] = 0\n    for length in range(2, n + 1):\n\n\n        for i in range(n - length + 1):\n            j = i + length - 1\n\n\n            if length == 2:\n                isPalin[i][j] = (s[i] == s[j])\n\n\n            else:\n                isPalin[i][j] = (s[i] == s[j]) and isPalin[i + 1][j - 1]\n\n            if isPalin[i][j]:\n                dp[i][j] = 0\n            else:\n\n\n                dp[i][j] = min(1 + dp[i][k] + dp[k + 1][j] for k in range(i, j))\n\n\n    return dp[0][n - 1]\nif __name__ == \"__main__\":\n    s = \"geek\"\n    print(palPartition(s))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/palindrome-partitioning-dp-17/",
    "complexity_weight": 3.0
  }
]