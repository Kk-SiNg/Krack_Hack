[
  {
    "code_with_comments": "// C++ Solution for Palindrome Partitioning Problem\n// using Optimised Bottom Up Dynamic Programming\n#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n// Function to fill isPalin array such that isPalin[i][j]\n// stores whether substring s[i, j] is a palindrome or not\nvoid generatePal(string& s, vector<vector<bool>>& isPalin) {\n    int n = s.size();\n    // Substring s[i .. i] of len 1\n  \t// is always palindromic\n    for (int i = 0; i < n; i++) {\n        isPalin[i][i] = true;\n    }\n    // Iterate over different lengths of substrings\n    for (int len = 2; len <= n; len++) {\n        for (int i = 0, j = i + len - 1; j < n ; i++, j++) {\n            // Check whether s[i] == s[j] and the\n            // substring between them is a palindrome\n            if (s[i] == s[j] && (len == 2\n                                 || isPalin[i + 1][j - 1])) {\n                // Mark the substring from i to j as a\n                // palindrome\n                isPalin[i][j] = true;\n            }\n        }\n    }\n}\n// Function to calculate the minimum number of cuts required\n// to make all substrings of 's' palindromic\nint palPartition(string& s) {\n    int n = s.size();\n    // 2D array to store whether substring\n  \t// s[i, j] is a palindrome or not\n    vector<vector<bool>> isPalin(n, vector<bool>(n, false));\n    generatePal(s, isPalin);\n    // dp[i] stores minimum cuts for Palindrome\n  \t// Partitioning of substring s[0...i]\n    vector<int> dp(n, n);\n    // There is no cut required for single character\n    // as it is always palindrome\n    dp[0] = 0;\n    // Iterate over the given string\n    for (int i = 1; i < n; i++) {\n        // Check if string 0 to i is palindrome.\n        if (isPalin[0][i]) {\n          \t// if palindrome then cuts required is 0\n            dp[i] = 0;\n        }\n        else {\n            for (int j = i; j >= 1; j--) {\n              \t// if substring s[j...i] is palindromic\n              \t// then we can make a cut over here\n                if (isPalin[j][i]) {\n                  \t// update dp[i] with minimum cuts\n                  \tdp[i] = min(dp[i], 1 + dp[j-1]);\n                }\n            }\n        }\n    }\n    // Return the minimum cuts required\n  \t// for the entire string 's'\n    return dp[n - 1];\n}\nint main() {\n    string s = \"geek\";\n    cout << palPartition(s) << endl;\n    return 0;\n}",
    "code_without_comments": "\n\n#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\n\nvoid generatePal(string& s, vector<vector<bool>>& isPalin) {\n    int n = s.size();\n\n\n    for (int i = 0; i < n; i++) {\n        isPalin[i][i] = true;\n    }\n\n    for (int len = 2; len <= n; len++) {\n        for (int i = 0, j = i + len - 1; j < n ; i++, j++) {\n\n\n            if (s[i] == s[j] && (len == 2\n                                 || isPalin[i + 1][j - 1])) {\n\n\n                isPalin[i][j] = true;\n            }\n        }\n    }\n}\n\n\nint palPartition(string& s) {\n    int n = s.size();\n\n\n    vector<vector<bool>> isPalin(n, vector<bool>(n, false));\n    generatePal(s, isPalin);\n\n\n    vector<int> dp(n, n);\n\n\n    dp[0] = 0;\n\n    for (int i = 1; i < n; i++) {\n\n        if (isPalin[0][i]) {\n\n            dp[i] = 0;\n        }\n        else {\n            for (int j = i; j >= 1; j--) {\n\n\n                if (isPalin[j][i]) {\n\n                  \tdp[i] = min(dp[i], 1 + dp[j-1]);\n                }\n            }\n        }\n    }\n\n\n    return dp[n - 1];\n}\nint main() {\n    string s = \"geek\";\n    cout << palPartition(s) << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/palindrome-partitioning-dp-17/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "# Python Solution for Palindrome Partitioning Problem\n# using Optimised Bottom Up Dynamic Programming\n# Function to fill isPalin array such that isPalin[i][j]\n# stores whether substring s[i, j] is a palindrome or not\ndef generatePal(s, isPalin):\n    n = len(s)\n    # Substring s[i .. i] of len 1\n    # is always palindromic\n    for i in range(n):\n        isPalin[i][i] = True\n    # Iterate over different lengths of substrings\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            # Check whether s[i] == s[j] and the\n            # substring between them is a palindrome\n            if s[i] == s[j] and (length == 2 or isPalin[i + 1][j - 1]):\n                # Mark the substring from i to j as a\n                # palindrome\n                isPalin[i][j] = True\n# Function to calculate the minimum number of cuts required\n# to make all substrings of 's' palindromic\ndef palPartition(s):\n    n = len(s)\n    # 2D array to store whether substring\n    # s[i, j] is a palindrome or not\n    isPalin = [[False] * n for _ in range(n)]\n    generatePal(s, isPalin)\n    # dp[i] stores minimum cuts for Palindrome\n    # Partitioning of substring s[0...i]\n    dp = [n] * n\n    # There is no cut required for single character\n    # as it is always palindrome\n    dp[0] = 0\n    # Iterate over the given string\n    for i in range(1, n):\n        # Check if string 0 to i is palindrome.\n        if isPalin[0][i]:\n            # if palindrome then cuts required is 0\n            dp[i] = 0\n        else:\n            for j in range(i, 0, -1):\n                # if substring s[j...i] is palindromic\n                # then we can make a cut over here\n                if isPalin[j][i]:\n                    # update dp[i] with minimum cuts\n                    dp[i] = min(dp[i], 1 + dp[j - 1])\n    # Return the minimum cuts required\n    # for the entire string 's'\n    return dp[n - 1]\nif __name__ == \"__main__\":\n    s = \"geek\"\n    print(palPartition(s))",
    "code_without_comments": "\n\n\n\ndef generatePal(s, isPalin):\n    n = len(s)\n\n\n    for i in range(n):\n        isPalin[i][i] = True\n\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n\n\n            if s[i] == s[j] and (length == 2 or isPalin[i + 1][j - 1]):\n\n\n                isPalin[i][j] = True\n\n# to make all substrings of 's' palindromic\ndef palPartition(s):\n    n = len(s)\n\n\n    isPalin = [[False] * n for _ in range(n)]\n    generatePal(s, isPalin)\n\n\n    dp = [n] * n\n\n\n    dp[0] = 0\n\n    for i in range(1, n):\n\n        if isPalin[0][i]:\n\n            dp[i] = 0\n        else:\n            for j in range(i, 0, -1):\n\n\n                if isPalin[j][i]:\n\n                    dp[i] = min(dp[i], 1 + dp[j - 1])\n\n    # for the entire string 's'\n    return dp[n - 1]\nif __name__ == \"__main__\":\n    s = \"geek\"\n    print(palPartition(s))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/palindrome-partitioning-dp-17/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "// C++ program to implement word break.\n#include <bits/stdc++.h>\nusing namespace std;\n// Function to check if the given string can be broken\n// down into words from the word list\nbool wordBreakRec(int i, string &s, vector<string> &dictionary)\n{\n    // If end of string is reached,\n    // return true.\n    if (i == s.length())\n        return true;\n    int n = s.length();\n    string prefix = \"\";\n    // Try every prefix\n    for (int j = i; j < n; j++)\n    {\n        prefix += s[j];\n        // if the prefix s[i..j] is a dictionary word\n        // and rest of the string can also be broken into\n        // valid words, return true\n        if (find(dictionary.begin(), dictionary.end(), prefix) != dictionary.end() &&\n            wordBreakRec(j + 1, s, dictionary))\n        {\n            return true;\n        }\n    }\n    return false;\n}\nbool wordBreak(string &s, vector<string> &dictionary)\n{\n    return wordBreakRec(0, s, dictionary);\n}\nint main()\n{\n    string s = \"ilike\";\n    vector<string> dictionary = {\"i\", \"like\", \"gfg\"};\n    cout << (wordBreak(s, dictionary) ? \"true\" : \"false\") << endl;\n    return 0;\n}",
    "code_without_comments": "\n#include <bits/stdc++.h>\nusing namespace std;\n\n\nbool wordBreakRec(int i, string &s, vector<string> &dictionary)\n{\n\n\n    if (i == s.length())\n        return true;\n    int n = s.length();\n    string prefix = \"\";\n\n    for (int j = i; j < n; j++)\n    {\n        prefix += s[j];\n\n\n\n        if (find(dictionary.begin(), dictionary.end(), prefix) != dictionary.end() &&\n            wordBreakRec(j + 1, s, dictionary))\n        {\n            return true;\n        }\n    }\n    return false;\n}\nbool wordBreak(string &s, vector<string> &dictionary)\n{\n    return wordBreakRec(0, s, dictionary);\n}\nint main()\n{\n    string s = \"ilike\";\n    vector<string> dictionary = {\"i\", \"like\", \"gfg\"};\n    cout << (wordBreak(s, dictionary) ? \"true\" : \"false\") << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/word-break-problem-dp-32/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "def wordBreakRec(i, s, dictionary):\n    # If end of string is reached,\n    # return true.\n    if i == len(s):\n        return 1\n    n = len(s)\n    prefix = \"\"\n    # Try every prefix\n    for j in range(i, n):\n        prefix += s[j]\n        # if the prefix s[i..j] is a dictionary word\n        # and rest of the string can also be broken into\n        # valid words, return true\n        if prefix in dictionary and wordBreakRec(j + 1, s, dictionary) == 1:\n            return 1\n    return 0\ndef wordBreak(s, dictionary):\n    return wordBreakRec(0, s, dictionary)\nif __name__ == \"__main__\":\n    s = \"ilike\"\n    dictionary = {\"i\", \"like\", \"gfg\"}\n    print(\"true\" if wordBreak(s, dictionary) else \"false\")",
    "code_without_comments": "def wordBreakRec(i, s, dictionary):\n\n\n    if i == len(s):\n        return 1\n    n = len(s)\n    prefix = \"\"\n\n    for j in range(i, n):\n        prefix += s[j]\n\n\n\n        if prefix in dictionary and wordBreakRec(j + 1, s, dictionary) == 1:\n            return 1\n    return 0\ndef wordBreak(s, dictionary):\n    return wordBreakRec(0, s, dictionary)\nif __name__ == \"__main__\":\n    s = \"ilike\"\n    dictionary = {\"i\", \"like\", \"gfg\"}\n    print(\"true\" if wordBreak(s, dictionary) else \"false\")",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/word-break-problem-dp-32/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "// C++ program to implement word break.\n#include <bits/stdc++.h>\nusing namespace std;\nbool wordBreak(string &s, vector<string> &dictionary)\n{\n    int n = s.size();\n    vector<bool> dp(n + 1, 0);\n    dp[0] = 1;\n    // Traverse through the given string\n    for (int i = 1; i <= n; i++)\n    {\n        // Traverse through the dictionary words\n        for (string &w : dictionary)\n        {\n            // Check if current word is present\n            // the prefix before the word is also\n            // breakable\n            int start = i - w.size();\n            if (start >= 0 && dp[start] && s.substr(start, w.size()) == w)\n            {\n                dp[i] = 1;\n                break;\n            }\n        }\n    }\n    return dp[n];\n}\nint main()\n{\n    string s = \"ilike\";\n    vector<string> dictionary = {\"i\", \"like\", \"gfg\"};\n    cout << (wordBreak(s, dictionary) ? \"true\" : \"false\") << endl;\n    return 0;\n}",
    "code_without_comments": "\n#include <bits/stdc++.h>\nusing namespace std;\nbool wordBreak(string &s, vector<string> &dictionary)\n{\n    int n = s.size();\n    vector<bool> dp(n + 1, 0);\n    dp[0] = 1;\n\n    for (int i = 1; i <= n; i++)\n    {\n\n        for (string &w : dictionary)\n        {\n\n\n\n            int start = i - w.size();\n            if (start >= 0 && dp[start] && s.substr(start, w.size()) == w)\n            {\n                dp[i] = 1;\n                break;\n            }\n        }\n    }\n    return dp[n];\n}\nint main()\n{\n    string s = \"ilike\";\n    vector<string> dictionary = {\"i\", \"like\", \"gfg\"};\n    cout << (wordBreak(s, dictionary) ? \"true\" : \"false\") << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/word-break-problem-dp-32/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "# Python program to implement word break\ndef wordBreak(s, dictionary):\n    n = len(s)\n    dp = [False] * (n + 1)\n    dp[0] = True\n    # Traverse through the given string\n    for i in range(1, n + 1):\n        # Traverse through the dictionary words\n        for w in dictionary:\n            # Check if current word is present\n            # the prefix before the word is also\n            # breakable\n            start = i - len(w)\n            if start >= 0 and dp[start] and s[start:start + len(w)] == w:\n                dp[i] = True\n                break\n    return 1 if dp[n] else 0\nif __name__ == '__main__':\n    s = \"ilike\"\n    dictionary = [\"i\", \"like\", \"gfg\"]\n    print(\"true\" if wordBreak(s, dictionary) else \"false\")",
    "code_without_comments": "\ndef wordBreak(s, dictionary):\n    n = len(s)\n    dp = [False] * (n + 1)\n    dp[0] = True\n\n    for i in range(1, n + 1):\n\n        for w in dictionary:\n\n\n\n            start = i - len(w)\n            if start >= 0 and dp[start] and s[start:start + len(w)] == w:\n                dp[i] = True\n                break\n    return 1 if dp[n] else 0\nif __name__ == '__main__':\n    s = \"ilike\"\n    dictionary = [\"i\", \"like\", \"gfg\"]\n    print(\"true\" if wordBreak(s, dictionary) else \"false\")",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/word-break-problem-dp-32/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "#include <bits/stdc++.h>\nusing namespace std;\n// Function to find minimum number of attempts\n// needed in order to find the critical floor\nint eggDrop(int n, int k) {\n    // if there is less than or equal to one floor\n    if (k == 1 || k == 0)\n        return k;\n    // if there is only one egg\n    if (n == 1)\n        return k;\n    // to store the minimum number of attempts\n    int res = INT_MAX;\n    // Consider all droppings from\n    // 1st floor to kth floor\n    for (int i = 1; i <= k; i++) {\n        int cur = 1 + max(eggDrop(n - 1, i - 1),\n                            eggDrop(n, k - i));\n        if (cur < res)\n            res = cur;\n    }\n    return res;\n}\nint main() {\n    int n = 2, k = 10;\n    cout << eggDrop(n, k);\n    return 0;\n}",
    "code_without_comments": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint eggDrop(int n, int k) {\n\n    if (k == 1 || k == 0)\n        return k;\n\n    if (n == 1)\n        return k;\n\n    int res = INT_MAX;\n\n\n    for (int i = 1; i <= k; i++) {\n        int cur = 1 + max(eggDrop(n - 1, i - 1),\n                            eggDrop(n, k - i));\n        if (cur < res)\n            res = cur;\n    }\n    return res;\n}\nint main() {\n    int n = 2, k = 10;\n    cout << eggDrop(n, k);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/egg-dropping-puzzle-dp-11/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "# Function to find minimum number of attempts\n# needed in order to find the critical floor\ndef eggDrop(n, k):\n    # if there is less than or equal to one floor\n    if k == 1 or k == 0:\n        return k\n    # if there is only one egg\n    if n == 1:\n        return k\n    # to store the minimum number of attempts\n    res = float('inf')\n    # Consider all droppings from\n    # 1st floor to kth floor\n    for i in range(1, k + 1):\n        cur = 1 + max(eggDrop(n - 1, i - 1), eggDrop(n, k - i))\n        if cur < res:\n            res = cur\n    return res\nif __name__ == \"__main__\":\n    n = 2\n    k = 10\n    print(eggDrop(n, k))",
    "code_without_comments": "\n\ndef eggDrop(n, k):\n\n    if k == 1 or k == 0:\n        return k\n\n    if n == 1:\n        return k\n\n    res = float('inf')\n\n\n    for i in range(1, k + 1):\n        cur = 1 + max(eggDrop(n - 1, i - 1), eggDrop(n, k - i))\n        if cur < res:\n            res = cur\n    return res\nif __name__ == \"__main__\":\n    n = 2\n    k = 10\n    print(eggDrop(n, k))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/egg-dropping-puzzle-dp-11/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "#include <bits/stdc++.h>\nusing namespace std;\n// Function to find minimum number of attempts\n// needed in order to find the critical floor\nint solveEggDrop(int n, int k, vector<vector<int>> &memo) {\n    // if value is already calculated\n    if (memo[n][k] != -1) {\n        return memo[n][k];\n    }\n    // if there is less than or equal to one floor\n    if (k == 1 || k == 0)\n        return k;\n    // if there is only one egg\n    if (n == 1)\n        return k;\n    // to store the minimum number of attempts\n    int res = INT_MAX;\n    // Consider all droppings from\n    // 1st floor to kth floor\n    for (int i = 1; i <= k; i++) {\n        int cur = max(solveEggDrop(n - 1, i - 1, memo),\n                        solveEggDrop(n, k - i, memo));\n        if (cur < res)\n            res = cur;\n    }\n    // update the memo, and return\n    return memo[n][k] = res + 1;\n}\n// Function to find minimum number of attempts\n// needed in order to find the critical floor\nint eggDrop(int n, int k) {\n    // create memo table\n    vector<vector<int>> memo(n + 1, vector<int>(k + 1, -1));\n    return solveEggDrop(n, k, memo);\n}\nint main() {\n    int n = 2, k = 10;\n    cout << eggDrop(n, k);\n    return 0;\n}",
    "code_without_comments": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint solveEggDrop(int n, int k, vector<vector<int>> &memo) {\n\n    if (memo[n][k] != -1) {\n        return memo[n][k];\n    }\n\n    if (k == 1 || k == 0)\n        return k;\n\n    if (n == 1)\n        return k;\n\n    int res = INT_MAX;\n\n\n    for (int i = 1; i <= k; i++) {\n        int cur = max(solveEggDrop(n - 1, i - 1, memo),\n                        solveEggDrop(n, k - i, memo));\n        if (cur < res)\n            res = cur;\n    }\n\n    return memo[n][k] = res + 1;\n}\n\n\nint eggDrop(int n, int k) {\n\n    vector<vector<int>> memo(n + 1, vector<int>(k + 1, -1));\n    return solveEggDrop(n, k, memo);\n}\nint main() {\n    int n = 2, k = 10;\n    cout << eggDrop(n, k);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/egg-dropping-puzzle-dp-11/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "# Function to find minimum number of attempts\n# needed in order to find the critical floor\ndef solveEggDrop(n, k, memo):\n    # if value is already calculated\n    if memo[n][k] != -1:\n        return memo[n][k]\n    # if there is less than or equal to one floor\n    if k == 1 or k == 0:\n        return k\n    # if there is only one egg\n    if n == 1:\n        return k\n    # to store the minimum number of attempts\n    res = float('inf')\n    # Consider all droppings from\n    # 1st floor to kth floor\n    for i in range(1, k + 1):\n        cur = max(solveEggDrop(n - 1, i - 1, memo), \\\n                    solveEggDrop(n, k - i, memo))\n        if cur < res:\n            res = cur\n    # update the memo, and return\n    memo[n][k] = res + 1\n    return memo[n][k]\n# Function to find minimum number of attempts\n# needed in order to find the critical floor\ndef eggDrop(n, k):\n    # create memo table\n    memo = [[-1 for _ in range(k + 1)] for _ in range(n + 1)]\n    return solveEggDrop(n, k, memo)\nif __name__ == \"__main__\":\n    n = 2\n    k = 10\n    print(eggDrop(n, k))",
    "code_without_comments": "\n\ndef solveEggDrop(n, k, memo):\n\n    if memo[n][k] != -1:\n        return memo[n][k]\n\n    if k == 1 or k == 0:\n        return k\n\n    if n == 1:\n        return k\n\n    res = float('inf')\n\n\n    for i in range(1, k + 1):\n        cur = max(solveEggDrop(n - 1, i - 1, memo), \\\n                    solveEggDrop(n, k - i, memo))\n        if cur < res:\n            res = cur\n\n    memo[n][k] = res + 1\n    return memo[n][k]\n\n\ndef eggDrop(n, k):\n\n    memo = [[-1 for _ in range(k + 1)] for _ in range(n + 1)]\n    return solveEggDrop(n, k, memo)\nif __name__ == \"__main__\":\n    n = 2\n    k = 10\n    print(eggDrop(n, k))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/egg-dropping-puzzle-dp-11/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "#include <bits/stdc++.h>\nusing namespace std;\n// Function to find minimum number of attempts\n// needed in order to find the critical floor\nint eggDrop(int n, int k) {\n    // create a 2D table to store the results\n    vector<vector<int>> dp(k + 1,\n                vector<int>(n + 1, 0));\n    // to count the number of moves\n    int cnt = 0;\n    // while the number of floors is less than k\n    while (dp[cnt][n] < k) {\n        cnt++;\n        // for each egg\n        for (int i = 1; i <= n; i++) {\n            dp[cnt][i] = 1 + dp[cnt - 1][i - 1] +\n                        dp[cnt - 1][i];\n        }\n    }\n    return cnt;\n}\nint main() {\n    int n = 2, k = 10;\n    cout << eggDrop(n, k);\n    return 0;\n}",
    "code_without_comments": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint eggDrop(int n, int k) {\n\n    vector<vector<int>> dp(k + 1,\n                vector<int>(n + 1, 0));\n\n    int cnt = 0;\n\n    while (dp[cnt][n] < k) {\n        cnt++;\n\n        for (int i = 1; i <= n; i++) {\n            dp[cnt][i] = 1 + dp[cnt - 1][i - 1] +\n                        dp[cnt - 1][i];\n        }\n    }\n    return cnt;\n}\nint main() {\n    int n = 2, k = 10;\n    cout << eggDrop(n, k);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/egg-dropping-puzzle-dp-11/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "# Function to find minimum number of attempts\n# needed in order to find the critical floor\ndef eggDrop(n, k):\n    # create a 2D table to store the results\n    dp = [[0 for _ in range(n + 1)] for _ in range(k + 1)]\n    # to count the number of moves\n    cnt = 0\n    # while the number of floors is less than k\n    while dp[cnt][n] < k:\n        cnt += 1\n        # for each egg\n        for i in range(1, n + 1):\n            dp[cnt][i] = 1 + dp[cnt - 1][i - 1] + dp[cnt - 1][i]\n    return cnt\nif __name__ == \"__main__\":\n    n = 2\n    k = 10\n    print(eggDrop(n, k))",
    "code_without_comments": "\n\ndef eggDrop(n, k):\n\n    dp = [[0 for _ in range(n + 1)] for _ in range(k + 1)]\n\n    cnt = 0\n\n    while dp[cnt][n] < k:\n        cnt += 1\n\n        for i in range(1, n + 1):\n            dp[cnt][i] = 1 + dp[cnt - 1][i - 1] + dp[cnt - 1][i]\n    return cnt\nif __name__ == \"__main__\":\n    n = 2\n    k = 10\n    print(eggDrop(n, k))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/egg-dropping-puzzle-dp-11/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "#include <bits/stdc++.h>\nusing namespace std;\n// Function to find minimum number of attempts\n// needed in order to find the critical floor\nint eggDrop(int n, int k) {\n    // create an array to store the results\n    vector<int> dp(n + 1, 0);\n    // to count the number of moves\n    int cnt = 0;\n    // while the number of floors is less than k\n    while (dp[n] < k) {\n        cnt++;\n        // for each egg\n        for (int i = n; i > 0; i--) {\n            dp[i] += 1 + dp[i - 1];\n        }\n    }\n    return cnt;\n}\nint main() {\n    int n = 2, k = 10;\n    cout << eggDrop(n, k);\n    return 0;\n}",
    "code_without_comments": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint eggDrop(int n, int k) {\n\n    vector<int> dp(n + 1, 0);\n\n    int cnt = 0;\n\n    while (dp[n] < k) {\n        cnt++;\n\n        for (int i = n; i > 0; i--) {\n            dp[i] += 1 + dp[i - 1];\n        }\n    }\n    return cnt;\n}\nint main() {\n    int n = 2, k = 10;\n    cout << eggDrop(n, k);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/egg-dropping-puzzle-dp-11/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "# Function to find minimum number of attempts\n# needed in order to find the critical floor\ndef eggDrop(n, k):\n    # create an array to store the results\n    dp = [0] * (n + 1)\n    # to count the number of moves\n    cnt = 0\n    # while the number of floors is less than k\n    while dp[n] < k:\n        cnt += 1\n        # for each egg\n        for i in range(n, 0, -1):\n            dp[i] += 1 + dp[i - 1]\n    return cnt\nif __name__ == \"__main__\":\n    n = 2\n    k = 10\n    print(eggDrop(n, k))",
    "code_without_comments": "\n\ndef eggDrop(n, k):\n\n    dp = [0] * (n + 1)\n\n    cnt = 0\n\n    while dp[n] < k:\n        cnt += 1\n\n        for i in range(n, 0, -1):\n            dp[i] += 1 + dp[i - 1]\n    return cnt\nif __name__ == \"__main__\":\n    n = 2\n    k = 10\n    print(eggDrop(n, k))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/egg-dropping-puzzle-dp-11/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "// C++ program to find out the maximum length\n// of a side of a square sub-matrix with all 1s.\n#include <bits/stdc++.h>\nusing namespace std;\n// Recursive function to find side of square\n// originating from i,j\nint maxSquareRecur(int i, int j, vector<vector<int>> &mat, int &ans) {\n    // Return 0 for invalid cells\n    if (i<0 || i==mat.size() || j<0 || j==mat[0].size())\n        return 0;\n    // Find the side of square for right, bottom,\n    // and diagonal cells.\n    int right = maxSquareRecur(i, j+1, mat, ans);\n    int down = maxSquareRecur(i+1, j, mat, ans);\n    int diagonal = maxSquareRecur(i+1, j+1, mat, ans);\n    // If mat[i][j]==0, then square cannot\n    // be formed.\n    if (mat[i][j]==0) return 0;\n    // Side of square will be\n    int val = 1+min({right, down, diagonal});\n    ans = max(ans, val);\n    return val;\n}\nint maxSquare(vector<vector<int>> &mat) {\n    int ans = 0;\n    maxSquareRecur(0,0,mat, ans);\n    return ans;\n}\nint main() {\n    vector<vector<int>> mat =\n    {{0, 1, 1, 0, 1},\n     {1, 1, 0, 1, 0},\n     {0, 1, 1, 1, 0},\n     {1, 1, 1, 1, 0},\n     {1, 1, 1, 1, 1},\n     {0, 0, 0, 0, 0}};\n    cout << maxSquare(mat) << endl;\n    return 0;\n}",
    "code_without_comments": "\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n\nint maxSquareRecur(int i, int j, vector<vector<int>> &mat, int &ans) {\n\n    if (i<0 || i==mat.size() || j<0 || j==mat[0].size())\n        return 0;\n\n\n    int right = maxSquareRecur(i, j+1, mat, ans);\n    int down = maxSquareRecur(i+1, j, mat, ans);\n    int diagonal = maxSquareRecur(i+1, j+1, mat, ans);\n\n\n    if (mat[i][j]==0) return 0;\n\n    int val = 1+min({right, down, diagonal});\n    ans = max(ans, val);\n    return val;\n}\nint maxSquare(vector<vector<int>> &mat) {\n    int ans = 0;\n    maxSquareRecur(0,0,mat, ans);\n    return ans;\n}\nint main() {\n    vector<vector<int>> mat =\n    {{0, 1, 1, 0, 1},\n     {1, 1, 0, 1, 0},\n     {0, 1, 1, 1, 0},\n     {1, 1, 1, 1, 0},\n     {1, 1, 1, 1, 1},\n     {0, 0, 0, 0, 0}};\n    cout << maxSquare(mat) << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/maximum-size-sub-matrix-with-all-1s-in-a-binary-matrix/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "# Python program to find out the maximum length\n# of a side of a square sub-matrix with all 1s.\ndef maxSquareRecur(i, j, mat, ans):\n    # Return 0 for invalid cells\n    if i < 0 or i == len(mat) or j < 0 or j == len(mat[0]):\n        return 0\n    # Find the side of square for right, bottom,\n    # and diagonal cells.\n    right = maxSquareRecur(i, j + 1, mat, ans)\n    down = maxSquareRecur(i + 1, j, mat, ans)\n    diagonal = maxSquareRecur(i + 1, j + 1, mat, ans)\n    # If mat[i][j]==0, then square cannot\n    # be formed.\n    if mat[i][j] == 0:\n        return 0\n    # Side of square will be\n    val = 1 + min(right, down, diagonal)\n    ans[0] = max(ans[0], val)\n    return val\ndef maxSquare(mat):\n    ans = [0]\n    maxSquareRecur(0, 0, mat, ans)\n    return ans[0]\nif __name__ == \"__main__\":\n    mat = [\n        [0, 1, 1, 0, 1],\n        [1, 1, 0, 1, 0],\n        [0, 1, 1, 1, 0],\n        [1, 1, 1, 1, 0],\n        [1, 1, 1, 1, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    print(maxSquare(mat))",
    "code_without_comments": "\n\ndef maxSquareRecur(i, j, mat, ans):\n\n    if i < 0 or i == len(mat) or j < 0 or j == len(mat[0]):\n        return 0\n\n\n    right = maxSquareRecur(i, j + 1, mat, ans)\n    down = maxSquareRecur(i + 1, j, mat, ans)\n    diagonal = maxSquareRecur(i + 1, j + 1, mat, ans)\n\n\n    if mat[i][j] == 0:\n        return 0\n\n    val = 1 + min(right, down, diagonal)\n    ans[0] = max(ans[0], val)\n    return val\ndef maxSquare(mat):\n    ans = [0]\n    maxSquareRecur(0, 0, mat, ans)\n    return ans[0]\nif __name__ == \"__main__\":\n    mat = [\n        [0, 1, 1, 0, 1],\n        [1, 1, 0, 1, 0],\n        [0, 1, 1, 1, 0],\n        [1, 1, 1, 1, 0],\n        [1, 1, 1, 1, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    print(maxSquare(mat))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/maximum-size-sub-matrix-with-all-1s-in-a-binary-matrix/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "// C++ program to find out the maximum length\n// of a side of a square sub-matrix with all 1s.\n#include <bits/stdc++.h>\nusing namespace std;\n// Recursive function to find side of square\n// originating from i,j\nint maxSquareRecur(int i, int j, vector<vector<int>> &mat,\n                   int &ans, vector<vector<int>> &memo) {\n    // Return 0 for invalid cells\n    if (i<0 || i==mat.size() || j<0 || j==mat[0].size())\n        return 0;\n    // If value is memoized, return value.\n    if (memo[i][j]!=-1) return memo[i][j];\n    // Find the side of square for right, bottom,\n    // and diagonal cells.\n    int right = maxSquareRecur(i, j+1, mat, ans, memo);\n    int down = maxSquareRecur(i+1, j, mat, ans, memo);\n    int diagonal = maxSquareRecur(i+1, j+1, mat, ans, memo);\n    // If mat[i][j]==0, then square cannot\n    // be formed.\n    if (mat[i][j]==0) return memo[i][j] = 0;\n    // Side of square will be\n    int val = 1+min({right, down, diagonal});\n    ans = max(ans, val);\n    // Memoize the value and return it.\n    return memo[i][j] = val;\n}\nint maxSquare(vector<vector<int>> &mat) {\n    int n = mat.size(), m = mat[0].size();\n    int ans = 0;\n    // Create 2d array for memoization\n    vector<vector<int>> memo(n, vector<int>(m, -1));\n    maxSquareRecur(0,0,mat, ans,memo);\n    return ans;\n}\nint main() {\n    vector<vector<int>> mat =\n    {{0, 1, 1, 0, 1},\n     {1, 1, 0, 1, 0},\n     {0, 1, 1, 1, 0},\n     {1, 1, 1, 1, 0},\n     {1, 1, 1, 1, 1},\n     {0, 0, 0, 0, 0}};\n    cout << maxSquare(mat) << endl;\n    return 0;\n}",
    "code_without_comments": "\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n\nint maxSquareRecur(int i, int j, vector<vector<int>> &mat,\n                   int &ans, vector<vector<int>> &memo) {\n\n    if (i<0 || i==mat.size() || j<0 || j==mat[0].size())\n        return 0;\n\n    if (memo[i][j]!=-1) return memo[i][j];\n\n\n    int right = maxSquareRecur(i, j+1, mat, ans, memo);\n    int down = maxSquareRecur(i+1, j, mat, ans, memo);\n    int diagonal = maxSquareRecur(i+1, j+1, mat, ans, memo);\n\n\n    if (mat[i][j]==0) return memo[i][j] = 0;\n\n    int val = 1+min({right, down, diagonal});\n    ans = max(ans, val);\n\n    return memo[i][j] = val;\n}\nint maxSquare(vector<vector<int>> &mat) {\n    int n = mat.size(), m = mat[0].size();\n    int ans = 0;\n\n    vector<vector<int>> memo(n, vector<int>(m, -1));\n    maxSquareRecur(0,0,mat, ans,memo);\n    return ans;\n}\nint main() {\n    vector<vector<int>> mat =\n    {{0, 1, 1, 0, 1},\n     {1, 1, 0, 1, 0},\n     {0, 1, 1, 1, 0},\n     {1, 1, 1, 1, 0},\n     {1, 1, 1, 1, 1},\n     {0, 0, 0, 0, 0}};\n    cout << maxSquare(mat) << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/maximum-size-sub-matrix-with-all-1s-in-a-binary-matrix/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "# Python program to find out the maximum length\n# of a side of a square sub-matrix with all 1s.\ndef maxSquareRecur(i, j, mat, ans, memo):\n    # Return 0 for invalid cells\n    if i < 0 or i == len(mat) or j < 0 or j == len(mat[0]):\n        return 0\n    # If value is memoized, return value.\n    if memo[i][j] != -1:\n        return memo[i][j]\n    # Find the side of square for right, bottom,\n    # and diagonal cells.\n    right = maxSquareRecur(i, j + 1, mat, ans, memo)\n    down = maxSquareRecur(i + 1, j, mat, ans, memo)\n    diagonal = maxSquareRecur(i + 1, j + 1, mat, ans, memo)\n    # If mat[i][j]==0, then square cannot\n    # be formed.\n    if mat[i][j] == 0:\n        memo[i][j] = 0\n        return 0\n    # Side of square will be\n    val = 1 + min(right, down, diagonal)\n    ans[0] = max(ans[0], val)\n    # Memoize the value and return it.\n    memo[i][j] = val\n    return val\ndef maxSquare(mat):\n    n, m = len(mat), len(mat[0])\n    ans = [0]\n    # Create 2d array for memoization\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    maxSquareRecur(0, 0, mat, ans, memo)\n    return ans[0]\nif __name__ == \"__main__\":\n    mat = [\n        [0, 1, 1, 0, 1],\n        [1, 1, 0, 1, 0],\n        [0, 1, 1, 1, 0],\n        [1, 1, 1, 1, 0],\n        [1, 1, 1, 1, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    print(maxSquare(mat))",
    "code_without_comments": "\n\ndef maxSquareRecur(i, j, mat, ans, memo):\n\n    if i < 0 or i == len(mat) or j < 0 or j == len(mat[0]):\n        return 0\n\n    if memo[i][j] != -1:\n        return memo[i][j]\n\n\n    right = maxSquareRecur(i, j + 1, mat, ans, memo)\n    down = maxSquareRecur(i + 1, j, mat, ans, memo)\n    diagonal = maxSquareRecur(i + 1, j + 1, mat, ans, memo)\n\n\n    if mat[i][j] == 0:\n        memo[i][j] = 0\n        return 0\n\n    val = 1 + min(right, down, diagonal)\n    ans[0] = max(ans[0], val)\n\n    memo[i][j] = val\n    return val\ndef maxSquare(mat):\n    n, m = len(mat), len(mat[0])\n    ans = [0]\n\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    maxSquareRecur(0, 0, mat, ans, memo)\n    return ans[0]\nif __name__ == \"__main__\":\n    mat = [\n        [0, 1, 1, 0, 1],\n        [1, 1, 0, 1, 0],\n        [0, 1, 1, 1, 0],\n        [1, 1, 1, 1, 0],\n        [1, 1, 1, 1, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    print(maxSquare(mat))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/maximum-size-sub-matrix-with-all-1s-in-a-binary-matrix/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "// C++ program to find out the maximum length\n// of a side of a square sub-matrix with all 1s.\n#include <bits/stdc++.h>\nusing namespace std;\nint maxSquare(vector<vector<int>> &mat) {\n    int n = mat.size(), m = mat[0].size();\n    int ans = 0;\n    // Create 2d array for tabulation\n    vector<vector<int>> dp(n+1, vector<int>(m+1, 0));\n    // Fill the dp\n    for (int i=n-1; i>=0; i--) {\n        for (int j=m-1; j>=0; j--) {\n            // If square cannot be formed\n            if (mat[i][j] == 0) {\n                dp[i][j] = 0;\n                continue;\n            }\n            dp[i][j] = 1 + min({dp[i][j+1],\n            dp[i+1][j], dp[i+1][j+1]});\n            ans = max(ans, dp[i][j]);\n        }\n    }\n    return ans;\n}\nint main() {\n    vector<vector<int>> mat =\n    {{0, 1, 1, 0, 1},\n     {1, 1, 0, 1, 0},\n     {0, 1, 1, 1, 0},\n     {1, 1, 1, 1, 0},\n     {1, 1, 1, 1, 1},\n     {0, 0, 0, 0, 0}};\n    cout << maxSquare(mat) << endl;\n    return 0;\n}",
    "code_without_comments": "\n\n#include <bits/stdc++.h>\nusing namespace std;\nint maxSquare(vector<vector<int>> &mat) {\n    int n = mat.size(), m = mat[0].size();\n    int ans = 0;\n\n    vector<vector<int>> dp(n+1, vector<int>(m+1, 0));\n\n    for (int i=n-1; i>=0; i--) {\n        for (int j=m-1; j>=0; j--) {\n\n            if (mat[i][j] == 0) {\n                dp[i][j] = 0;\n                continue;\n            }\n            dp[i][j] = 1 + min({dp[i][j+1],\n            dp[i+1][j], dp[i+1][j+1]});\n            ans = max(ans, dp[i][j]);\n        }\n    }\n    return ans;\n}\nint main() {\n    vector<vector<int>> mat =\n    {{0, 1, 1, 0, 1},\n     {1, 1, 0, 1, 0},\n     {0, 1, 1, 1, 0},\n     {1, 1, 1, 1, 0},\n     {1, 1, 1, 1, 1},\n     {0, 0, 0, 0, 0}};\n    cout << maxSquare(mat) << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/maximum-size-sub-matrix-with-all-1s-in-a-binary-matrix/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "# Python program to find out the maximum length\n# of a side of a square sub-matrix with all 1s.\ndef maxSquare(mat):\n    n, m = len(mat), len(mat[0])\n    ans = 0\n    # Create 2d array for tabulation\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    # Fill the dp\n    for i in range(n - 1, -1, -1):\n        for j in range(m - 1, -1, -1):\n            # If square cannot be formed\n            if mat[i][j] == 0:\n                dp[i][j] = 0\n                continue\n            dp[i][j] = 1 + min(dp[i][j + 1], \\\n                               dp[i + 1][j], dp[i + 1][j + 1])\n            ans = max(ans, dp[i][j])\n    return ans\nif __name__ == \"__main__\":\n    mat = [\n        [0, 1, 1, 0, 1],\n        [1, 1, 0, 1, 0],\n        [0, 1, 1, 1, 0],\n        [1, 1, 1, 1, 0],\n        [1, 1, 1, 1, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    print(maxSquare(mat))",
    "code_without_comments": "\n\ndef maxSquare(mat):\n    n, m = len(mat), len(mat[0])\n    ans = 0\n\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    for i in range(n - 1, -1, -1):\n        for j in range(m - 1, -1, -1):\n\n            if mat[i][j] == 0:\n                dp[i][j] = 0\n                continue\n            dp[i][j] = 1 + min(dp[i][j + 1], \\\n                               dp[i + 1][j], dp[i + 1][j + 1])\n            ans = max(ans, dp[i][j])\n    return ans\nif __name__ == \"__main__\":\n    mat = [\n        [0, 1, 1, 0, 1],\n        [1, 1, 0, 1, 0],\n        [0, 1, 1, 1, 0],\n        [1, 1, 1, 1, 0],\n        [1, 1, 1, 1, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    print(maxSquare(mat))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/maximum-size-sub-matrix-with-all-1s-in-a-binary-matrix/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "// C++ program to find out the maximum length\n// of a side of a square sub-matrix with all 1s.\n#include <bits/stdc++.h>\nusing namespace std;\nint maxSquare(vector<vector<int>> &mat) {\n    int n = mat.size(), m = mat[0].size();\n    int ans = 0;\n    // Create 1d array\n    vector<int> dp(n + 1, 0);\n    // variable to store the value of\n    // {i, j+1} as its value will be\n    // lost while setting dp[i][j+1].\n    int diagonal = 0;\n    // Traverse column by column\n    for (int j = m - 1; j >= 0; j--) {\n        for (int i = n - 1; i >= 0; i--) {\n            int tmp = dp[i];\n            // If square cannot be formed\n            if (mat[i][j] == 0) {\n                dp[i] = 0;\n            }\n            else {\n                dp[i] = 1 + min({dp[i], diagonal, dp[i + 1]});\n            }\n            diagonal = tmp;\n            ans = max(ans, dp[i]);\n        }\n    }\n    return ans;\n}\nint main() {\n    vector<vector<int>> mat =\n                    {{0, 1, 1, 0, 1},\n                     {1, 1, 0, 1, 0},\n                     {0, 1, 1, 1, 0},\n                     {1, 1, 1, 1, 0},\n                     {1, 1, 1, 1, 1},\n                     {0, 0, 0, 0, 0}};\n    cout << maxSquare(mat) << endl;\n    return 0;\n}",
    "code_without_comments": "\n\n#include <bits/stdc++.h>\nusing namespace std;\nint maxSquare(vector<vector<int>> &mat) {\n    int n = mat.size(), m = mat[0].size();\n    int ans = 0;\n\n    vector<int> dp(n + 1, 0);\n\n\n\n    int diagonal = 0;\n\n    for (int j = m - 1; j >= 0; j--) {\n        for (int i = n - 1; i >= 0; i--) {\n            int tmp = dp[i];\n\n            if (mat[i][j] == 0) {\n                dp[i] = 0;\n            }\n            else {\n                dp[i] = 1 + min({dp[i], diagonal, dp[i + 1]});\n            }\n            diagonal = tmp;\n            ans = max(ans, dp[i]);\n        }\n    }\n    return ans;\n}\nint main() {\n    vector<vector<int>> mat =\n                    {{0, 1, 1, 0, 1},\n                     {1, 1, 0, 1, 0},\n                     {0, 1, 1, 1, 0},\n                     {1, 1, 1, 1, 0},\n                     {1, 1, 1, 1, 1},\n                     {0, 0, 0, 0, 0}};\n    cout << maxSquare(mat) << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/maximum-size-sub-matrix-with-all-1s-in-a-binary-matrix/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "# Python program to find out the maximum length\n# of a side of a square sub-matrix with all 1s.\ndef maxSquare(mat):\n    n, m = len(mat), len(mat[0])\n    ans = 0\n    # Create 1d array\n    dp = [0] * (n + 1)\n    # variable to store the value of\n    # {i, j+1} as its value will be\n    # lost while setting dp[i][j+1].\n    diagonal = 0\n    # Traverse column by column\n    for j in range(m - 1, -1, -1):\n        for i in range(n - 1, -1, -1):\n            tmp = dp[i]\n            # If square cannot be formed\n            if mat[i][j] == 0:\n                dp[i] = 0\n            else:\n                dp[i] = 1 + min(dp[i], \\\n                                diagonal, dp[i + 1])\n            diagonal = tmp\n            ans = max(ans, dp[i])\n    return ans\nif __name__ == \"__main__\":\n    mat = [\n        [0, 1, 1, 0, 1],\n        [1, 1, 0, 1, 0],\n        [0, 1, 1, 1, 0],\n        [1, 1, 1, 1, 0],\n        [1, 1, 1, 1, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    print(maxSquare(mat))",
    "code_without_comments": "\n\ndef maxSquare(mat):\n    n, m = len(mat), len(mat[0])\n    ans = 0\n\n    dp = [0] * (n + 1)\n\n\n\n    diagonal = 0\n\n    for j in range(m - 1, -1, -1):\n        for i in range(n - 1, -1, -1):\n            tmp = dp[i]\n\n            if mat[i][j] == 0:\n                dp[i] = 0\n            else:\n                dp[i] = 1 + min(dp[i], \\\n                                diagonal, dp[i + 1])\n            diagonal = tmp\n            ans = max(ans, dp[i])\n    return ans\nif __name__ == \"__main__\":\n    mat = [\n        [0, 1, 1, 0, 1],\n        [1, 1, 0, 1, 0],\n        [0, 1, 1, 1, 0],\n        [1, 1, 1, 1, 0],\n        [1, 1, 1, 1, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    print(maxSquare(mat))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/maximum-size-sub-matrix-with-all-1s-in-a-binary-matrix/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "// C++ program to find the lps\n#include <bits/stdc++.h>\nusing namespace std;\n// Returns the length of the longest\n// palindromic subsequence in seq\nint lps(const string& s, int low, int high) {\n    // Base case\n    if(low > high) return 0;\n    // If there is only 1 character\n    if (low == high)\n        return 1;\n    // If the first and last characters match\n    if (s[low] == s[high])\n        return lps(s, low + 1, high - 1) + 2;\n    // If the first and last characters do not match\n    return max(lps(s, low, high - 1), lps(s, low + 1, high));\n}\nint longestPalinSubseq(string &s) {\n    return lps(s, 0, s.size() - 1);\n}\nint main() {\n    string s = \"bbabcbcab\";\n    cout << longestPalinSubseq(s);\n    return 0;\n}",
    "code_without_comments": "\n#include <bits/stdc++.h>\nusing namespace std;\n\n\nint lps(const string& s, int low, int high) {\n\n    if(low > high) return 0;\n\n    if (low == high)\n        return 1;\n\n    if (s[low] == s[high])\n        return lps(s, low + 1, high - 1) + 2;\n\n    return max(lps(s, low, high - 1), lps(s, low + 1, high));\n}\nint longestPalinSubseq(string &s) {\n    return lps(s, 0, s.size() - 1);\n}\nint main() {\n    string s = \"bbabcbcab\";\n    cout << longestPalinSubseq(s);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/longest-palindromic-subsequence-dp-12/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "// C program to find the lps\n#include <stdio.h>\n#include <string.h>\n// Returns the length of the longest\n// palindromic subsequence in seq\nint lps(const char *s, int low, int high) {\n    // Base case\n    if (low > high) return 0;\n    // If there is only 1 character\n    if (low == high)\n        return 1;\n    // If the first and last characters match\n    if (s[low] == s[high])\n        return lps(s, low + 1, high - 1) + 2;\n    // If the first and last characters do not match\n  \tint a = lps(s, low, high - 1);\n  \tint b = lps(s, low + 1, high);\n    return (a > b)? a: b;\n}\nint longestPalinSubseq(char *s) {\n    int n = strlen(s);\n    return lps(s, 0, n - 1);\n}\nint main() {\n    char s[] = \"bbabcbcab\";\n    printf(\"%d\", longestPalinSubseq(s));\n    return 0;\n}",
    "code_without_comments": "\n#include <stdio.h>\n#include <string.h>\n\n\nint lps(const char *s, int low, int high) {\n\n    if (low > high) return 0;\n\n    if (low == high)\n        return 1;\n\n    if (s[low] == s[high])\n        return lps(s, low + 1, high - 1) + 2;\n\n  \tint a = lps(s, low, high - 1);\n  \tint b = lps(s, low + 1, high);\n    return (a > b)? a: b;\n}\nint longestPalinSubseq(char *s) {\n    int n = strlen(s);\n    return lps(s, 0, n - 1);\n}\nint main() {\n    char s[] = \"bbabcbcab\";\n    printf(\"%d\", longestPalinSubseq(s));\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/longest-palindromic-subsequence-dp-12/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "# Python program to find the lps\n# Returns the length of the longest\n# palindromic subsequence in seq\ndef lps(s, low, high):\n    # Base case\n    if low > high:\n        return 0\n    # If there is only 1 character\n    if low == high:\n        return 1\n    # If the first and last characters match\n    if s[low] == s[high]:\n        return lps(s, low + 1, high - 1) + 2\n    # If the first and last characters do not match\n    return max(lps(s, low, high - 1), lps(s, low + 1, high))\ndef longestPalinSubseq(s):\n    return lps(s, 0, len(s) - 1)\nif __name__ == \"__main__\":\n    s = \"bbabcbcab\"\n    print(longestPalinSubseq(s))",
    "code_without_comments": "\n\n\ndef lps(s, low, high):\n\n    if low > high:\n        return 0\n\n    if low == high:\n        return 1\n\n    if s[low] == s[high]:\n        return lps(s, low + 1, high - 1) + 2\n\n    return max(lps(s, low, high - 1), lps(s, low + 1, high))\ndef longestPalinSubseq(s):\n    return lps(s, 0, len(s) - 1)\nif __name__ == \"__main__\":\n    s = \"bbabcbcab\"\n    print(longestPalinSubseq(s))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/longest-palindromic-subsequence-dp-12/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "// C++ program to find the lps\n#include <bits/stdc++.h>\nusing namespace std;\n// Returns the length of the longest\n// palindromic subsequence in seq\nint lps(const string& s, int low, int high,\n                        vector<vector<int>> &memo) {\n    // Base case\n    if(low > high) return 0;\n    // If there is only 1 character\n    if (low == high)\n        return 1;\n    // If the value is already calculated\n    if(memo[low][high] != -1)\n        return memo[low][high];\n    // If the first and last characters match\n    if (s[low] == s[high])\n        return memo[low][high] =\n                lps(s, low + 1, high - 1, memo) + 2;\n    // If the first and last characters do not match\n    return memo[low][high] =\n      \t\t\tmax(lps(s, low, high - 1, memo),\n                         lps(s, low + 1, high, memo));\n}\nint longestPalinSubseq(string &s) {\n    // create memoization table\n    vector<vector<int>> memo(s.size(),\n                    vector<int>(s.size(), -1));\n    return lps(s, 0, s.size() - 1, memo);\n}\nint main() {\n    string s = \"bbabcbcab\";\n    cout << longestPalinSubseq(s);\n    return 0;\n}",
    "code_without_comments": "\n#include <bits/stdc++.h>\nusing namespace std;\n\n\nint lps(const string& s, int low, int high,\n                        vector<vector<int>> &memo) {\n\n    if(low > high) return 0;\n\n    if (low == high)\n        return 1;\n\n    if(memo[low][high] != -1)\n        return memo[low][high];\n\n    if (s[low] == s[high])\n        return memo[low][high] =\n                lps(s, low + 1, high - 1, memo) + 2;\n\n    return memo[low][high] =\n      \t\t\tmax(lps(s, low, high - 1, memo),\n                         lps(s, low + 1, high, memo));\n}\nint longestPalinSubseq(string &s) {\n\n    vector<vector<int>> memo(s.size(),\n                    vector<int>(s.size(), -1));\n    return lps(s, 0, s.size() - 1, memo);\n}\nint main() {\n    string s = \"bbabcbcab\";\n    cout << longestPalinSubseq(s);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/longest-palindromic-subsequence-dp-12/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "# Python program to find the lps\n# Returns the length of the longest\n# palindromic subsequence in seq\ndef lps(s, low, high, memo):\n    # Base case\n    if low > high:\n        return 0\n    # If there is only 1 character\n    if low == high:\n        return 1\n    # If the value is already calculated\n    if memo[low][high] != -1:\n        return memo[low][high]\n    # If the first and last characters match\n    if s[low] == s[high]:\n        memo[low][high] = lps(s, low + 1, high - 1, memo) + 2\n    else:\n        # If the first and last characters do not match\n        memo[low][high] = max(lps(s, low, high - 1, memo),\n                              lps(s, low + 1, high, memo))\n    return memo[low][high]\ndef longestPalinSubseq(s):\n    n = len(s)\n    memo = [[-1 for _ in range(n)] for _ in range(n)]\n    return lps(s, 0, n - 1, memo)\nif __name__ == \"__main__\":\n    s = \"bbabcbcab\"\n    print(longestPalinSubseq(s))",
    "code_without_comments": "\n\n\ndef lps(s, low, high, memo):\n\n    if low > high:\n        return 0\n\n    if low == high:\n        return 1\n\n    if memo[low][high] != -1:\n        return memo[low][high]\n\n    if s[low] == s[high]:\n        memo[low][high] = lps(s, low + 1, high - 1, memo) + 2\n    else:\n\n        memo[low][high] = max(lps(s, low, high - 1, memo),\n                              lps(s, low + 1, high, memo))\n    return memo[low][high]\ndef longestPalinSubseq(s):\n    n = len(s)\n    memo = [[-1 for _ in range(n)] for _ in range(n)]\n    return lps(s, 0, n - 1, memo)\nif __name__ == \"__main__\":\n    s = \"bbabcbcab\"\n    print(longestPalinSubseq(s))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/longest-palindromic-subsequence-dp-12/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "// C++ program to find the lps\n#include <bits/stdc++.h>\nusing namespace std;\n// Function to find the LPS\nint longestPalinSubseq(string& s) {\n    int n = s.length();\n    // Create a DP table\n    vector<vector<int>> dp(n, vector<int>(n));\n    // Build the DP table for all the substrings\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = i; j < n; j++) {\n            // If there is only one character\n            if(i == j){\n                dp[i][j] = 1;\n                continue;\n            }\n            // If characters at position i and j are the same\n            if (s[i] == s[j]) {\n                if(i + 1 == j) dp[i][j] = 2;\n                else dp[i][j] = dp[i + 1][j - 1] + 2;\n            }\n            else {\n                // Otherwise, take the maximum length\n                // from either excluding i or j\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    // The final answer is stored in dp[0][n-1]\n    return dp[0][n - 1];\n}\nint main() {\n    string s = \"bbabcbcab\";\n    cout << longestPalinSubseq(s);\n    return 0;\n}",
    "code_without_comments": "\n#include <bits/stdc++.h>\nusing namespace std;\n\nint longestPalinSubseq(string& s) {\n    int n = s.length();\n\n    vector<vector<int>> dp(n, vector<int>(n));\n\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = i; j < n; j++) {\n\n            if(i == j){\n                dp[i][j] = 1;\n                continue;\n            }\n\n            if (s[i] == s[j]) {\n                if(i + 1 == j) dp[i][j] = 2;\n                else dp[i][j] = dp[i + 1][j - 1] + 2;\n            }\n            else {\n\n\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n\n    return dp[0][n - 1];\n}\nint main() {\n    string s = \"bbabcbcab\";\n    cout << longestPalinSubseq(s);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/longest-palindromic-subsequence-dp-12/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "# Python program to find the lps\n# Function to find the LPS\ndef longestPalinSubseq(s):\n    n = len(s)\n    # Create a DP table\n    dp = [[0] * n for _ in range(n)]\n    # Build the DP table for all the substrings\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n):\n            # If there is only one character\n            if i == j:\n                dp[i][j] = 1\n                continue\n            # If characters at position i and j are the same\n            if s[i] == s[j]:\n                if i + 1 == j:\n                    dp[i][j] = 2\n                else:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                # Otherwise, take the maximum length\n                # from either excluding i or j\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    # The final answer is stored in dp[0][n-1]\n    return dp[0][n - 1]\nif __name__ == \"__main__\":\n    s = \"bbabcbcab\"\n    print(longestPalinSubseq(s))",
    "code_without_comments": "\n\ndef longestPalinSubseq(s):\n    n = len(s)\n\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n):\n\n            if i == j:\n                dp[i][j] = 1\n                continue\n\n            if s[i] == s[j]:\n                if i + 1 == j:\n                    dp[i][j] = 2\n                else:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n\n\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n\n    return dp[0][n - 1]\nif __name__ == \"__main__\":\n    s = \"bbabcbcab\"\n    print(longestPalinSubseq(s))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/longest-palindromic-subsequence-dp-12/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "// C++ program to find longest\n// palindromic subsequence\n#include <bits/stdc++.h>\nusing namespace std;\n// Function to find the length of the lps\nint longestPalinSubseq(const string &s) {\n    int n = s.size();\n    // Create two vectors: one for the current state (dp)\n    // and one for the previous state (dpPrev)\n    vector<int> curr(n), prev(n);\n    // Loop through the string in reverse (starting from the end)\n    for (int i = n - 1; i >= 0; --i){\n        // Initialize the current state of dp\n        curr[i] = 1;\n        // Loop through the characters ahead of i\n        for (int j = i + 1; j < n; ++j){\n            // If the characters at i and j are the same\n            if (s[i] == s[j]){\n                // Add 2 to the length of the palindrome between them\n                curr[j] = prev[j - 1] + 2;\n            }\n            else{\n                // Take the maximum between excluding either i or j\n                curr[j] = max(prev[j], curr[j - 1]);\n            }\n        }\n        // Update previous to the current state of dp\n        prev = curr;\n    }\n    return curr[n-1];\n}\nint main() {\n    string s = \"bbabcbcab\";\n    cout << longestPalinSubseq(s);\n    return 0;\n}",
    "code_without_comments": "\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint longestPalinSubseq(const string &s) {\n    int n = s.size();\n\n\n    vector<int> curr(n), prev(n);\n\n    for (int i = n - 1; i >= 0; --i){\n\n        curr[i] = 1;\n\n        for (int j = i + 1; j < n; ++j){\n\n            if (s[i] == s[j]){\n\n                curr[j] = prev[j - 1] + 2;\n            }\n            else{\n\n                curr[j] = max(prev[j], curr[j - 1]);\n            }\n        }\n\n        prev = curr;\n    }\n    return curr[n-1];\n}\nint main() {\n    string s = \"bbabcbcab\";\n    cout << longestPalinSubseq(s);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/longest-palindromic-subsequence-dp-12/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "# Python program to find the length of the lps\n# Function to find the length of the lps\ndef longestPalinSubseq(s):\n    n = len(s)\n    # Create two arrays: one for the current state (dp)\n    # and one for the previous state (dpPrev)\n    curr = [0] * n\n    prev = [0] * n\n    # Loop through the string in reverse (starting from the end)\n    for i in range(n - 1, -1, -1):\n        # Initialize the current state of dp\n        curr[i] = 1\n        # Loop through the characters ahead of i\n        for j in range(i + 1, n):\n            # If the characters at i and j are the same\n            if s[i] == s[j]:\n                # Add 2 to the length of the palindrome between them\n                curr[j] = prev[j - 1] + 2\n            else:\n                # Take the maximum between excluding either i or j\n                curr[j] = max(prev[j], curr[j - 1])\n        # Update previous to the current state of dp\n        prev = curr[:]\n    return curr[n - 1]\nif __name__ == \"__main__\":\n    s = \"bbabcbcab\"\n    print(longestPalinSubseq(s))",
    "code_without_comments": "\n\ndef longestPalinSubseq(s):\n    n = len(s)\n\n\n    curr = [0] * n\n    prev = [0] * n\n\n    for i in range(n - 1, -1, -1):\n\n        curr[i] = 1\n\n        for j in range(i + 1, n):\n\n            if s[i] == s[j]:\n\n                curr[j] = prev[j - 1] + 2\n            else:\n\n                curr[j] = max(prev[j], curr[j - 1])\n\n        prev = curr[:]\n    return curr[n - 1]\nif __name__ == \"__main__\":\n    s = \"bbabcbcab\"\n    print(longestPalinSubseq(s))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/longest-palindromic-subsequence-dp-12/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "#include <bits/stdc++.h>\nusing namespace std;\n// Function to evaluate a boolean expression given two operands and an operator\nbool evaluate(bool left, bool right, char op) {\n    if (op == '&') return left & right;\n    if (op == '|') return left | right;\n    return left ^ right; // for '^'\n}\n// Recursive function to count the number of ways s[i...j] can evaluate to 'req'\nint countRecur(int i, int j, bool req, string &s) {\n    // Base case: if the substring is a single operand (T/F)\n    if (i == j) {\n        return (req == (s[i] == 'T')) ? 1 : 0;\n    }\n    int ways = 0;\n    // Partition only at operator positions  they lie at odd indices\n    for (int k = i + 1; k < j; k += 2) {\n        // Count ways for left and right subexpressions\n        int leftTrue  = countRecur(i, k - 1, true, s);\n        int leftFalse = countRecur(i, k - 1, false, s);\n        int rightTrue  = countRecur(k + 1, j, true, s);\n        int rightFalse = countRecur(k + 1, j, false, s);\n        // Combine results based on operator at position k\n        if (evaluate(true, true, s[k]) == req)\n            ways += leftTrue * rightTrue;\n        if (evaluate(true, false, s[k]) == req)\n            ways += leftTrue * rightFalse;\n        if (evaluate(false, true, s[k]) == req)\n            ways += leftFalse * rightTrue;\n        if (evaluate(false, false, s[k]) == req)\n            ways += leftFalse * rightFalse;\n    }\n    return ways;\n}\n// Wrapper function: returns number of ways to evaluate entire expression to True\nint countWays(string s) {\n    int n = s.length();\n    return countRecur(0, n - 1, true, s);\n}\nint main() {\n    string s = \"T|T&F^T\";\n    cout << countWays(s);\n    return 0;\n}",
    "code_without_comments": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool evaluate(bool left, bool right, char op) {\n    if (op == '&') return left & right;\n    if (op == '|') return left | right;\n    return left ^ right;\n}\n\nint countRecur(int i, int j, bool req, string &s) {\n\n    if (i == j) {\n        return (req == (s[i] == 'T')) ? 1 : 0;\n    }\n    int ways = 0;\n\n    for (int k = i + 1; k < j; k += 2) {\n\n        int leftTrue  = countRecur(i, k - 1, true, s);\n        int leftFalse = countRecur(i, k - 1, false, s);\n        int rightTrue  = countRecur(k + 1, j, true, s);\n        int rightFalse = countRecur(k + 1, j, false, s);\n\n        if (evaluate(true, true, s[k]) == req)\n            ways += leftTrue * rightTrue;\n        if (evaluate(true, false, s[k]) == req)\n            ways += leftTrue * rightFalse;\n        if (evaluate(false, true, s[k]) == req)\n            ways += leftFalse * rightTrue;\n        if (evaluate(false, false, s[k]) == req)\n            ways += leftFalse * rightFalse;\n    }\n    return ways;\n}\n\nint countWays(string s) {\n    int n = s.length();\n    return countRecur(0, n - 1, true, s);\n}\nint main() {\n    string s = \"T|T&F^T\";\n    cout << countWays(s);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/boolean-parenthesization-problem-dp-37/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "def evaluate(b1, b2, op):\n    if op == '&':\n        return b1 & b2\n    elif op == '|':\n        return b1 | b2\n    return b1 ^ b2\n# Function which returns the number of ways\n# s[i:j] evaluates to req\ndef countRecur(i, j, req, s):\n    # Base case: When we have only one character\n    if i == j:\n        return 1 if req == (s[i] == 'T') else 0\n    ans = 0\n    # Loop through the operators (every other character is an operator)\n    for k in range(i + 1, j, 2):\n        # Count ways in which left and right substrings\n        # evaluate to True or False\n        leftTrue = countRecur(i, k - 1, True, s)\n        leftFalse = countRecur(i, k - 1, False, s)\n        rightTrue = countRecur(k + 1, j, True, s)\n        rightFalse = countRecur(k + 1, j, False, s)\n        # Check the result of applying the operator at position\n        # `k` to the subproblems\n        if evaluate(True, True, s[k]) == req:\n            ans += leftTrue * rightTrue\n        if evaluate(True, False, s[k]) == req:\n            ans += leftTrue * rightFalse\n        if evaluate(False, True, s[k]) == req:\n            ans += leftFalse * rightTrue\n        if evaluate(False, False, s[k]) == req:\n            ans += leftFalse * rightFalse\n    return ans\n# Function to count the number of ways the expression\n# evaluates to True\ndef countWays(s):\n    n = len(s)\n    return countRecur(0, n - 1, True, s)\nif __name__ == \"__main__\":\n    s = \"T|T&F^T\"\n    print(countWays(s))",
    "code_without_comments": "def evaluate(b1, b2, op):\n    if op == '&':\n        return b1 & b2\n    elif op == '|':\n        return b1 | b2\n    return b1 ^ b2\n\n\ndef countRecur(i, j, req, s):\n\n    if i == j:\n        return 1 if req == (s[i] == 'T') else 0\n    ans = 0\n\n    for k in range(i + 1, j, 2):\n\n\n        leftTrue = countRecur(i, k - 1, True, s)\n        leftFalse = countRecur(i, k - 1, False, s)\n        rightTrue = countRecur(k + 1, j, True, s)\n        rightFalse = countRecur(k + 1, j, False, s)\n\n\n        if evaluate(True, True, s[k]) == req:\n            ans += leftTrue * rightTrue\n        if evaluate(True, False, s[k]) == req:\n            ans += leftTrue * rightFalse\n        if evaluate(False, True, s[k]) == req:\n            ans += leftFalse * rightTrue\n        if evaluate(False, False, s[k]) == req:\n            ans += leftFalse * rightFalse\n    return ans\n\n\ndef countWays(s):\n    n = len(s)\n    return countRecur(0, n - 1, True, s)\nif __name__ == \"__main__\":\n    s = \"T|T&F^T\"\n    print(countWays(s))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/boolean-parenthesization-problem-dp-37/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "#include <bits/stdc++.h>\nusing namespace std;\n// Function to evaluate a\n// boolean condition.\nbool evaluate(int b1, int b2, char op)\n{\n    if (op == '&')\n    {\n        return b1 & b2;\n    }\n    else if (op == '|')\n    {\n        return b1 | b2;\n    }\n    return b1 ^ b2;\n}\n// Function which returns the number of ways\n// s[i:j] evaluates to req.\nint countRecur(int i, int j, int req, string &s, vector<vector<vector<int>>> &memo)\n{\n    // Base case:\n    if (i == j)\n    {\n        return (req == (s[i] == 'T')) ? 1 : 0;\n    }\n    // If value is memoized\n    if (memo[i][j][req] != -1)\n        return memo[i][j][req];\n    int ans = 0;\n    for (int k = i + 1; k < j; k += 2)\n    {\n        // Count Ways in which left substring\n        // evaluates to true and false.\n        int leftTrue = countRecur(i, k - 1, 1, s, memo);\n        int leftFalse = countRecur(i, k - 1, 0, s, memo);\n        // Count Ways in which right substring\n        // evaluates to true and false.\n        int rightTrue = countRecur(k + 1, j, 1, s, memo);\n        int rightFalse = countRecur(k + 1, j, 0, s, memo);\n        // Check if the combinations results\n        // to req.\n        if (evaluate(1, 1, s[k]) == req)\n        {\n            ans += leftTrue * rightTrue;\n        }\n        if (evaluate(1, 0, s[k]) == req)\n        {\n            ans += leftTrue * rightFalse;\n        }\n        if (evaluate(0, 1, s[k]) == req)\n        {\n            ans += leftFalse * rightTrue;\n        }\n        if (evaluate(0, 0, s[k]) == req)\n        {\n            ans += leftFalse * rightFalse;\n        }\n    }\n    return memo[i][j][req] = ans;\n}\nint countWays(string s)\n{\n    int n = s.length();\n    vector<vector<vector<int>>> memo(n, vector<vector<int>>(n, vector<int>(2, -1)));\n    return countRecur(0, n - 1, 1, s, memo);\n}\nint main()\n{\n    string s = \"T|T&F^T\";\n    cout << countWays(s);\n    return 0;\n}",
    "code_without_comments": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nbool evaluate(int b1, int b2, char op)\n{\n    if (op == '&')\n    {\n        return b1 & b2;\n    }\n    else if (op == '|')\n    {\n        return b1 | b2;\n    }\n    return b1 ^ b2;\n}\n\n\nint countRecur(int i, int j, int req, string &s, vector<vector<vector<int>>> &memo)\n{\n\n    if (i == j)\n    {\n        return (req == (s[i] == 'T')) ? 1 : 0;\n    }\n\n    if (memo[i][j][req] != -1)\n        return memo[i][j][req];\n    int ans = 0;\n    for (int k = i + 1; k < j; k += 2)\n    {\n\n\n        int leftTrue = countRecur(i, k - 1, 1, s, memo);\n        int leftFalse = countRecur(i, k - 1, 0, s, memo);\n\n\n        int rightTrue = countRecur(k + 1, j, 1, s, memo);\n        int rightFalse = countRecur(k + 1, j, 0, s, memo);\n\n\n        if (evaluate(1, 1, s[k]) == req)\n        {\n            ans += leftTrue * rightTrue;\n        }\n        if (evaluate(1, 0, s[k]) == req)\n        {\n            ans += leftTrue * rightFalse;\n        }\n        if (evaluate(0, 1, s[k]) == req)\n        {\n            ans += leftFalse * rightTrue;\n        }\n        if (evaluate(0, 0, s[k]) == req)\n        {\n            ans += leftFalse * rightFalse;\n        }\n    }\n    return memo[i][j][req] = ans;\n}\nint countWays(string s)\n{\n    int n = s.length();\n    vector<vector<vector<int>>> memo(n, vector<vector<int>>(n, vector<int>(2, -1)));\n    return countRecur(0, n - 1, 1, s, memo);\n}\nint main()\n{\n    string s = \"T|T&F^T\";\n    cout << countWays(s);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/boolean-parenthesization-problem-dp-37/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "# Function to evaluate a\n# boolean condition.\ndef evaluate(b1, b2, op):\n    if op == '&':\n        return b1 & b2\n    elif op == '|':\n        return b1 | b2\n    return b1 ^ b2\n# Function which returns the number of ways\n# s[i:j] evaluates to req.\ndef countRecur(i, j, req, s, memo):\n    # Base case:\n    if i == j:\n        return 1 if req == (1 if s[i] == 'T' else 0) else 0\n    # If value is memoized\n    if memo[i][j][req] != -1:\n        return memo[i][j][req]\n    ans = 0\n    for k in range(i + 1, j, 2):\n        # Count Ways in which left substring\n        # evaluates to true and false.\n        left_true = countRecur(i, k - 1, 1, s, memo)\n        left_false = countRecur(i, k - 1, 0, s, memo)\n        # Count Ways in which right substring\n        # evaluates to true and false.\n        right_true = countRecur(k + 1, j, 1, s, memo)\n        right_false = countRecur(k + 1, j, 0, s, memo)\n        # Check if the combinations result\n        # to req.\n        if evaluate(1, 1, s[k]) == req:\n            ans += left_true * right_true\n        if evaluate(1, 0, s[k]) == req:\n            ans += left_true * right_false\n        if evaluate(0, 1, s[k]) == req:\n            ans += left_false * right_true\n        if evaluate(0, 0, s[k]) == req:\n            ans += left_false * right_false\n    memo[i][j][req] = ans\n    return ans\ndef countWays(s):\n    n = len(s)\n    memo = [[[-1 for _ in range(2)] for _ in range(n)] for _ in range(n)]\n    return countRecur(0, n - 1, 1, s, memo)\nif __name__ == \"__main__\":\n    s = \"T|T&F^T\"\n    print(countWays(s))",
    "code_without_comments": "\n\ndef evaluate(b1, b2, op):\n    if op == '&':\n        return b1 & b2\n    elif op == '|':\n        return b1 | b2\n    return b1 ^ b2\n\n\ndef countRecur(i, j, req, s, memo):\n\n    if i == j:\n        return 1 if req == (1 if s[i] == 'T' else 0) else 0\n\n    if memo[i][j][req] != -1:\n        return memo[i][j][req]\n    ans = 0\n    for k in range(i + 1, j, 2):\n\n\n        left_true = countRecur(i, k - 1, 1, s, memo)\n        left_false = countRecur(i, k - 1, 0, s, memo)\n\n\n        right_true = countRecur(k + 1, j, 1, s, memo)\n        right_false = countRecur(k + 1, j, 0, s, memo)\n\n\n        if evaluate(1, 1, s[k]) == req:\n            ans += left_true * right_true\n        if evaluate(1, 0, s[k]) == req:\n            ans += left_true * right_false\n        if evaluate(0, 1, s[k]) == req:\n            ans += left_false * right_true\n        if evaluate(0, 0, s[k]) == req:\n            ans += left_false * right_false\n    memo[i][j][req] = ans\n    return ans\ndef countWays(s):\n    n = len(s)\n    memo = [[[-1 for _ in range(2)] for _ in range(n)] for _ in range(n)]\n    return countRecur(0, n - 1, 1, s, memo)\nif __name__ == \"__main__\":\n    s = \"T|T&F^T\"\n    print(countWays(s))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/boolean-parenthesization-problem-dp-37/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "#include <bits/stdc++.h>\nusing namespace std;\n// Function to evaluate a boolean condition.\nbool evaluate(int b1, int b2, char op)\n{\n    if (op == '&')\n        return b1 & b2;\n    if (op == '|')\n        return b1 | b2;\n    return b1 ^ b2;\n}\n// Function to count ways to parenthesize the expression to get 'True'\nint countWays(string s)\n{\n    int n = s.length();\n    vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(2, 0)));\n    // Base case: Single operands (T or F)\n    for (int i = 0; i < n; i += 2)\n    {\n        dp[i][i][1] = (s[i] == 'T');\n        dp[i][i][0] = (s[i] == 'F');\n    }\n    // Iterate over different substring lengths\n    for (int len = 2; len < n; len += 2)\n    {\n        // len increases by 2 (odd indices are operators)\n        for (int i = 0; i < n - len; i += 2)\n        {\n            int j = i + len;\n            // Reset values for the current subproblem\n            dp[i][j][0] = dp[i][j][1] = 0;\n            for (int k = i + 1; k < j; k += 2)\n            { // Iterate over operators\n                char op = s[k];\n                int leftTrue = dp[i][k - 1][1], leftFalse = dp[i][k - 1][0];\n                int rightTrue = dp[k + 1][j][1], rightFalse = dp[k + 1][j][0];\n                // Count ways to get True or False\n                if (evaluate(1, 1, op))\n                    dp[i][j][1] += leftTrue * rightTrue;\n                if (evaluate(1, 0, op))\n                    dp[i][j][1] += leftTrue * rightFalse;\n                if (evaluate(0, 1, op))\n                    dp[i][j][1] += leftFalse * rightTrue;\n                if (evaluate(0, 0, op))\n                    dp[i][j][1] += leftFalse * rightFalse;\n                if (!evaluate(1, 1, op))\n                    dp[i][j][0] += leftTrue * rightTrue;\n                if (!evaluate(1, 0, op))\n                    dp[i][j][0] += leftTrue * rightFalse;\n                if (!evaluate(0, 1, op))\n                    dp[i][j][0] += leftFalse * rightTrue;\n                if (!evaluate(0, 0, op))\n                    dp[i][j][0] += leftFalse * rightFalse;\n            }\n        }\n    }\n    // Return ways to make entire expression True\n    return dp[0][n - 1][1];\n}\nint main()\n{\n    string s = \"T|T&F^T\";\n    cout << countWays(s) << endl;\n    return 0;\n}",
    "code_without_comments": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool evaluate(int b1, int b2, char op)\n{\n    if (op == '&')\n        return b1 & b2;\n    if (op == '|')\n        return b1 | b2;\n    return b1 ^ b2;\n}\n\nint countWays(string s)\n{\n    int n = s.length();\n    vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(2, 0)));\n\n    for (int i = 0; i < n; i += 2)\n    {\n        dp[i][i][1] = (s[i] == 'T');\n        dp[i][i][0] = (s[i] == 'F');\n    }\n\n    for (int len = 2; len < n; len += 2)\n    {\n\n        for (int i = 0; i < n - len; i += 2)\n        {\n            int j = i + len;\n\n            dp[i][j][0] = dp[i][j][1] = 0;\n            for (int k = i + 1; k < j; k += 2)\n            {\n                char op = s[k];\n                int leftTrue = dp[i][k - 1][1], leftFalse = dp[i][k - 1][0];\n                int rightTrue = dp[k + 1][j][1], rightFalse = dp[k + 1][j][0];\n\n                if (evaluate(1, 1, op))\n                    dp[i][j][1] += leftTrue * rightTrue;\n                if (evaluate(1, 0, op))\n                    dp[i][j][1] += leftTrue * rightFalse;\n                if (evaluate(0, 1, op))\n                    dp[i][j][1] += leftFalse * rightTrue;\n                if (evaluate(0, 0, op))\n                    dp[i][j][1] += leftFalse * rightFalse;\n                if (!evaluate(1, 1, op))\n                    dp[i][j][0] += leftTrue * rightTrue;\n                if (!evaluate(1, 0, op))\n                    dp[i][j][0] += leftTrue * rightFalse;\n                if (!evaluate(0, 1, op))\n                    dp[i][j][0] += leftFalse * rightTrue;\n                if (!evaluate(0, 0, op))\n                    dp[i][j][0] += leftFalse * rightFalse;\n            }\n        }\n    }\n\n    return dp[0][n - 1][1];\n}\nint main()\n{\n    string s = \"T|T&F^T\";\n    cout << countWays(s) << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/boolean-parenthesization-problem-dp-37/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "/*package whatever //do not write package name here */\nimport java.io.*;\nclass GfG {\n    static boolean evaluate(int b1, int b2, char op)\n    {\n        if (op == '&')\n            return (b1 & b2) == 1;\n        if (op == '|')\n            return (b1 | b2) == 1;\n        return (b1 ^ b2) == 1;\n    }\n    static int countWays(String s)\n    {\n        int n = s.length();\n        int[][][] dp = new int[n][n][2];\n        for (int i = 0; i < n; i += 2) {\n            dp[i][i][1] = (s.charAt(i) == 'T') ? 1 : 0;\n            dp[i][i][0] = (s.charAt(i) == 'F') ? 1 : 0;\n        }\n        for (int len = 2; len < n; len += 2) {\n            for (int i = 0; i < n - len; i += 2) {\n                int j = i + len;\n                dp[i][j][0] = dp[i][j][1] = 0;\n                for (int k = i + 1; k < j; k += 2) {\n                    char op = s.charAt(k);\n                    int leftTrue = dp[i][k - 1][1],\n                        leftFalse = dp[i][k - 1][0];\n                    int rightTrue = dp[k + 1][j][1],\n                        rightFalse = dp[k + 1][j][0];\n                    if (evaluate(1, 1, op))\n                        dp[i][j][1] += leftTrue * rightTrue;\n                    if (evaluate(1, 0, op))\n                        dp[i][j][1]\n                            += leftTrue * rightFalse;\n                    if (evaluate(0, 1, op))\n                        dp[i][j][1]\n                            += leftFalse * rightTrue;\n                    if (evaluate(0, 0, op))\n                        dp[i][j][1]\n                            += leftFalse * rightFalse;\n                    if (!evaluate(1, 1, op))\n                        dp[i][j][0] += leftTrue * rightTrue;\n                    if (!evaluate(1, 0, op))\n                        dp[i][j][0]\n                            += leftTrue * rightFalse;\n                    if (!evaluate(0, 1, op))\n                        dp[i][j][0]\n                            += leftFalse * rightTrue;\n                    if (!evaluate(0, 0, op))\n                        dp[i][j][0]\n                            += leftFalse * rightFalse;\n                }\n            }\n        }\n        return dp[0][n - 1][1];\n    }\n    public static void main(String[] args)\n    {\n        String s = \"T|T&F^T\";\n        System.out.println(countWays(s));\n    }\n}",
    "code_without_comments": "/*package whatever //do not write package name here */\nimport java.io.*;\nclass GfG {\n    static boolean evaluate(int b1, int b2, char op)\n    {\n        if (op == '&')\n            return (b1 & b2) == 1;\n        if (op == '|')\n            return (b1 | b2) == 1;\n        return (b1 ^ b2) == 1;\n    }\n    static int countWays(String s)\n    {\n        int n = s.length();\n        int[][][] dp = new int[n][n][2];\n        for (int i = 0; i < n; i += 2) {\n            dp[i][i][1] = (s.charAt(i) == 'T') ? 1 : 0;\n            dp[i][i][0] = (s.charAt(i) == 'F') ? 1 : 0;\n        }\n        for (int len = 2; len < n; len += 2) {\n            for (int i = 0; i < n - len; i += 2) {\n                int j = i + len;\n                dp[i][j][0] = dp[i][j][1] = 0;\n                for (int k = i + 1; k < j; k += 2) {\n                    char op = s.charAt(k);\n                    int leftTrue = dp[i][k - 1][1],\n                        leftFalse = dp[i][k - 1][0];\n                    int rightTrue = dp[k + 1][j][1],\n                        rightFalse = dp[k + 1][j][0];\n                    if (evaluate(1, 1, op))\n                        dp[i][j][1] += leftTrue * rightTrue;\n                    if (evaluate(1, 0, op))\n                        dp[i][j][1]\n                            += leftTrue * rightFalse;\n                    if (evaluate(0, 1, op))\n                        dp[i][j][1]\n                            += leftFalse * rightTrue;\n                    if (evaluate(0, 0, op))\n                        dp[i][j][1]\n                            += leftFalse * rightFalse;\n                    if (!evaluate(1, 1, op))\n                        dp[i][j][0] += leftTrue * rightTrue;\n                    if (!evaluate(1, 0, op))\n                        dp[i][j][0]\n                            += leftTrue * rightFalse;\n                    if (!evaluate(0, 1, op))\n                        dp[i][j][0]\n                            += leftFalse * rightTrue;\n                    if (!evaluate(0, 0, op))\n                        dp[i][j][0]\n                            += leftFalse * rightFalse;\n                }\n            }\n        }\n        return dp[0][n - 1][1];\n    }\n    public static void main(String[] args)\n    {\n        String s = \"T|T&F^T\";\n        System.out.println(countWays(s));\n    }\n}",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/boolean-parenthesization-problem-dp-37/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "def evaluate(b1, b2, op):\n    if op == '&':\n        return b1 & b2\n    if op == '|':\n        return b1 | b2\n    return b1 ^ b2\ndef countWays(s):\n    n = len(s)\n    dp = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    # Base case: Single operands (T or F)\n    for i in range(0, n, 2):\n        dp[i][i][1] = 1 if s[i] == 'T' else 0\n        dp[i][i][0] = 1 if s[i] == 'F' else 0\n    # Iterate over different substring lengths\n    for length in range(2, n, 2):  # length increases by 2 (odd indices are operators)\n        for i in range(0, n - length, 2):\n            j = i + length\n            # Reset values for the current subproblem\n            dp[i][j][0] = dp[i][j][1] = 0\n            for k in range(i + 1, j, 2):  # Iterate over operators\n                op = s[k]\n                leftTrue, leftFalse = dp[i][k - 1][1], dp[i][k - 1][0]\n                rightTrue, rightFalse = dp[k + 1][j][1], dp[k + 1][j][0]\n                # Count ways to get True or False\n                if evaluate(1, 1, op):\n                    dp[i][j][1] += leftTrue * rightTrue\n                if evaluate(1, 0, op):\n                    dp[i][j][1] += leftTrue * rightFalse\n                if evaluate(0, 1, op):\n                    dp[i][j][1] += leftFalse * rightTrue\n                if evaluate(0, 0, op):\n                    dp[i][j][1] += leftFalse * rightFalse\n                if not evaluate(1, 1, op):\n                    dp[i][j][0] += leftTrue * rightTrue\n                if not evaluate(1, 0, op):\n                    dp[i][j][0] += leftTrue * rightFalse\n                if not evaluate(0, 1, op):\n                    dp[i][j][0] += leftFalse * rightTrue\n                if not evaluate(0, 0, op):\n                    dp[i][j][0] += leftFalse * rightFalse\n    return dp[0][n - 1][1]  # Return ways to make entire expression True\nif __name__ == \"__main__\":\n    s = \"T|T&F^T\"\n    print(countWays(s))",
    "code_without_comments": "def evaluate(b1, b2, op):\n    if op == '&':\n        return b1 & b2\n    if op == '|':\n        return b1 | b2\n    return b1 ^ b2\ndef countWays(s):\n    n = len(s)\n    dp = [[[0, 0] for _ in range(n)] for _ in range(n)]\n\n    for i in range(0, n, 2):\n        dp[i][i][1] = 1 if s[i] == 'T' else 0\n        dp[i][i][0] = 1 if s[i] == 'F' else 0\n\n    for length in range(2, n, 2):\n        for i in range(0, n - length, 2):\n            j = i + length\n\n            dp[i][j][0] = dp[i][j][1] = 0\n            for k in range(i + 1, j, 2):\n                op = s[k]\n                leftTrue, leftFalse = dp[i][k - 1][1], dp[i][k - 1][0]\n                rightTrue, rightFalse = dp[k + 1][j][1], dp[k + 1][j][0]\n\n                if evaluate(1, 1, op):\n                    dp[i][j][1] += leftTrue * rightTrue\n                if evaluate(1, 0, op):\n                    dp[i][j][1] += leftTrue * rightFalse\n                if evaluate(0, 1, op):\n                    dp[i][j][1] += leftFalse * rightTrue\n                if evaluate(0, 0, op):\n                    dp[i][j][1] += leftFalse * rightFalse\n                if not evaluate(1, 1, op):\n                    dp[i][j][0] += leftTrue * rightTrue\n                if not evaluate(1, 0, op):\n                    dp[i][j][0] += leftTrue * rightFalse\n                if not evaluate(0, 1, op):\n                    dp[i][j][0] += leftFalse * rightTrue\n                if not evaluate(0, 0, op):\n                    dp[i][j][0] += leftFalse * rightFalse\n    return dp[0][n - 1][1]\nif __name__ == \"__main__\":\n    s = \"T|T&F^T\"\n    print(countWays(s))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/boolean-parenthesization-problem-dp-37/",
    "complexity_weight": 3.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include<vector>\nusing namespace std;\nclass Node {\npublic:\n    int data;\n    Node *left, *right;\n    // Constructor to initialize a new node\n    Node(int value) {\n        data = value;\n        left = nullptr;\n        right = nullptr;\n    }\n};\nvoid levelOrderRec(Node* root, int level, vector<vector<int>>& res) {\n    // Base case\n    if (root == nullptr) return;\n    // Add a new level to the result if needed\n    if (res.size() <= level)\n        res.push_back({});\n    // Add current node's data to its corresponding level\n    res[level].push_back(root->data);\n    // Recur for left and right children\n    levelOrderRec(root->left, level + 1, res);\n    levelOrderRec(root->right, level + 1, res);\n}\n// Function to perform level order traversal\nvector<vector<int>> levelOrder(Node* root) {\n    // Stores the result level by level\n    vector<vector<int>> res;\n    levelOrderRec(root, 0, res);\n    return res;\n}\nint main() {\n    //      5\n    //     / \\\n    //   12   13\n    //   /  \\    \\\n    //  7    14   2\n    // / \\  /  \\  / \\\n    //17 23 27 3  8  11\n    Node* root = new Node(5);\n    root->left = new Node(12);\n    root->right = new Node(13);\n    root->left->left = new Node(7);\n    root->left->right = new Node(14);\n    root->right->right = new Node(2);\n    root->left->left->left = new Node(17);\n    root->left->left->right = new Node(23);\n    root->left->right->left = new Node(27);\n    root->left->right->right = new Node(3);\n    root->right->right->left = new Node(8);\n    root->right->right->right = new Node(11);\n    vector<vector<int>> res = levelOrder(root);\n    for (vector<int> level : res) {\n        for (int val : level) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include<vector>\nusing namespace std;\nclass Node {\npublic:\n    int data;\n    Node *left, *right;\n\n    Node(int value) {\n        data = value;\n        left = nullptr;\n        right = nullptr;\n    }\n};\nvoid levelOrderRec(Node* root, int level, vector<vector<int>>& res) {\n\n    if (root == nullptr) return;\n\n    if (res.size() <= level)\n        res.push_back({});\n\n    res[level].push_back(root->data);\n\n    levelOrderRec(root->left, level + 1, res);\n    levelOrderRec(root->right, level + 1, res);\n}\n\nvector<vector<int>> levelOrder(Node* root) {\n\n    vector<vector<int>> res;\n    levelOrderRec(root, 0, res);\n    return res;\n}\nint main() {\n\n\n\n\n\n\n\n    Node* root = new Node(5);\n    root->left = new Node(12);\n    root->right = new Node(13);\n    root->left->left = new Node(7);\n    root->left->right = new Node(14);\n    root->right->right = new Node(2);\n    root->left->left->left = new Node(17);\n    root->left->left->right = new Node(23);\n    root->left->right->left = new Node(27);\n    root->left->right->right = new Node(3);\n    root->right->right->left = new Node(8);\n    root->right->right->right = new Node(11);\n    vector<vector<int>> res = levelOrder(root);\n    for (vector<int> level : res) {\n        for (int val : level) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/level-order-tree-traversal/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "class Node:\n    def __init__(self, value):\n        self.data = value\n        self.left = None\n        self.right = None\ndef levelOrderRec(root, level, res):\n    # Base case\n    if root is None:\n        return\n    # Add a new level to the result if needed\n    if len(res) <= level:\n        res.append([])\n    # Add current node's data to its corresponding level\n    res[level].append(root.data)\n    # Recur for left and right children\n    level_order_rec(root.left, level + 1, res)\n    level_order_rec(root.right, level + 1, res)\n# Function to perform level order traversal\ndef levelOrder(root):\n    # Stores the result level by level\n    res = []\n    level_order_rec(root, 0, res)\n    return res\nif __name__ == '__main__':\n    #      5\n    #     / \\\n    #   12   13\n    #   /  \\    \\\n    #  7    14    2\n    # /  \\  /  \\  / \\\n    #17  23 27 3 8  11\n    root = Node(5)\n    root.left = Node(12)\n    root.right = Node(13)\n    root.left.left = Node(7)\n    root.left.right = Node(14)\n    root.right.right = Node(2)\n    root.left.left.left = Node(17)\n    root.left.left.right = Node(23)\n    root.left.right.left = Node(27)\n    root.left.right.right = Node(3)\n    root.right.right.left = Node(8)\n    root.right.right.right = Node(11)\n    res = level_order(root)\n    for level in res:\n        print(' '.join(map(str, level)))",
    "code_without_comments": "class Node:\n    def __init__(self, value):\n        self.data = value\n        self.left = None\n        self.right = None\ndef levelOrderRec(root, level, res):\n\n    if root is None:\n        return\n\n    if len(res) <= level:\n        res.append([])\n    # Add current node's data to its corresponding level\n    res[level].append(root.data)\n\n    level_order_rec(root.left, level + 1, res)\n    level_order_rec(root.right, level + 1, res)\n\ndef levelOrder(root):\n\n    res = []\n    level_order_rec(root, 0, res)\n    return res\nif __name__ == '__main__':\n\n\n\n\n\n\n\n    root = Node(5)\n    root.left = Node(12)\n    root.right = Node(13)\n    root.left.left = Node(7)\n    root.left.right = Node(14)\n    root.right.right = Node(2)\n    root.left.left.left = Node(17)\n    root.left.left.right = Node(23)\n    root.left.right.left = Node(27)\n    root.left.right.right = Node(3)\n    root.right.right.left = Node(8)\n    root.right.right.right = Node(11)\n    res = level_order(root)\n    for level in res:\n        print(' '.join(map(str, level)))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/level-order-tree-traversal/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include<queue>\n#include<vector>\nusing namespace std;\nclass Node {\npublic:\n    int data;\n    Node *left, *right;\n    // Constructor to initialize a new node\n    Node(int value) {\n        data = value;\n        left = nullptr;\n        right = nullptr;\n    }\n};\n// Iterative method to perform level order traversal\nvector<vector<int>> levelOrder(Node *root) {\n    if (root == nullptr)\n        return {};\n    // Create an empty queue for level order traversal\n    queue<Node *> q;\n    vector<vector<int>> res;\n    // Enqueue Root\n    q.push(root);\n    int currLevel = 0;\n    while (!q.empty()) {\n        int len = q.size();\n        res.push_back({});\n        for (int i = 0; i < len; i++) {\n            // Add front of queue and remove it from queue\n            Node *node = q.front();\n            q.pop();\n            res[currLevel].push_back(node->data);\n            // Enqueue left child\n            if (node->left != nullptr)\n                q.push(node->left);\n            // Enqueue right child\n            if (node->right != nullptr)\n                q.push(node->right);\n        }\n        currLevel++;\n    }\n    return res;\n}\nint main() {\n    //      5\n    //     / \\\n    //   12   13\n    //   /  \\    \\\n    //  7    14   2\n    // / \\  /  \\  / \\\n    //17 23 27 3  8  11\n    Node *root = new Node(5);\n    root->left = new Node(12);\n    root->right = new Node(13);\n    root->left->left = new Node(7);\n    root->left->right = new Node(14);\n    root->right->right = new Node(2);\n    root->left->left->left = new Node(17);\n    root->left->left->right = new Node(23);\n    root->left->right->left = new Node(27);\n    root->left->right->right = new Node(3);\n    root->right->right->left = new Node(8);\n    root->right->right->right = new Node(11);\n    vector<vector<int>> res = levelOrder(root);\n   for (vector<int> level : res) {\n        for (int val : level) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include<queue>\n#include<vector>\nusing namespace std;\nclass Node {\npublic:\n    int data;\n    Node *left, *right;\n\n    Node(int value) {\n        data = value;\n        left = nullptr;\n        right = nullptr;\n    }\n};\n\nvector<vector<int>> levelOrder(Node *root) {\n    if (root == nullptr)\n        return {};\n\n    queue<Node *> q;\n    vector<vector<int>> res;\n\n    q.push(root);\n    int currLevel = 0;\n    while (!q.empty()) {\n        int len = q.size();\n        res.push_back({});\n        for (int i = 0; i < len; i++) {\n\n            Node *node = q.front();\n            q.pop();\n            res[currLevel].push_back(node->data);\n\n            if (node->left != nullptr)\n                q.push(node->left);\n\n            if (node->right != nullptr)\n                q.push(node->right);\n        }\n        currLevel++;\n    }\n    return res;\n}\nint main() {\n\n\n\n\n\n\n\n    Node *root = new Node(5);\n    root->left = new Node(12);\n    root->right = new Node(13);\n    root->left->left = new Node(7);\n    root->left->right = new Node(14);\n    root->right->right = new Node(2);\n    root->left->left->left = new Node(17);\n    root->left->left->right = new Node(23);\n    root->left->right->left = new Node(27);\n    root->left->right->right = new Node(3);\n    root->right->right->left = new Node(8);\n    root->right->right->right = new Node(11);\n    vector<vector<int>> res = levelOrder(root);\n   for (vector<int> level : res) {\n        for (int val : level) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/level-order-tree-traversal/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "class Node:\n    def __init__(self, value):\n        self.data = value\n        self.left = None\n        self.right = None\n# Iterative method to perform level order traversal\ndef levelOrder(root):\n    if root is None:\n        return []\n    # Create an empty queue for level order traversal\n    q = []\n    res = []\n    # Enqueue Root\n    q.append(root)\n    curr_level = 0\n    while q:\n        len_q = len(q)\n        res.append([])\n        for _ in range(len_q):\n            # Add front of queue and remove it from queue\n            node = q.pop(0)\n            res[curr_level].append(node.data)\n            # Enqueue left child\n            if node.left is not None:\n                q.append(node.left)\n            # Enqueue right child\n            if node.right is not None:\n                q.append(node.right)\n        curr_level += 1\n    return res\nif __name__ == '__main__':\n    #      5\n    #     / \\\n    #   12   13\n    #   /  \\    \\\n    #  7    14   2\n    # /  \\ /  \\  / \\\n    #17 23 2  3 8  11\n    root = Node(5)\n    root.left = Node(12)\n    root.right = Node(13)\n    root.left.left = Node(7)\n    root.left.right = Node(14)\n    root.right.right = Node(2)\n    root.left.left.left = Node(17)\n    root.left.left.right = Node(23)\n    root.left.right.left = Node(27)\n    root.left.right.right = Node(3)\n    root.right.right.left = Node(8)\n    root.right.right.right = Node(11)\n    # Perform level order traversal and get the result\n    res = levelOrder(root)\n    for level in res:\n        for val in level:\n            print(val, end=' ')\n        print()",
    "code_without_comments": "class Node:\n    def __init__(self, value):\n        self.data = value\n        self.left = None\n        self.right = None\n\ndef levelOrder(root):\n    if root is None:\n        return []\n\n    q = []\n    res = []\n\n    q.append(root)\n    curr_level = 0\n    while q:\n        len_q = len(q)\n        res.append([])\n        for _ in range(len_q):\n\n            node = q.pop(0)\n            res[curr_level].append(node.data)\n\n            if node.left is not None:\n                q.append(node.left)\n\n            if node.right is not None:\n                q.append(node.right)\n        curr_level += 1\n    return res\nif __name__ == '__main__':\n\n\n\n\n\n\n\n    root = Node(5)\n    root.left = Node(12)\n    root.right = Node(13)\n    root.left.left = Node(7)\n    root.left.right = Node(14)\n    root.right.right = Node(2)\n    root.left.left.left = Node(17)\n    root.left.left.right = Node(23)\n    root.left.right.left = Node(27)\n    root.left.right.right = Node(3)\n    root.right.right.left = Node(8)\n    root.right.right.right = Node(11)\n\n    res = levelOrder(root)\n    for level in res:\n        for val in level:\n            print(val, end=' ')\n        print()",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/level-order-tree-traversal/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#include <iostream>\nusing namespace std;\n// Node structure\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(int item) {\n        data = item;\n        left = right = nullptr;\n    }\n};\nbool search(Node* root, int key) {\n    // root is null -> return false\n    if (root == nullptr) return false;\n    // if root has key -> return true\n    if (root->data == key) return true;\n    if (key > root->data)\n        return search(root->right, key);\n    else\n        return search(root->left, key);\n}\nint main() {\n    // Creating BST\n    //    6\n    //   / \\\n    //  2   8\n    //     / \\\n    //    7   9\n    Node* root = new Node(6);\n    root->left = new Node(2);\n    root->right = new Node(8);\n    root->right->left = new Node(7);\n    root->right->right = new Node(9);\n    int key = 7;\n    // Searching for key in BST\n    cout << search(root, key) << endl;\n}",
    "code_without_comments": "#include <iostream>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(int item) {\n        data = item;\n        left = right = nullptr;\n    }\n};\nbool search(Node* root, int key) {\n\n    if (root == nullptr) return false;\n\n    if (root->data == key) return true;\n    if (key > root->data)\n        return search(root->right, key);\n    else\n        return search(root->left, key);\n}\nint main() {\n\n\n\n\n\n\n    Node* root = new Node(6);\n    root->left = new Node(2);\n    root->right = new Node(8);\n    root->right->left = new Node(7);\n    root->right->right = new Node(9);\n    int key = 7;\n\n    cout << search(root, key) << endl;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/binary-search-tree-set-1-search-and-insertion/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n// Node structure\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n// Create new node\nstruct Node* newNode(int item) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = item;\n    node->left = node->right = NULL;\n    return node;\n}\nbool search(struct Node* root, int key) {\n    // root is null -> return false\n    if (root == NULL) return false;\n    // if root has key -> return true\n    if (root->data == key) return true;\n    if (key > root->data) return search(root->right, key);\n    return search(root->left, key);\n}\nint main() {\n    // Creating BST\n    //    6\n    //   / \\\n    //  2   8\n    //     / \\\n    //    7   9\n    struct Node* root = newNode(6);\n    root->left = newNode(2);\n    root->right = newNode(8);\n    root->right->left = newNode(7);\n    root->right->right = newNode(9);\n    int key = 7;\n    // Searching for key in the BST\n    printf(\"%d\\n\", search(root, key));\n}",
    "code_without_comments": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\nstruct Node* newNode(int item) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = item;\n    node->left = node->right = NULL;\n    return node;\n}\nbool search(struct Node* root, int key) {\n\n    if (root == NULL) return false;\n\n    if (root->data == key) return true;\n    if (key > root->data) return search(root->right, key);\n    return search(root->left, key);\n}\nint main() {\n\n\n\n\n\n\n    struct Node* root = newNode(6);\n    root->left = newNode(2);\n    root->right = newNode(8);\n    root->right->left = newNode(7);\n    root->right->right = newNode(9);\n    int key = 7;\n\n    printf(\"%d\\n\", search(root, key));\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/binary-search-tree-set-1-search-and-insertion/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "# Node structure\nclass Node:\n    def __init__(self, item):\n        self.data = item\n        self.left = None\n        self.right = None\ndef search(root, key):\n    # root is null -> return false\n    if root is None:\n        return False\n    # if root has key -> return true\n    if root.data == key:\n        return True\n    if key > root.data:\n        return search(root.right, key)\n    return search(root.left, key)\n# Creating BST\n#     6\n#   / \\\n#   2   8\n#      / \\\n#     7   9\nroot = Node(6)\nroot.left = Node(2)\nroot.right = Node(8)\nroot.right.left = Node(7)\nroot.right.right = Node(9)\nkey = 7\n# Searching for key in the BST\nprint(search(root, key))",
    "code_without_comments": "\nclass Node:\n    def __init__(self, item):\n        self.data = item\n        self.left = None\n        self.right = None\ndef search(root, key):\n\n    if root is None:\n        return False\n\n    if root.data == key:\n        return True\n    if key > root.data:\n        return search(root.right, key)\n    return search(root.left, key)\n\n\n\n\n\n\nroot = Node(6)\nroot.left = Node(2)\nroot.right = Node(8)\nroot.right.left = Node(7)\nroot.right.right = Node(9)\nkey = 7\n\nprint(search(root, key))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/binary-search-tree-set-1-search-and-insertion/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#include <iostream>\nusing namespace std;\n// Node structure\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(int item) {\n        data = item;\n        left = right = nullptr;\n    }\n};\nbool search(Node* root, int key) {\n    bool present = false;\n    // iterative traversal\n    while (root != nullptr) {\n        if (root->data == key) {\n            present = true;\n            break;\n        }\n        else if (key > root->data)\n            root = root->right;\n        else\n            root = root->left;\n    }\n    return present;\n}\nint main() {\n    // Creating BST\n    //    6\n    //   / \\\n    //  2   8\n    //     / \\\n    //    7   9\n    Node* root = new Node(6);\n    root->left = new Node(2);\n    root->right = new Node(8);\n    root->right->left = new Node(7);\n    root->right->right = new Node(9);\n    int key = 7;\n    // Searching for key in BST\n    cout << search(root, key) << endl;\n}",
    "code_without_comments": "#include <iostream>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(int item) {\n        data = item;\n        left = right = nullptr;\n    }\n};\nbool search(Node* root, int key) {\n    bool present = false;\n\n    while (root != nullptr) {\n        if (root->data == key) {\n            present = true;\n            break;\n        }\n        else if (key > root->data)\n            root = root->right;\n        else\n            root = root->left;\n    }\n    return present;\n}\nint main() {\n\n\n\n\n\n\n    Node* root = new Node(6);\n    root->left = new Node(2);\n    root->right = new Node(8);\n    root->right->left = new Node(7);\n    root->right->right = new Node(9);\n    int key = 7;\n\n    cout << search(root, key) << endl;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/binary-search-tree-set-1-search-and-insertion/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n// Node structure\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n// Create new node\nstruct Node* newNode(int item) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = item;\n    node->left = node->right = NULL;\n    return node;\n}\nbool search(struct Node* root, int key) {\n    bool present = false;\n    // iterative traversal\n    while (root != NULL ) {\n        if (root->data == key) {\n            present = true;\n            break;\n        }\n        else if (key > root->data)\n            root = root->right;\n        else\n            root = root->left;\n    }\n    return present;\n}\nint main() {\n    // Creating BST\n    //    6\n    //   / \\\n    //  2   8\n    //     / \\\n    //    7   9\n    struct Node* root = newNode(6);\n    root->left = newNode(2);\n    root->right = newNode(8);\n    root->right->left = newNode(7);\n    root->right->right = newNode(9);\n    int key = 7;\n    // Searching for key in the BST\n    printf(\"%d\\n\", search(root, key));\n}",
    "code_without_comments": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\nstruct Node* newNode(int item) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = item;\n    node->left = node->right = NULL;\n    return node;\n}\nbool search(struct Node* root, int key) {\n    bool present = false;\n\n    while (root != NULL ) {\n        if (root->data == key) {\n            present = true;\n            break;\n        }\n        else if (key > root->data)\n            root = root->right;\n        else\n            root = root->left;\n    }\n    return present;\n}\nint main() {\n\n\n\n\n\n\n    struct Node* root = newNode(6);\n    root->left = newNode(2);\n    root->right = newNode(8);\n    root->right->left = newNode(7);\n    root->right->right = newNode(9);\n    int key = 7;\n\n    printf(\"%d\\n\", search(root, key));\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/binary-search-tree-set-1-search-and-insertion/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "# Node structure\nclass Node:\n    def __init__(self, item):\n        self.data = item\n        self.left = None\n        self.right = None\ndef search(root, key):\n    present = False\n    # iterative traversal\n    while root is not None:\n        if root.data == key:\n            present = True\n            break\n        elif key > root.data:\n            root = root.right\n        else:\n            root = root.left\n    return present\nif __name__ == \"__main__\":\n    # Creating BST\n    #     6\n    #   / \\\n    #   2   8\n    #      / \\\n    #     7   9\n    root = Node(6)\n    root.left = Node(2)\n    root.right = Node(8)\n    root.right.left = Node(7)\n    root.right.right = Node(9)\n    key = 7\n    # Searching for key in the BST\n    print(search(root, key))",
    "code_without_comments": "\nclass Node:\n    def __init__(self, item):\n        self.data = item\n        self.left = None\n        self.right = None\ndef search(root, key):\n    present = False\n\n    while root is not None:\n        if root.data == key:\n            present = True\n            break\n        elif key > root.data:\n            root = root.right\n        else:\n            root = root.left\n    return present\nif __name__ == \"__main__\":\n\n\n\n\n\n\n    root = Node(6)\n    root.left = Node(2)\n    root.right = Node(8)\n    root.right.left = Node(7)\n    root.right.right = Node(9)\n    key = 7\n\n    print(search(root, key))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/binary-search-tree-set-1-search-and-insertion/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <iostream>\n#include<vector>\n#include<unordered_map>\n#include <queue>\nusing namespace std;\n// Node structure\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(int x) {\n        data = x;\n        left = right = nullptr;\n    }\n};\n// Calculate Height\nint getHeight(Node* root, int h) {\n    if (root == nullptr) return h - 1;\n    return max(getHeight(root->left, h + 1),\n                      getHeight(root->right, h + 1));\n}\n// Print Level Order\nvoid levelOrder(Node* root) {\n    queue<pair<Node*, int>> q;\n    q.push({root, 0});\n    int lastLevel = 0;\n    // function to get the height of tree\n    int height = getHeight(root, 0);\n    // printing the level order of tree\n    while (!q.empty()) {\n        auto top = q.front(); q.pop();\n        Node* node = top.first;\n        int lvl = top.second;\n        if (lvl > lastLevel) {\n            cout << \"\n\";\n            lastLevel = lvl;\n        }\n        // all levels are printed\n        if (lvl > height) break;\n        if (node->data != -1) cout << node->data << \" \";\n        // printing null node\n        else cout << \"N \";\n        // null node has no children\n        if (node->data == -1) continue;\n        if (node->left == nullptr) q.push({new Node(-1), lvl + 1});\n        else q.push({node->left, lvl + 1});\n        if (node->right == nullptr) q.push({new Node(-1), lvl + 1});\n        else q.push({node->right, lvl + 1});\n    }\n}\n//Driver Code Ends\n// Get inorder successor (smallest in right subtree)\nNode* getSuccessor(Node* curr) {\n    curr = curr->right;\n    while (curr != nullptr && curr->left != nullptr)\n        curr = curr->left;\n    return curr;\n}\n// Delete a node with value x from BST\nNode* delNode(Node* root, int x) {\n    if (root == nullptr)\n        return root;\n    if (root->data > x)\n        root->left = delNode(root->left, x);\n    else if (root->data < x)\n        root->right = delNode(root->right, x);\n    else {\n        // Node with 0 or 1 child\n        if (root->left == nullptr) {\n            Node* temp = root->right;\n            delete root;\n            return temp;\n        }\n        if (root->right == nullptr) {\n            Node* temp = root->left;\n            delete root;\n            return temp;\n        }\n        // Node with 2 children\n        Node* succ = getSuccessor(root);\n        root->data = succ->data;\n        root->right = delNode(root->right, succ->data);\n    }\n    return root;\n}\n//Driver Code Starts\nint main() {\n    Node* root = new Node(10);\n    root->left = new Node(5);\n    root->right = new Node(15);\n    root->right->left = new Node(12);\n    root->right->right = new Node(18);\n    int x = 15;\n    root = delNode(root, x);\n    levelOrder(root);\n    return 0;\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <iostream>\n#include<vector>\n#include<unordered_map>\n#include <queue>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(int x) {\n        data = x;\n        left = right = nullptr;\n    }\n};\n\nint getHeight(Node* root, int h) {\n    if (root == nullptr) return h - 1;\n    return max(getHeight(root->left, h + 1),\n                      getHeight(root->right, h + 1));\n}\n\nvoid levelOrder(Node* root) {\n    queue<pair<Node*, int>> q;\n    q.push({root, 0});\n    int lastLevel = 0;\n\n    int height = getHeight(root, 0);\n\n    while (!q.empty()) {\n        auto top = q.front(); q.pop();\n        Node* node = top.first;\n        int lvl = top.second;\n        if (lvl > lastLevel) {\n            cout << \"\n\";\n            lastLevel = lvl;\n        }\n\n        if (lvl > height) break;\n        if (node->data != -1) cout << node->data << \" \";\n\n        else cout << \"N \";\n\n        if (node->data == -1) continue;\n        if (node->left == nullptr) q.push({new Node(-1), lvl + 1});\n        else q.push({node->left, lvl + 1});\n        if (node->right == nullptr) q.push({new Node(-1), lvl + 1});\n        else q.push({node->right, lvl + 1});\n    }\n}\n\n\nNode* getSuccessor(Node* curr) {\n    curr = curr->right;\n    while (curr != nullptr && curr->left != nullptr)\n        curr = curr->left;\n    return curr;\n}\n\nNode* delNode(Node* root, int x) {\n    if (root == nullptr)\n        return root;\n    if (root->data > x)\n        root->left = delNode(root->left, x);\n    else if (root->data < x)\n        root->right = delNode(root->right, x);\n    else {\n\n        if (root->left == nullptr) {\n            Node* temp = root->right;\n            delete root;\n            return temp;\n        }\n        if (root->right == nullptr) {\n            Node* temp = root->left;\n            delete root;\n            return temp;\n        }\n\n        Node* succ = getSuccessor(root);\n        root->data = succ->data;\n        root->right = delNode(root->right, succ->data);\n    }\n    return root;\n}\n\nint main() {\n    Node* root = new Node(10);\n    root->left = new Node(5);\n    root->right = new Node(15);\n    root->right->left = new Node(12);\n    root->right->right = new Node(18);\n    int x = 15;\n    root = delNode(root, x);\n    levelOrder(root);\n    return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/binary-search-tree-set-2-delete/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <stdio.h>\n#include <stdlib.h>\n// Node structure\nstruct Node\n{\n    int data;\n    struct Node *left;\n    struct Node *right;\n};\n// Function to create a new node\nstruct Node *createNode(int x)\n{\n    struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));\n    newNode->data = x;\n    newNode->left = newNode->right = NULL;\n    return newNode;\n}\n// Function to find the height of the tree\nint getHeight(struct Node *root, int h)\n{\n    if (root == NULL)\n        return h - 1;\n    int leftHeight = getHeight(root->left, h + 1);\n    int rightHeight = getHeight(root->right, h + 1);\n    return (leftHeight > rightHeight) ? leftHeight : rightHeight;\n}\n// Queue structure for level order traversal\nstruct QueueNode\n{\n    struct Node *node;\n    int level;\n};\nstruct Queue\n{\n    struct QueueNode arr[100];\n    int front, rear;\n};\n// Initialize queue\nvoid initQueue(struct Queue *q)\n{\n    q->front = 0;\n    q->rear = 0;\n}\n// Enqueue\nvoid enqueue(struct Queue *q, struct Node *node, int level)\n{\n    q->arr[q->rear].node = node;\n    q->arr[q->rear].level = level;\n    q->rear++;\n}\n// Dequeue\nstruct QueueNode dequeue(struct Queue *q)\n{\n    return q->arr[q->front++];\n}\n// Check if queue is empty\nint isEmpty(struct Queue *q)\n{\n    return q->front == q->rear;\n}\n// Function to print Level Order Traversal\nvoid levelOrder(struct Node *root)\n{\n    if (root == NULL)\n        return;\n    struct Queue q;\n    initQueue(&q);\n    enqueue(&q, root, 0);\n    int lastLevel = 0;\n    // function to get height of the tree\n    int height = getHeight(root, 0);\n    // printing level order of the tree\n    while (!isEmpty(&q))\n    {\n        struct QueueNode temp = dequeue(&q);\n        struct Node *node = temp.node;\n        int lvl = temp.level;\n        if (lvl > lastLevel)\n        {\n            printf(\"\n\");\n            lastLevel = lvl;\n        }\n        // all levels are printed\n        if (lvl > height)\n            break;\n        // Printing null nodes\n        if (node->data != -1)\n            printf(\"%d \", node->data);\n        else\n            printf(\"N \");\n        // null node has no children\n        if (node->data == -1)\n            continue;\n        if (node->left == NULL)\n            enqueue(&q, createNode(-1), lvl + 1);\n        else\n            enqueue(&q, node->left, lvl + 1);\n        if (node->right == NULL)\n            enqueue(&q, createNode(-1), lvl + 1);\n        else\n            enqueue(&q, node->right, lvl + 1);\n    }\n}\n//Driver Code Ends\n// the inorder successor (smallest in right subtree)\nstruct Node *getSuccessor(struct Node *curr)\n{\n    curr = curr->right;\n    while (curr != NULL && curr->left != NULL)\n        curr = curr->left;\n    return curr;\n}\n// Function to delete a node with value x from BST\nstruct Node *delNode(struct Node *root, int x)\n{\n    if (root == NULL)\n        return root;\n    if (root->data > x)\n        root->left = delNode(root->left, x);\n    else if (root->data < x)\n        root->right = delNode(root->right, x);\n    else\n    {\n        // Node with 0 or 1 child\n        if (root->left == NULL)\n        {\n            struct Node *temp = root->right;\n            free(root);\n            return temp;\n        }\n        if (root->right == NULL)\n        {\n            struct Node *temp = root->left;\n            free(root);\n            return temp;\n        }\n        // Node with 2 children\n        struct Node *succ = getSuccessor(root);\n        root->data = succ->data;\n        root->right = delNode(root->right, succ->data);\n    }\n    return root;\n}\n//Driver Code Starts\nint main()\n{\n    struct Node *root = createNode(10);\n    root->left = createNode(5);\n    root->right = createNode(15);\n    root->right->left = createNode(12);\n    root->right->right = createNode(18);\n    int x = 15;\n    root = delNode(root, x);\n    levelOrder(root);\n    return 0;\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node\n{\n    int data;\n    struct Node *left;\n    struct Node *right;\n};\n\nstruct Node *createNode(int x)\n{\n    struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));\n    newNode->data = x;\n    newNode->left = newNode->right = NULL;\n    return newNode;\n}\n\nint getHeight(struct Node *root, int h)\n{\n    if (root == NULL)\n        return h - 1;\n    int leftHeight = getHeight(root->left, h + 1);\n    int rightHeight = getHeight(root->right, h + 1);\n    return (leftHeight > rightHeight) ? leftHeight : rightHeight;\n}\n\nstruct QueueNode\n{\n    struct Node *node;\n    int level;\n};\nstruct Queue\n{\n    struct QueueNode arr[100];\n    int front, rear;\n};\n\nvoid initQueue(struct Queue *q)\n{\n    q->front = 0;\n    q->rear = 0;\n}\n\nvoid enqueue(struct Queue *q, struct Node *node, int level)\n{\n    q->arr[q->rear].node = node;\n    q->arr[q->rear].level = level;\n    q->rear++;\n}\n\nstruct QueueNode dequeue(struct Queue *q)\n{\n    return q->arr[q->front++];\n}\n\nint isEmpty(struct Queue *q)\n{\n    return q->front == q->rear;\n}\n\nvoid levelOrder(struct Node *root)\n{\n    if (root == NULL)\n        return;\n    struct Queue q;\n    initQueue(&q);\n    enqueue(&q, root, 0);\n    int lastLevel = 0;\n\n    int height = getHeight(root, 0);\n\n    while (!isEmpty(&q))\n    {\n        struct QueueNode temp = dequeue(&q);\n        struct Node *node = temp.node;\n        int lvl = temp.level;\n        if (lvl > lastLevel)\n        {\n            printf(\"\n\");\n            lastLevel = lvl;\n        }\n\n        if (lvl > height)\n            break;\n\n        if (node->data != -1)\n            printf(\"%d \", node->data);\n        else\n            printf(\"N \");\n\n        if (node->data == -1)\n            continue;\n        if (node->left == NULL)\n            enqueue(&q, createNode(-1), lvl + 1);\n        else\n            enqueue(&q, node->left, lvl + 1);\n        if (node->right == NULL)\n            enqueue(&q, createNode(-1), lvl + 1);\n        else\n            enqueue(&q, node->right, lvl + 1);\n    }\n}\n\n\nstruct Node *getSuccessor(struct Node *curr)\n{\n    curr = curr->right;\n    while (curr != NULL && curr->left != NULL)\n        curr = curr->left;\n    return curr;\n}\n\nstruct Node *delNode(struct Node *root, int x)\n{\n    if (root == NULL)\n        return root;\n    if (root->data > x)\n        root->left = delNode(root->left, x);\n    else if (root->data < x)\n        root->right = delNode(root->right, x);\n    else\n    {\n\n        if (root->left == NULL)\n        {\n            struct Node *temp = root->right;\n            free(root);\n            return temp;\n        }\n        if (root->right == NULL)\n        {\n            struct Node *temp = root->left;\n            free(root);\n            return temp;\n        }\n\n        struct Node *succ = getSuccessor(root);\n        root->data = succ->data;\n        root->right = delNode(root->right, succ->data);\n    }\n    return root;\n}\n\nint main()\n{\n    struct Node *root = createNode(10);\n    root->left = createNode(5);\n    root->right = createNode(15);\n    root->right->left = createNode(12);\n    root->right->right = createNode(18);\n    int x = 15;\n    root = delNode(root, x);\n    levelOrder(root);\n    return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/binary-search-tree-set-2-delete/",
    "complexity_weight": 2.0
  }
]