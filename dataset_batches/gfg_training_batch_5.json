[
  {
    "code_with_comments": "#Driver Code Starts\nfrom collections import deque\n# Node structure\nclass Node:\n    def __init__(self, x):\n        self.data = x\n        self.left = None\n        self.right = None\n# Calculate Height\ndef getHeight(root, h):\n    if root is None:\n        return h - 1\n    return max(getHeight(root.left, h + 1),\n               getHeight(root.right, h + 1))\n# Print Level Order\ndef levelOrder(root):\n    q = deque()\n    q.append((root, 0))\n    lastLevel = 0\n    # function to get the height of tree\n    height = getHeight(root, 0)\n    #  printing the level order of tree\n    while q:\n        node, lvl = q.popleft()\n        if lvl > lastLevel:\n            print()\n            lastLevel = lvl\n        #  all levels are printed\n        if lvl > height:\n            break\n        #  printing null nodes\n        if node.data != -1:\n            print(node.data, end=\" \")\n        else:\n            print(\"N\", end=\" \")\n        # null node has no children\n        if node.data == -1:\n            continue\n        if node.left is None:\n            q.append((Node(-1), lvl + 1))\n        else:\n            q.append((node.left, lvl + 1))\n        if node.right is None:\n            q.append((Node(-1), lvl + 1))\n        else:\n            q.append((node.right, lvl + 1))\n#Driver Code Ends\n# Get inorder successor (smallest in right subtree)\ndef getSuccessor(curr):\n    curr = curr.right\n    while curr is not None and curr.left is not None:\n        curr = curr.left\n    return curr\n# Delete a node with value x from BST\ndef delNode(root, x):\n    if root is None:\n        return root\n    if root.data > x:\n        root.left = delNode(root.left, x)\n    elif root.data < x:\n        root.right = delNode(root.right, x)\n    else:\n        # node with 0 or 1  children\n        if root.left is None:\n            return root.right\n        if root.right is None:\n            return root.left\n        #  Node with 2 children\n        succ = getSuccessor(root)\n        root.data = succ.data\n        root.right = delNode(root.right, succ.data)\n    return root\n#Driver Code Starts\nif  __name__ == \"__main__\":\n    root = Node(10)\n    root.left = Node(5)\n    root.right = Node(15)\n    root.right.left = Node(12)\n    root.right.right = Node(18)\n    x = 15\n    root = delNode(root, x)\n    levelOrder(root)\n#Driver Code Ends",
    "code_without_comments": "\nfrom collections import deque\n\nclass Node:\n    def __init__(self, x):\n        self.data = x\n        self.left = None\n        self.right = None\n\ndef getHeight(root, h):\n    if root is None:\n        return h - 1\n    return max(getHeight(root.left, h + 1),\n               getHeight(root.right, h + 1))\n\ndef levelOrder(root):\n    q = deque()\n    q.append((root, 0))\n    lastLevel = 0\n\n    height = getHeight(root, 0)\n\n    while q:\n        node, lvl = q.popleft()\n        if lvl > lastLevel:\n            print()\n            lastLevel = lvl\n\n        if lvl > height:\n            break\n\n        if node.data != -1:\n            print(node.data, end=\" \")\n        else:\n            print(\"N\", end=\" \")\n\n        if node.data == -1:\n            continue\n        if node.left is None:\n            q.append((Node(-1), lvl + 1))\n        else:\n            q.append((node.left, lvl + 1))\n        if node.right is None:\n            q.append((Node(-1), lvl + 1))\n        else:\n            q.append((node.right, lvl + 1))\n\n\ndef getSuccessor(curr):\n    curr = curr.right\n    while curr is not None and curr.left is not None:\n        curr = curr.left\n    return curr\n\ndef delNode(root, x):\n    if root is None:\n        return root\n    if root.data > x:\n        root.left = delNode(root.left, x)\n    elif root.data < x:\n        root.right = delNode(root.right, x)\n    else:\n\n        if root.left is None:\n            return root.right\n        if root.right is None:\n            return root.left\n\n        succ = getSuccessor(root)\n        root.data = succ.data\n        root.right = delNode(root.right, succ.data)\n    return root\n\nif  __name__ == \"__main__\":\n    root = Node(10)\n    root.left = Node(5)\n    root.right = Node(15)\n    root.right.left = Node(12)\n    root.right.right = Node(18)\n    x = 15\n    root = delNode(root, x)\n    levelOrder(root)\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/binary-search-tree-set-2-delete/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "// C++ program to insert a node in AVL tree\n#include <bits/stdc++.h>\nusing namespace std;\n// An AVL tree node\nstruct Node {\n    int key;\n    Node *left;\n    Node *right;\n    int height;\n    Node(int k) {\n        key = k;\n        left = nullptr;\n        right = nullptr;\n        height = 1;\n    }\n};\n// A utility function to\n// get the height of the tree\nint height(Node *N) {\n    if (N == nullptr)\n        return 0;\n    return N->height;\n}\n// A utility function to right\n// rotate subtree rooted with y\nNode *rightRotate(Node *y) {\n    Node *x = y->left;\n    Node *T2 = x->right;\n    // Perform rotation\n    x->right = y;\n    y->left = T2;\n    // Update heights\n    y->height = 1 + max(height(y->left),\n                    height(y->right));\n    x->height = 1 + max(height(x->left),\n                        height(x->right));\n    // Return new root\n    return x;\n}\n// A utility function to left rotate\n// subtree rooted with x\nNode *leftRotate(Node *x) {\n    Node *y = x->right;\n    Node *T2 = y->left;\n    // Perform rotation\n    y->left = x;\n    x->right = T2;\n    // Update heights\n    x->height = 1 + max(height(x->left),\n                        height(x->right));\n    y->height = 1 + max(height(y->left),\n                        height(y->right));\n    // Return new root\n    return y;\n}\n// Get balance factor of node N\nint getBalance(Node *N) {\n    if (N == nullptr)\n        return 0;\n    return height(N->left) - height(N->right);\n}\n// Recursive function to insert a key in\n// the subtree rooted with node\nNode* insert(Node* node, int key) {\n    // Perform the normal BST insertion\n    if (node == nullptr)\n        return new Node(key);\n    if (key < node->key)\n        node->left = insert(node->left, key);\n    else if (key > node->key)\n        node->right = insert(node->right, key);\n    else // Equal keys are not allowed in BST\n        return node;\n    // Update height of this ancestor node\n    node->height = 1 + max(height(node->left),\n                           height(node->right));\n    // Get the balance factor of this ancestor node\n    int balance = getBalance(node);\n    // If this node becomes unbalanced,\n    // then there are 4 cases\n    // Left Left Case\n    if (balance > 1 && key < node->left->key)\n        return rightRotate(node);\n    // Right Right Case\n    if (balance < -1 && key > node->right->key)\n        return leftRotate(node);\n    // Left Right Case\n    if (balance > 1 && key > node->left->key) {\n        node->left = leftRotate(node->left);\n        return rightRotate(node);\n    }\n    // Right Left Case\n    if (balance < -1 && key < node->right->key) {\n        node->right = rightRotate(node->right);\n        return leftRotate(node);\n    }\n    // Return the (unchanged) node pointer\n    return node;\n}\n// A utility function to print\n// preorder traversal of the tree\nvoid preOrder(Node *root) {\n    if (root != nullptr) {\n        cout << root->key << \" \";\n        preOrder(root->left);\n        preOrder(root->right);\n    }\n}\n// Driver Code\nint main() {\n    Node *root = nullptr;\n    // Constructing tree given in the above figure\n    root = insert(root, 10);\n    root = insert(root, 20);\n    root = insert(root, 30);\n    root = insert(root, 40);\n    root = insert(root, 50);\n    root = insert(root, 25);\n    /* The constructed AVL Tree would be\n              30\n            /   \\\n          20     40\n         /  \\      \\\n       10   25     50\n    */\n    // Preorder traversal\n    preOrder(root);\n    return 0;\n}",
    "code_without_comments": "\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Node {\n    int key;\n    Node *left;\n    Node *right;\n    int height;\n    Node(int k) {\n        key = k;\n        left = nullptr;\n        right = nullptr;\n        height = 1;\n    }\n};\n\n\nint height(Node *N) {\n    if (N == nullptr)\n        return 0;\n    return N->height;\n}\n\n\nNode *rightRotate(Node *y) {\n    Node *x = y->left;\n    Node *T2 = x->right;\n\n    x->right = y;\n    y->left = T2;\n\n    y->height = 1 + max(height(y->left),\n                    height(y->right));\n    x->height = 1 + max(height(x->left),\n                        height(x->right));\n\n    return x;\n}\n\n\nNode *leftRotate(Node *x) {\n    Node *y = x->right;\n    Node *T2 = y->left;\n\n    y->left = x;\n    x->right = T2;\n\n    x->height = 1 + max(height(x->left),\n                        height(x->right));\n    y->height = 1 + max(height(y->left),\n                        height(y->right));\n\n    return y;\n}\n\nint getBalance(Node *N) {\n    if (N == nullptr)\n        return 0;\n    return height(N->left) - height(N->right);\n}\n\n\nNode* insert(Node* node, int key) {\n\n    if (node == nullptr)\n        return new Node(key);\n    if (key < node->key)\n        node->left = insert(node->left, key);\n    else if (key > node->key)\n        node->right = insert(node->right, key);\n    else\n        return node;\n\n    node->height = 1 + max(height(node->left),\n                           height(node->right));\n\n    int balance = getBalance(node);\n\n\n\n    if (balance > 1 && key < node->left->key)\n        return rightRotate(node);\n\n    if (balance < -1 && key > node->right->key)\n        return leftRotate(node);\n\n    if (balance > 1 && key > node->left->key) {\n        node->left = leftRotate(node->left);\n        return rightRotate(node);\n    }\n\n    if (balance < -1 && key < node->right->key) {\n        node->right = rightRotate(node->right);\n        return leftRotate(node);\n    }\n\n    return node;\n}\n\n\nvoid preOrder(Node *root) {\n    if (root != nullptr) {\n        cout << root->key << \" \";\n        preOrder(root->left);\n        preOrder(root->right);\n    }\n}\n\nint main() {\n    Node *root = nullptr;\n\n    root = insert(root, 10);\n    root = insert(root, 20);\n    root = insert(root, 30);\n    root = insert(root, 40);\n    root = insert(root, 50);\n    root = insert(root, 25);\n\n\n    preOrder(root);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/avl-tree-set-1-insertion/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "// C program to insert a node in AVL tree\n#include<stdio.h>\n#include<stdlib.h>\n// An AVL tree node\nstruct Node\n{\n    int key;\n    struct Node *left;\n    struct Node *right;\n    int height;\n};\n// A utility function to get the height of the tree\nint height(struct Node *N)\n{\n    if (N == NULL)\n        return 0;\n    return N->height;\n}\n// A utility function to get maximum of two integers\nint max(int a, int b)\n{\n    return (a > b)? a : b;\n}\n/* Helper function that allocates a new node with the given key and\n    NULL left and right pointers. */\nstruct Node* newNode(int key)\n{\n    struct Node* node = (struct Node*)\n                        malloc(sizeof(struct Node));\n    node->key   = key;\n    node->left   = NULL;\n    node->right  = NULL;\n    node->height = 1;  // new node is initially added at leaf\n    return(node);\n}\n// A utility function to right rotate subtree rooted with y\n// See the diagram given above.\nstruct Node *rightRotate(struct Node *y)\n{\n    struct Node *x = y->left;\n    struct Node *T2 = x->right;\n    // Perform rotation\n    x->right = y;\n    y->left = T2;\n    // Update heights\n    y->height = max(height(y->left),\n                    height(y->right)) + 1;\n    x->height = max(height(x->left),\n                    height(x->right)) + 1;\n    // Return new root\n    return x;\n}\n// A utility function to left rotate subtree rooted with x\n// See the diagram given above.\nstruct Node *leftRotate(struct Node *x)\n{\n    struct Node *y = x->right;\n    struct Node *T2 = y->left;\n    // Perform rotation\n    y->left = x;\n    x->right = T2;\n    //  Update heights\n    x->height = max(height(x->left),\n                    height(x->right)) + 1;\n    y->height = max(height(y->left),\n                    height(y->right)) + 1;\n    // Return new root\n    return y;\n}\n// Get Balance factor of node N\nint getBalance(struct Node *N)\n{\n    if (N == NULL)\n        return 0;\n    return height(N->left) - height(N->right);\n}\n// Recursive function to insert a key in the subtree rooted\n// with node and returns the new root of the subtree.\nstruct Node* insert(struct Node* node, int key)\n{\n    /* 1.  Perform the normal BST insertion */\n    if (node == NULL)\n        return(newNode(key));\n    if (key < node->key)\n        node->left  = insert(node->left, key);\n    else if (key > node->key)\n        node->right = insert(node->right, key);\n    else // Equal keys are not allowed in BST\n        return node;\n    /* 2. Update height of this ancestor node */\n    node->height = 1 + max(height(node->left),\n                        height(node->right));\n    /* 3. Get the balance factor of this ancestor\n          node to check whether this node became\n          unbalanced */\n    int balance = getBalance(node);\n    // If this node becomes unbalanced, then\n    // there are 4 cases\n    // Left Left Case\n    if (balance > 1 && key < node->left->key)\n        return rightRotate(node);\n    // Right Right Case\n    if (balance < -1 && key > node->right->key)\n        return leftRotate(node);\n    // Left Right Case\n    if (balance > 1 && key > node->left->key)\n    {\n        node->left =  leftRotate(node->left);\n        return rightRotate(node);\n    }\n    // Right Left Case\n    if (balance < -1 && key < node->right->key)\n    {\n        node->right = rightRotate(node->right);\n        return leftRotate(node);\n    }\n    /* return the (unchanged) node pointer */\n    return node;\n}\n// A utility function to print preorder traversal\n// of the tree.\n// The function also prints height of every node\nvoid preOrder(struct Node *root)\n{\n    if(root != NULL)\n    {\n        printf(\"%d \", root->key);\n        preOrder(root->left);\n        preOrder(root->right);\n    }\n}\n/* Driver program to test above function*/\nint main()\n{\n  struct Node *root = NULL;\n  /* Constructing tree given in the above figure */\n  root = insert(root, 10);\n  root = insert(root, 20);\n  root = insert(root, 30);\n  root = insert(root, 40);\n  root = insert(root, 50);\n  root = insert(root, 25);\n  /* The constructed AVL Tree would be\n            30\n           /  \\\n         20   40\n        /  \\     \\\n       10  25    50\n  */\n// Preorder traversal\n  preOrder(root);\n  return 0;\n}",
    "code_without_comments": "\n#include<stdio.h>\n#include<stdlib.h>\n\nstruct Node\n{\n    int key;\n    struct Node *left;\n    struct Node *right;\n    int height;\n};\n\nint height(struct Node *N)\n{\n    if (N == NULL)\n        return 0;\n    return N->height;\n}\n\nint max(int a, int b)\n{\n    return (a > b)? a : b;\n}\n\nstruct Node* newNode(int key)\n{\n    struct Node* node = (struct Node*)\n                        malloc(sizeof(struct Node));\n    node->key   = key;\n    node->left   = NULL;\n    node->right  = NULL;\n    node->height = 1;\n    return(node);\n}\n\n\nstruct Node *rightRotate(struct Node *y)\n{\n    struct Node *x = y->left;\n    struct Node *T2 = x->right;\n\n    x->right = y;\n    y->left = T2;\n\n    y->height = max(height(y->left),\n                    height(y->right)) + 1;\n    x->height = max(height(x->left),\n                    height(x->right)) + 1;\n\n    return x;\n}\n\n\nstruct Node *leftRotate(struct Node *x)\n{\n    struct Node *y = x->right;\n    struct Node *T2 = y->left;\n\n    y->left = x;\n    x->right = T2;\n\n    x->height = max(height(x->left),\n                    height(x->right)) + 1;\n    y->height = max(height(y->left),\n                    height(y->right)) + 1;\n\n    return y;\n}\n\nint getBalance(struct Node *N)\n{\n    if (N == NULL)\n        return 0;\n    return height(N->left) - height(N->right);\n}\n\n\nstruct Node* insert(struct Node* node, int key)\n{\n\n    if (node == NULL)\n        return(newNode(key));\n    if (key < node->key)\n        node->left  = insert(node->left, key);\n    else if (key > node->key)\n        node->right = insert(node->right, key);\n    else\n        return node;\n\n    node->height = 1 + max(height(node->left),\n                        height(node->right));\n\n    int balance = getBalance(node);\n\n\n\n    if (balance > 1 && key < node->left->key)\n        return rightRotate(node);\n\n    if (balance < -1 && key > node->right->key)\n        return leftRotate(node);\n\n    if (balance > 1 && key > node->left->key)\n    {\n        node->left =  leftRotate(node->left);\n        return rightRotate(node);\n    }\n\n    if (balance < -1 && key < node->right->key)\n    {\n        node->right = rightRotate(node->right);\n        return leftRotate(node);\n    }\n\n    return node;\n}\n\n\n\nvoid preOrder(struct Node *root)\n{\n    if(root != NULL)\n    {\n        printf(\"%d \", root->key);\n        preOrder(root->left);\n        preOrder(root->right);\n    }\n}\n\nint main()\n{\n  struct Node *root = NULL;\n\n  root = insert(root, 10);\n  root = insert(root, 20);\n  root = insert(root, 30);\n  root = insert(root, 40);\n  root = insert(root, 50);\n  root = insert(root, 25);\n\n\n  preOrder(root);\n  return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/avl-tree-set-1-insertion/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "// Java program to insert a node in AVL tree\nimport java.util.*;\nclass Node {\n    int key;\n    Node left;\n    Node right;\n    int height;\n    Node(int k) {\n        key = k;\n        left = null;\n        right = null;\n        height = 1;\n    }\n}\nclass GfG {\n    // A utility function to get the\n    // height of the tree\n    static int height(Node N) {\n        if (N == null)\n            return 0;\n        return N.height;\n    }\n    // A utility function to right rotate\n    // subtree rooted with y\n    static Node rightRotate(Node y) {\n        Node x = y.left;\n        Node T2 = x.right;\n        // Perform rotation\n        x.right = y;\n        y.left = T2;\n        // Update heights\n        y.height = 1 + Math.max(height(y.left),\n                                height(y.right));\n        x.height = 1 + Math.max(height(x.left),\n                                height(x.right));\n        // Return new root\n        return x;\n    }\n    // A utility function to left rotate\n    // subtree rooted with x\n    static Node leftRotate(Node x) {\n        Node y = x.right;\n        Node T2 = y.left;\n        // Perform rotation\n        y.left = x;\n        x.right = T2;\n        // Update heights\n        x.height = 1 + Math.max(height(x.left),\n                                height(x.right));\n        y.height = 1 + Math.max(height(y.left),\n                                height(y.right));\n        // Return new root\n        return y;\n    }\n    // Get balance factor of node N\n    static int getBalance(Node N) {\n        if (N == null)\n            return 0;\n        return height(N.left) - height(N.right);\n    }\n    // Recursive function to insert a key in\n    // the subtree rooted with node\n    static Node insert(Node node, int key) {\n        // Perform the normal BST insertion\n        if (node == null)\n            return new Node(key);\n        if (key < node.key)\n            node.left = insert(node.left, key);\n        else if (key > node.key)\n            node.right = insert(node.right, key);\n        else // Equal keys are not allowed in BST\n            return node;\n        // Update height of this ancestor node\n        node.height = 1 + Math.max(height(node.left),\n                                   height(node.right));\n        // Get the balance factor of this ancestor node\n        int balance = getBalance(node);\n        // If this node becomes unbalanced,\n        // then there are 4 cases\n        // Left Left Case\n        if (balance > 1 && key < node.left.key)\n            return rightRotate(node);\n        // Right Right Case\n        if (balance < -1 && key > node.right.key)\n            return leftRotate(node);\n        // Left Right Case\n        if (balance > 1 && key > node.left.key) {\n            node.left = leftRotate(node.left);\n            return rightRotate(node);\n        }\n        // Right Left Case\n        if (balance < -1 && key < node.right.key) {\n            node.right = rightRotate(node.right);\n            return leftRotate(node);\n        }\n        // Return the (unchanged) node pointer\n        return node;\n    }\n    // A utility function to print preorder\n    // traversal of the tree\n    static void preOrder(Node root) {\n        if (root != null) {\n            System.out.print(root.key + \" \");\n            preOrder(root.left);\n            preOrder(root.right);\n        }\n    }\n    // Driver code\n    public static void main(String[] args) {\n        Node root = null;\n        // Constructing tree given in the above figure\n        root = insert(root, 10);\n        root = insert(root, 20);\n        root = insert(root, 30);\n        root = insert(root, 40);\n        root = insert(root, 50);\n        root = insert(root, 25);\n        /* The constructed AVL Tree would be\n                  30\n                /   \\\n              20     40\n             /  \\      \\\n           10   25     50\n        */\n    // Preorder traversal\n        preOrder(root);\n    }\n}",
    "code_without_comments": "// Java program to insert a node in AVL tree\nimport java.util.*;\nclass Node {\n    int key;\n    Node left;\n    Node right;\n    int height;\n    Node(int k) {\n        key = k;\n        left = null;\n        right = null;\n        height = 1;\n    }\n}\nclass GfG {\n    // A utility function to get the\n    // height of the tree\n    static int height(Node N) {\n        if (N == null)\n            return 0;\n        return N.height;\n    }\n    // A utility function to right rotate\n    // subtree rooted with y\n    static Node rightRotate(Node y) {\n        Node x = y.left;\n        Node T2 = x.right;\n        // Perform rotation\n        x.right = y;\n        y.left = T2;\n        // Update heights\n        y.height = 1 + Math.max(height(y.left),\n                                height(y.right));\n        x.height = 1 + Math.max(height(x.left),\n                                height(x.right));\n        // Return new root\n        return x;\n    }\n    // A utility function to left rotate\n    // subtree rooted with x\n    static Node leftRotate(Node x) {\n        Node y = x.right;\n        Node T2 = y.left;\n        // Perform rotation\n        y.left = x;\n        x.right = T2;\n        // Update heights\n        x.height = 1 + Math.max(height(x.left),\n                                height(x.right));\n        y.height = 1 + Math.max(height(y.left),\n                                height(y.right));\n        // Return new root\n        return y;\n    }\n    // Get balance factor of node N\n    static int getBalance(Node N) {\n        if (N == null)\n            return 0;\n        return height(N.left) - height(N.right);\n    }\n    // Recursive function to insert a key in\n    // the subtree rooted with node\n    static Node insert(Node node, int key) {\n        // Perform the normal BST insertion\n        if (node == null)\n            return new Node(key);\n        if (key < node.key)\n            node.left = insert(node.left, key);\n        else if (key > node.key)\n            node.right = insert(node.right, key);\n        else // Equal keys are not allowed in BST\n            return node;\n        // Update height of this ancestor node\n        node.height = 1 + Math.max(height(node.left),\n                                   height(node.right));\n        // Get the balance factor of this ancestor node\n        int balance = getBalance(node);\n        // If this node becomes unbalanced,\n        // then there are 4 cases\n        // Left Left Case\n        if (balance > 1 && key < node.left.key)\n            return rightRotate(node);\n        // Right Right Case\n        if (balance < -1 && key > node.right.key)\n            return leftRotate(node);\n        // Left Right Case\n        if (balance > 1 && key > node.left.key) {\n            node.left = leftRotate(node.left);\n            return rightRotate(node);\n        }\n        // Right Left Case\n        if (balance < -1 && key < node.right.key) {\n            node.right = rightRotate(node.right);\n            return leftRotate(node);\n        }\n        // Return the (unchanged) node pointer\n        return node;\n    }\n    // A utility function to print preorder\n    // traversal of the tree\n    static void preOrder(Node root) {\n        if (root != null) {\n            System.out.print(root.key + \" \");\n            preOrder(root.left);\n            preOrder(root.right);\n        }\n    }\n    // Driver code\n    public static void main(String[] args) {\n        Node root = null;\n        // Constructing tree given in the above figure\n        root = insert(root, 10);\n        root = insert(root, 20);\n        root = insert(root, 30);\n        root = insert(root, 40);\n        root = insert(root, 50);\n        root = insert(root, 25);\n        /* The constructed AVL Tree would be\n                  30\n                /   \\\n              20     40\n             /  \\      \\\n           10   25     50\n        */\n    // Preorder traversal\n        preOrder(root);\n    }\n}",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/avl-tree-set-1-insertion/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "class Node:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n        self.height = 1\n# A utility function to get the\n# height of the tree\ndef height(node):\n    if not node:\n        return 0\n    return node.height\n# A utility function to right rotate\n# subtree rooted with y\ndef right_rotate(y):\n    x = y.left\n    T2 = x.right\n    # Perform rotation\n    x.right = y\n    y.left = T2\n    # Update heights\n    y.height = 1 + max(height(y.left), height(y.right))\n    x.height = 1 + max(height(x.left), height(x.right))\n    # Return new root\n    return x\n# A utility function to left rotate\n# subtree rooted with x\ndef left_rotate(x):\n    y = x.right\n    T2 = y.left\n    # Perform rotation\n    y.left = x\n    x.right = T2\n    # Update heights\n    x.height = 1 + max(height(x.left), height(x.right))\n    y.height = 1 + max(height(y.left), height(y.right))\n    # Return new root\n    return y\n# Get balance factor of node N\ndef get_balance(node):\n    if not node:\n        return 0\n    return height(node.left) - height(node.right)\n# Recursive function to insert a key in\n# the subtree rooted with node\ndef insert(node, key):\n    # Perform the normal BST insertion\n    if not node:\n        return Node(key)\n    if key < node.key:\n        node.left = insert(node.left, key)\n    elif key > node.key:\n        node.right = insert(node.right, key)\n    else:\n        # Equal keys are not allowed in BST\n        return node\n    # Update height of this ancestor node\n    node.height = 1 + max(height(node.left), height(node.right))\n    # Get the balance factor of this ancestor node\n    balance = get_balance(node)\n    # If this node becomes unbalanced,\n    # then there are 4 cases\n    # Left Left Case\n    if balance > 1 and key < node.left.key:\n        return right_rotate(node)\n    # Right Right Case\n    if balance < -1 and key > node.right.key:\n        return left_rotate(node)\n    # Left Right Case\n    if balance > 1 and key > node.left.key:\n        node.left = left_rotate(node.left)\n        return right_rotate(node)\n    # Right Left Case\n    if balance < -1 and key < node.right.key:\n        node.right = right_rotate(node.right)\n        return left_rotate(node)\n    # Return the (unchanged) node pointer\n    return node\n# A utility function to print preorder\n# traversal of the tree\ndef pre_order(root):\n    if root:\n        print(root.key, end=\" \")\n        pre_order(root.left)\n        pre_order(root.right)\n# Driver code\nroot = None\n# Constructing tree given in the above figure\nroot = insert(root, 10)\nroot = insert(root, 20)\nroot = insert(root, 30)\nroot = insert(root, 40)\nroot = insert(root, 50)\nroot = insert(root, 25)\n# The constructed AVL Tree would be\n#        30\n#       /  \\\n#      20   40\n#     /  \\    \\\n#    10  25   50\n# Preorder traversal\npre_order(root)",
    "code_without_comments": "class Node:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n        self.height = 1\n\n\ndef height(node):\n    if not node:\n        return 0\n    return node.height\n\n\ndef right_rotate(y):\n    x = y.left\n    T2 = x.right\n\n    x.right = y\n    y.left = T2\n\n    y.height = 1 + max(height(y.left), height(y.right))\n    x.height = 1 + max(height(x.left), height(x.right))\n\n    return x\n\n\ndef left_rotate(x):\n    y = x.right\n    T2 = y.left\n\n    y.left = x\n    x.right = T2\n\n    x.height = 1 + max(height(x.left), height(x.right))\n    y.height = 1 + max(height(y.left), height(y.right))\n\n    return y\n\ndef get_balance(node):\n    if not node:\n        return 0\n    return height(node.left) - height(node.right)\n\n\ndef insert(node, key):\n\n    if not node:\n        return Node(key)\n    if key < node.key:\n        node.left = insert(node.left, key)\n    elif key > node.key:\n        node.right = insert(node.right, key)\n    else:\n\n        return node\n\n    node.height = 1 + max(height(node.left), height(node.right))\n\n    balance = get_balance(node)\n\n\n\n    if balance > 1 and key < node.left.key:\n        return right_rotate(node)\n\n    if balance < -1 and key > node.right.key:\n        return left_rotate(node)\n\n    if balance > 1 and key > node.left.key:\n        node.left = left_rotate(node.left)\n        return right_rotate(node)\n\n    if balance < -1 and key < node.right.key:\n        node.right = right_rotate(node.right)\n        return left_rotate(node)\n\n    return node\n\n\ndef pre_order(root):\n    if root:\n        print(root.key, end=\" \")\n        pre_order(root.left)\n        pre_order(root.right)\n\nroot = None\n\nroot = insert(root, 10)\nroot = insert(root, 20)\nroot = insert(root, 30)\nroot = insert(root, 40)\nroot = insert(root, 50)\nroot = insert(root, 25)\n\n\n\n\n\n\n\npre_order(root)",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/avl-tree-set-1-insertion/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "// C++ program to show segment tree operations like construction, query\n// and update\n#include <bits/stdc++.h>\nusing namespace std;\n// A utility function to get the middle index from corner indexes.\nint getMid(int s, int e) { return s + (e -s)/2; }\n/* A recursive function to get the sum of values in the given range\n    of the array. The following are parameters for this function.\n    st --> Pointer to segment tree\n    si --> Index of current node in the segment tree. Initially\n            0 is passed as root is always at index 0\n    ss & se --> Starting and ending indexes of the segment represented\n                by current node, i.e., st[si]\n    qs & qe --> Starting and ending indexes of query range */\nint getSumUtil(int *st, int ss, int se, int qs, int qe, int si)\n{\n    // If segment of this node is a part of given range, then return\n    // the sum of the segment\n    if (qs <= ss && qe >= se)\n        return st[si];\n    // If segment of this node is outside the given range\n    if (se < qs || ss > qe)\n        return 0;\n    // If a part of this segment overlaps with the given range\n    int mid = getMid(ss, se);\n    return getSumUtil(st, ss, mid, qs, qe, 2*si+1) +\n        getSumUtil(st, mid+1, se, qs, qe, 2*si+2);\n}\n/* A recursive function to update the nodes which have the given\nindex in their range. The following are parameters\n    st, si, ss and se are same as getSumUtil()\n    i --> index of the element to be updated. This index is\n            in the input array.\ndiff --> Value to be added to all nodes which have i in range */\nvoid updateValueUtil(int *st, int ss, int se, int i, int diff, int si)\n{\n    // Base Case: If the input index lies outside the range of\n    // this segment\n    if (i < ss || i > se)\n        return;\n    // If the input index is in range of this node, then update\n    // the value of the node and its children\n    st[si] = st[si] + diff;\n    if (se != ss)\n    {\n        int mid = getMid(ss, se);\n        updateValueUtil(st, ss, mid, i, diff, 2*si + 1);\n        updateValueUtil(st, mid+1, se, i, diff, 2*si + 2);\n    }\n}\n// The function to update a value in input array and segment tree.\n// It uses updateValueUtil() to update the value in segment tree\nvoid updateValue(int arr[], int *st, int n, int i, int new_val)\n{\n    // Check for erroneous input index\n    if (i < 0 || i > n-1)\n    {\n        cout<<\"Invalid Input\";\n        return;\n    }\n    // Get the difference between new value and old value\n    int diff = new_val - arr[i];\n    // Update the value in array\n    arr[i] = new_val;\n    // Update the values of nodes in segment tree\n    updateValueUtil(st, 0, n-1, i, diff, 0);\n}\n// Return sum of elements in range from index qs (query start)\n// to qe (query end). It mainly uses getSumUtil()\nint getSum(int *st, int n, int qs, int qe)\n{\n    // Check for erroneous input values\n    if (qs < 0 || qe > n-1 || qs > qe)\n    {\n        cout<<\"Invalid Input\";\n        return -1;\n    }\n    return getSumUtil(st, 0, n-1, qs, qe, 0);\n}\n// A recursive function that constructs Segment Tree for array[ss..se].\n// si is index of current node in segment tree st\nint constructSTUtil(int arr[], int ss, int se, int *st, int si)\n{\n    // If there is one element in array, store it in current node of\n    // segment tree and return\n    if (ss == se)\n    {\n        st[si] = arr[ss];\n        return arr[ss];\n    }\n    // If there are more than one elements, then recur for left and\n    // right subtrees and store the sum of values in this node\n    int mid = getMid(ss, se);\n    st[si] = constructSTUtil(arr, ss, mid, st, si*2+1) +\n            constructSTUtil(arr, mid+1, se, st, si*2+2);\n    return st[si];\n}\n/* Function to construct segment tree from given array. This function\nallocates memory for segment tree and calls constructSTUtil() to\nfill the allocated memory */\nint *constructST(int arr[], int n)\n{\n    // Allocate memory for the segment tree\n    //Height of segment tree\n    int x = (int)(ceil(log2(n)));\n    //Maximum size of segment tree\n    int max_size = 2*(int)pow(2, x) - 1;\n    // Allocate memory\n    int *st = new int[max_size];\n    // Fill the allocated memory st\n    constructSTUtil(arr, 0, n-1, st, 0);\n    // Return the constructed segment tree\n    return st;\n}\n// Driver program to test above functions\nint main()\n{\n    int arr[] = {1, 3, 5, 7, 9, 11};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    // Build segment tree from given array\n    int *st = constructST(arr, n);\n    // Print sum of values in array from index 1 to 3\n    cout<<\"Sum of values in given range = \"<<getSum(st, n, 1, 3)<<endl;\n    // Update: set arr[1] = 10 and update corresponding\n    // segment tree nodes\n    updateValue(arr, st, n, 1, 10);\n    // Find sum after the value is updated\n    cout<<\"Updated sum of values in given range = \"\n            <<getSum(st, n, 1, 3)<<endl;\n    return 0;\n}\n//This code is contributed by rathbhupendra",
    "code_without_comments": "\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMid(int s, int e) { return s + (e -s)/2; }\n\nint getSumUtil(int *st, int ss, int se, int qs, int qe, int si)\n{\n\n\n    if (qs <= ss && qe >= se)\n        return st[si];\n\n    if (se < qs || ss > qe)\n        return 0;\n\n    int mid = getMid(ss, se);\n    return getSumUtil(st, ss, mid, qs, qe, 2*si+1) +\n        getSumUtil(st, mid+1, se, qs, qe, 2*si+2);\n}\n\nvoid updateValueUtil(int *st, int ss, int se, int i, int diff, int si)\n{\n\n\n    if (i < ss || i > se)\n        return;\n\n\n    st[si] = st[si] + diff;\n    if (se != ss)\n    {\n        int mid = getMid(ss, se);\n        updateValueUtil(st, ss, mid, i, diff, 2*si + 1);\n        updateValueUtil(st, mid+1, se, i, diff, 2*si + 2);\n    }\n}\n\n\nvoid updateValue(int arr[], int *st, int n, int i, int new_val)\n{\n\n    if (i < 0 || i > n-1)\n    {\n        cout<<\"Invalid Input\";\n        return;\n    }\n\n    int diff = new_val - arr[i];\n\n    arr[i] = new_val;\n\n    updateValueUtil(st, 0, n-1, i, diff, 0);\n}\n\n\nint getSum(int *st, int n, int qs, int qe)\n{\n\n    if (qs < 0 || qe > n-1 || qs > qe)\n    {\n        cout<<\"Invalid Input\";\n        return -1;\n    }\n    return getSumUtil(st, 0, n-1, qs, qe, 0);\n}\n\n\nint constructSTUtil(int arr[], int ss, int se, int *st, int si)\n{\n\n\n    if (ss == se)\n    {\n        st[si] = arr[ss];\n        return arr[ss];\n    }\n\n\n    int mid = getMid(ss, se);\n    st[si] = constructSTUtil(arr, ss, mid, st, si*2+1) +\n            constructSTUtil(arr, mid+1, se, st, si*2+2);\n    return st[si];\n}\n\nint *constructST(int arr[], int n)\n{\n\n\n    int x = (int)(ceil(log2(n)));\n\n    int max_size = 2*(int)pow(2, x) - 1;\n\n    int *st = new int[max_size];\n\n    constructSTUtil(arr, 0, n-1, st, 0);\n\n    return st;\n}\n\nint main()\n{\n    int arr[] = {1, 3, 5, 7, 9, 11};\n    int n = sizeof(arr)/sizeof(arr[0]);\n\n    int *st = constructST(arr, n);\n\n    cout<<\"Sum of values in given range = \"<<getSum(st, n, 1, 3)<<endl;\n\n\n    updateValue(arr, st, n, 1, 10);\n\n    cout<<\"Updated sum of values in given range = \"\n            <<getSum(st, n, 1, 3)<<endl;\n    return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "// C program to show segment tree operations like construction, query\n// and update\n#include <stdio.h>\n#include <math.h>\n// A utility function to get the middle index from corner indexes.\nint getMid(int s, int e) {  return s + (e -s)/2;  }\n/*  A recursive function to get the sum of values in given range\n    of the array. The following are parameters for this function.\n    st    --> Pointer to segment tree\n    si    --> Index of current node in the segment tree. Initially\n              0 is passed as root is always at index 0\n    ss & se  --> Starting and ending indexes of the segment represented\n                 by current node, i.e., st[si]\n    qs & qe  --> Starting and ending indexes of query range */\nint getSumUtil(int *st, int ss, int se, int qs, int qe, int si)\n{\n    // If segment of this node is a part of given range, then return\n    // the sum of the segment\n    if (qs <= ss && qe >= se)\n        return st[si];\n    // If segment of this node is outside the given range\n    if (se < qs || ss > qe)\n        return 0;\n    // If a part of this segment overlaps with the given range\n    int mid = getMid(ss, se);\n    return getSumUtil(st, ss, mid, qs, qe, 2*si+1) +\n           getSumUtil(st, mid+1, se, qs, qe, 2*si+2);\n}\n/* A recursive function to update the nodes which have the given\n   index in their range. The following are parameters\n    st, si, ss and se are same as getSumUtil()\n    i    --> index of the element to be updated. This index is\n             in the input array.\n   diff --> Value to be added to all nodes which have i in range */\nvoid updateValueUtil(int *st, int ss, int se, int i, int diff, int si)\n{\n    // Base Case: If the input index lies outside the range of\n    // this segment\n    if (i < ss || i > se)\n        return;\n    // If the input index is in range of this node, then update\n    // the value of the node and its children\n    st[si] = st[si] + diff;\n    if (se != ss)\n    {\n        int mid = getMid(ss, se);\n        updateValueUtil(st, ss, mid, i, diff, 2*si + 1);\n        updateValueUtil(st, mid+1, se, i, diff, 2*si + 2);\n    }\n}\n// The function to update a value in input array and segment tree.\n// It uses updateValueUtil() to update the value in segment tree\nvoid updateValue(int arr[], int *st, int n, int i, int new_val)\n{\n    // Check for erroneous input index\n    if (i < 0 || i > n-1)\n    {\n        printf(\"Invalid Input\");\n        return;\n    }\n    // Get the difference between new value and old value\n    int diff = new_val - arr[i];\n    // Update the value in array\n    arr[i] = new_val;\n    // Update the values of nodes in segment tree\n    updateValueUtil(st, 0, n-1, i, diff, 0);\n}\n// Return sum of elements in range from index qs (query start)\n// to qe (query end).  It mainly uses getSumUtil()\nint getSum(int *st, int n, int qs, int qe)\n{\n    // Check for erroneous input values\n    if (qs < 0 || qe > n-1 || qs > qe)\n    {\n        printf(\"Invalid Input\");\n        return -1;\n    }\n    return getSumUtil(st, 0, n-1, qs, qe, 0);\n}\n// A recursive function that constructs Segment Tree for array[ss..se].\n// si is index of current node in segment tree st\nint constructSTUtil(int arr[], int ss, int se, int *st, int si)\n{\n    // If there is one element in array, store it in current node of\n    // segment tree and return\n    if (ss == se)\n    {\n        st[si] = arr[ss];\n        return arr[ss];\n    }\n    // If there are more than one elements, then recur for left and\n    // right subtrees and store the sum of values in this node\n    int mid = getMid(ss, se);\n    st[si] =  constructSTUtil(arr, ss, mid, st, si*2+1) +\n              constructSTUtil(arr, mid+1, se, st, si*2+2);\n    return st[si];\n}\n/* Function to construct segment tree from given array. This function\n   allocates memory for segment tree and calls constructSTUtil() to\n   fill the allocated memory */\nint *constructST(int arr[], int n)\n{\n    // Allocate memory for the segment tree\n    //Height of segment tree\n    int x = (int)(ceil(log2(n)));\n    //Maximum size of segment tree\n    int max_size = 2*(int)pow(2, x) - 1;\n    // Allocate memory\n    int *st = new int[max_size];\n    // Fill the allocated memory st\n    constructSTUtil(arr, 0, n-1, st, 0);\n    // Return the constructed segment tree\n    return st;\n}\n// Driver program to test above functions\nint main()\n{\n    int arr[] = {1, 3, 5, 7, 9, 11};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    // Build segment tree from given array\n    int *st = constructST(arr, n);\n    // Print sum of values in array from index 1 to 3\n    printf(\"Sum of values in given range = %dn\",\n            getSum(st, n, 1, 3));\n    // Update: set arr[1] = 10 and update corresponding\n    // segment tree nodes\n    updateValue(arr, st, n, 1, 10);\n    // Find sum after the value is updated\n    printf(\"Updated sum of values in given range = %dn\",\n             getSum(st, n, 1, 3));\n    return 0;\n}",
    "code_without_comments": "\n\n#include <stdio.h>\n#include <math.h>\n\nint getMid(int s, int e) {  return s + (e -s)/2;  }\n\nint getSumUtil(int *st, int ss, int se, int qs, int qe, int si)\n{\n\n\n    if (qs <= ss && qe >= se)\n        return st[si];\n\n    if (se < qs || ss > qe)\n        return 0;\n\n    int mid = getMid(ss, se);\n    return getSumUtil(st, ss, mid, qs, qe, 2*si+1) +\n           getSumUtil(st, mid+1, se, qs, qe, 2*si+2);\n}\n\nvoid updateValueUtil(int *st, int ss, int se, int i, int diff, int si)\n{\n\n\n    if (i < ss || i > se)\n        return;\n\n\n    st[si] = st[si] + diff;\n    if (se != ss)\n    {\n        int mid = getMid(ss, se);\n        updateValueUtil(st, ss, mid, i, diff, 2*si + 1);\n        updateValueUtil(st, mid+1, se, i, diff, 2*si + 2);\n    }\n}\n\n\nvoid updateValue(int arr[], int *st, int n, int i, int new_val)\n{\n\n    if (i < 0 || i > n-1)\n    {\n        printf(\"Invalid Input\");\n        return;\n    }\n\n    int diff = new_val - arr[i];\n\n    arr[i] = new_val;\n\n    updateValueUtil(st, 0, n-1, i, diff, 0);\n}\n\n\nint getSum(int *st, int n, int qs, int qe)\n{\n\n    if (qs < 0 || qe > n-1 || qs > qe)\n    {\n        printf(\"Invalid Input\");\n        return -1;\n    }\n    return getSumUtil(st, 0, n-1, qs, qe, 0);\n}\n\n\nint constructSTUtil(int arr[], int ss, int se, int *st, int si)\n{\n\n\n    if (ss == se)\n    {\n        st[si] = arr[ss];\n        return arr[ss];\n    }\n\n\n    int mid = getMid(ss, se);\n    st[si] =  constructSTUtil(arr, ss, mid, st, si*2+1) +\n              constructSTUtil(arr, mid+1, se, st, si*2+2);\n    return st[si];\n}\n\nint *constructST(int arr[], int n)\n{\n\n\n    int x = (int)(ceil(log2(n)));\n\n    int max_size = 2*(int)pow(2, x) - 1;\n\n    int *st = new int[max_size];\n\n    constructSTUtil(arr, 0, n-1, st, 0);\n\n    return st;\n}\n\nint main()\n{\n    int arr[] = {1, 3, 5, 7, 9, 11};\n    int n = sizeof(arr)/sizeof(arr[0]);\n\n    int *st = constructST(arr, n);\n\n    printf(\"Sum of values in given range = %dn\",\n            getSum(st, n, 1, 3));\n\n\n    updateValue(arr, st, n, 1, 10);\n\n    printf(\"Updated sum of values in given range = %dn\",\n             getSum(st, n, 1, 3));\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "// Java Program to show segment tree operations like construction,\n// query and update\nimport java.io.*;\npublic class SegmentTree\n{\n    int st[]; // The array that stores segment tree nodes\n    /* Constructor to construct segment tree from given array. This\n       constructor  allocates memory for segment tree and calls\n       constructSTUtil() to  fill the allocated memory */\n    SegmentTree(int arr[], int n)\n    {\n        // Allocate memory for segment tree\n        //Height of segment tree\n        int x = (int) (Math.ceil(Math.log(n) / Math.log(2)));\n        //Maximum size of segment tree\n        int max_size = 2 * (int) Math.pow(2, x) - 1;\n        st = new int[max_size]; // Memory allocation\n        constructSTUtil(arr, 0, n - 1, 0);\n    }\n    // A utility function to get the middle index from corner indexes.\n    int getMid(int s, int e) {\n        return s + (e - s) / 2;\n    }\n    /*  A recursive function to get the sum of values in given range\n        of the array.  The following are parameters for this function.\n      st    --> Pointer to segment tree\n      si    --> Index of current node in the segment tree. Initially\n                0 is passed as root is always at index 0\n      ss & se  --> Starting and ending indexes of the segment represented\n                    by current node, i.e., st[si]\n      qs & qe  --> Starting and ending indexes of query range */\n    int getSumUtil(int ss, int se, int qs, int qe, int si)\n    {\n        // If segment of this node is a part of given range, then return\n        // the sum of the segment\n        if (qs <= ss && qe >= se)\n            return st[si];\n        // If segment of this node is outside the given range\n        if (se < qs || ss > qe)\n            return 0;\n        // If a part of this segment overlaps with the given range\n        int mid = getMid(ss, se);\n        return getSumUtil(ss, mid, qs, qe, 2 * si + 1) +\n                getSumUtil(mid + 1, se, qs, qe, 2 * si + 2);\n    }\n    /* A recursive function to update the nodes which have the given\n       index in their range. The following are parameters\n        st, si, ss and se are same as getSumUtil()\n        i    --> index of the element to be updated. This index is in\n                 input array.\n       diff --> Value to be added to all nodes which have i in range */\n    void updateValueUtil(int ss, int se, int i, int diff, int si)\n    {\n        // Base Case: If the input index lies outside the range of\n        // this segment\n        if (i < ss || i > se)\n            return;\n        // If the input index is in range of this node, then update the\n        // value of the node and its children\n        st[si] = st[si] + diff;\n        if (se != ss) {\n            int mid = getMid(ss, se);\n            updateValueUtil(ss, mid, i, diff, 2 * si + 1);\n            updateValueUtil(mid + 1, se, i, diff, 2 * si + 2);\n        }\n    }\n    // The function to update a value in input array and segment tree.\n   // It uses updateValueUtil() to update the value in segment tree\n    void updateValue(int arr[], int n, int i, int new_val)\n    {\n        // Check for erroneous input index\n        if (i < 0 || i > n - 1) {\n            System.out.println(\"Invalid Input\");\n            return;\n        }\n        // Get the difference between new value and old value\n        int diff = new_val - arr[i];\n        // Update the value in array\n        arr[i] = new_val;\n        // Update the values of nodes in segment tree\n        updateValueUtil(0, n - 1, i, diff, 0);\n    }\n    // Return sum of elements in range from index qs (query start) to\n   // qe (query end).  It mainly uses getSumUtil()\n    int getSum(int n, int qs, int qe)\n    {\n        // Check for erroneous input values\n        if (qs < 0 || qe > n - 1 || qs > qe) {\n            System.out.println(\"Invalid Input\");\n            return -1;\n        }\n        return getSumUtil(0, n - 1, qs, qe, 0);\n    }\n    // A recursive function that constructs Segment Tree for array[ss..se].\n    // si is index of current node in segment tree st\n    int constructSTUtil(int arr[], int ss, int se, int si)\n    {\n        // If there is one element in array, store it in current node of\n        // segment tree and return\n        if (ss == se) {\n            st[si] = arr[ss];\n            return arr[ss];\n        }\n        // If there are more than one elements, then recur for left and\n        // right subtrees and store the sum of values in this node\n        int mid = getMid(ss, se);\n        st[si] = constructSTUtil(arr, ss, mid, si * 2 + 1) +\n                 constructSTUtil(arr, mid + 1, se, si * 2 + 2);\n        return st[si];\n    }\n    // Driver program to test above functions\n    public static void main(String args[])\n    {\n        int arr[] = {1, 3, 5, 7, 9, 11};\n        int n = arr.length;\n        SegmentTree  tree = new SegmentTree(arr, n);\n        // Build segment tree from given array\n        // Print sum of values in array from index 1 to 3\n        System.out.println(\"Sum of values in given range = \" +\n                           tree.getSum(n, 1, 3));\n        // Update: set arr[1] = 10 and update corresponding segment\n        // tree nodes\n        tree.updateValue(arr, n, 1, 10);\n        // Find sum after the value is updated\n        System.out.println(\"Updated sum of values in given range = \" +\n                tree.getSum(n, 1, 3));\n    }\n}\n//This code is contributed by Ankur Narain Verma",
    "code_without_comments": "// Java Program to show segment tree operations like construction,\n// query and update\nimport java.io.*;\npublic class SegmentTree\n{\n    int st[]; // The array that stores segment tree nodes\n    /* Constructor to construct segment tree from given array. This\n       constructor  allocates memory for segment tree and calls\n       constructSTUtil() to  fill the allocated memory */\n    SegmentTree(int arr[], int n)\n    {\n        // Allocate memory for segment tree\n        //Height of segment tree\n        int x = (int) (Math.ceil(Math.log(n) / Math.log(2)));\n        //Maximum size of segment tree\n        int max_size = 2 * (int) Math.pow(2, x) - 1;\n        st = new int[max_size]; // Memory allocation\n        constructSTUtil(arr, 0, n - 1, 0);\n    }\n    // A utility function to get the middle index from corner indexes.\n    int getMid(int s, int e) {\n        return s + (e - s) / 2;\n    }\n    /*  A recursive function to get the sum of values in given range\n        of the array.  The following are parameters for this function.\n      st    --> Pointer to segment tree\n      si    --> Index of current node in the segment tree. Initially\n                0 is passed as root is always at index 0\n      ss & se  --> Starting and ending indexes of the segment represented\n                    by current node, i.e., st[si]\n      qs & qe  --> Starting and ending indexes of query range */\n    int getSumUtil(int ss, int se, int qs, int qe, int si)\n    {\n        // If segment of this node is a part of given range, then return\n        // the sum of the segment\n        if (qs <= ss && qe >= se)\n            return st[si];\n        // If segment of this node is outside the given range\n        if (se < qs || ss > qe)\n            return 0;\n        // If a part of this segment overlaps with the given range\n        int mid = getMid(ss, se);\n        return getSumUtil(ss, mid, qs, qe, 2 * si + 1) +\n                getSumUtil(mid + 1, se, qs, qe, 2 * si + 2);\n    }\n    /* A recursive function to update the nodes which have the given\n       index in their range. The following are parameters\n        st, si, ss and se are same as getSumUtil()\n        i    --> index of the element to be updated. This index is in\n                 input array.\n       diff --> Value to be added to all nodes which have i in range */\n    void updateValueUtil(int ss, int se, int i, int diff, int si)\n    {\n        // Base Case: If the input index lies outside the range of\n        // this segment\n        if (i < ss || i > se)\n            return;\n        // If the input index is in range of this node, then update the\n        // value of the node and its children\n        st[si] = st[si] + diff;\n        if (se != ss) {\n            int mid = getMid(ss, se);\n            updateValueUtil(ss, mid, i, diff, 2 * si + 1);\n            updateValueUtil(mid + 1, se, i, diff, 2 * si + 2);\n        }\n    }\n    // The function to update a value in input array and segment tree.\n   // It uses updateValueUtil() to update the value in segment tree\n    void updateValue(int arr[], int n, int i, int new_val)\n    {\n        // Check for erroneous input index\n        if (i < 0 || i > n - 1) {\n            System.out.println(\"Invalid Input\");\n            return;\n        }\n        // Get the difference between new value and old value\n        int diff = new_val - arr[i];\n        // Update the value in array\n        arr[i] = new_val;\n        // Update the values of nodes in segment tree\n        updateValueUtil(0, n - 1, i, diff, 0);\n    }\n    // Return sum of elements in range from index qs (query start) to\n   // qe (query end).  It mainly uses getSumUtil()\n    int getSum(int n, int qs, int qe)\n    {\n        // Check for erroneous input values\n        if (qs < 0 || qe > n - 1 || qs > qe) {\n            System.out.println(\"Invalid Input\");\n            return -1;\n        }\n        return getSumUtil(0, n - 1, qs, qe, 0);\n    }\n    // A recursive function that constructs Segment Tree for array[ss..se].\n    // si is index of current node in segment tree st\n    int constructSTUtil(int arr[], int ss, int se, int si)\n    {\n        // If there is one element in array, store it in current node of\n        // segment tree and return\n        if (ss == se) {\n            st[si] = arr[ss];\n            return arr[ss];\n        }\n        // If there are more than one elements, then recur for left and\n        // right subtrees and store the sum of values in this node\n        int mid = getMid(ss, se);\n        st[si] = constructSTUtil(arr, ss, mid, si * 2 + 1) +\n                 constructSTUtil(arr, mid + 1, se, si * 2 + 2);\n        return st[si];\n    }\n    // Driver program to test above functions\n    public static void main(String args[])\n    {\n        int arr[] = {1, 3, 5, 7, 9, 11};\n        int n = arr.length;\n        SegmentTree  tree = new SegmentTree(arr, n);\n        // Build segment tree from given array\n        // Print sum of values in array from index 1 to 3\n        System.out.println(\"Sum of values in given range = \" +\n                           tree.getSum(n, 1, 3));\n        // Update: set arr[1] = 10 and update corresponding segment\n        // tree nodes\n        tree.updateValue(arr, n, 1, 10);\n        // Find sum after the value is updated\n        System.out.println(\"Updated sum of values in given range = \" +\n                tree.getSum(n, 1, 3));\n    }\n}\n//This code is contributed by Ankur Narain Verma",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "# Python3 program to show segment tree operations like\n# construction, query and update\nfrom math import ceil, log2;\n# A utility function to get the\n# middle index from corner indexes.\ndef getMid(s, e) :\n    return s + (e -s) // 2;\n\"\"\" A recursive function to get the sum of values\n    in the given range of the array. The following\n    are parameters for this function.\n    st --> Pointer to segment tree\n    si --> Index of current node in the segment tree.\n           Initially 0 is passed as root is always at index 0\n    ss & se --> Starting and ending indexes of the segment\n                represented by current node, i.e., st[si]\n    qs & qe --> Starting and ending indexes of query range \"\"\"\ndef getSumUtil(st, ss, se, qs, qe, si) :\n    # If segment of this node is a part of given range,\n    # then return the sum of the segment\n    if (qs <= ss and qe >= se) :\n        return st[si];\n    # If segment of this node is\n    # outside the given range\n    if (se < qs or ss > qe) :\n        return 0;\n    # If a part of this segment overlaps\n    # with the given range\n    mid = getMid(ss, se);\n    return (getSumUtil(st, ss, mid, qs, qe, 2 * si + 1) +\n           getSumUtil(st, mid + 1, se, qs, qe, 2 * si + 2));\n\"\"\" A recursive function to update the nodes\nwhich have the given index in their range.\nThe following are parameters st, si, ss and se\nare same as getSumUtil()\ni --> index of the element to be updated.\n      This index is in the input array.\ndiff --> Value to be added to all nodes\nwhich have i in range \"\"\"\ndef updateValueUtil(st, ss, se, i, diff, si) :\n    # Base Case: If the input index lies\n    # outside the range of this segment\n    if (i < ss or i > se) :\n        return;\n    # If the input index is in range of this node,\n    # then update the value of the node and its children\n    st[si] = st[si] + diff;\n    if (se != ss) :\n        mid = getMid(ss, se);\n        updateValueUtil(st, ss, mid, i,\n                        diff, 2 * si + 1);\n        updateValueUtil(st, mid + 1, se, i,\n                         diff, 2 * si + 2);\n# The function to update a value in input array\n# and segment tree. It uses updateValueUtil()\n# to update the value in segment tree\ndef updateValue(arr, st, n, i, new_val) :\n    # Check for erroneous input index\n    if (i < 0 or i > n - 1) :\n        print(\"Invalid Input\", end = \"\");\n        return;\n    # Get the difference between\n    # new value and old value\n    diff = new_val - arr[i];\n    # Update the value in array\n    arr[i] = new_val;\n    # Update the values of nodes in segment tree\n    updateValueUtil(st, 0, n - 1, i, diff, 0);\n# Return sum of elements in range from\n# index qs (query start) to qe (query end).\n# It mainly uses getSumUtil()\ndef getSum(st, n, qs, qe) :\n    # Check for erroneous input values\n    if (qs < 0 or qe > n - 1 or qs > qe) :\n        print(\"Invalid Input\", end = \"\");\n        return -1;\n    return getSumUtil(st, 0, n - 1, qs, qe, 0);\n# A recursive function that constructs\n# Segment Tree for array[ss..se].\n# si is index of current node in segment tree st\ndef constructSTUtil(arr, ss, se, st, si) :\n    # If there is one element in array,\n    # store it in current node of\n    # segment tree and return\n    if (ss == se) :\n        st[si] = arr[ss];\n        return arr[ss];\n    # If there are more than one elements,\n    # then recur for left and right subtrees\n    # and store the sum of values in this node\n    mid = getMid(ss, se);\n    st[si] = (constructSTUtil(arr, ss, mid, st, si * 2 + 1) +\n             constructSTUtil(arr, mid + 1, se, st, si * 2 + 2));\n    return st[si];\n\"\"\" Function to construct segment tree\nfrom given array. This function allocates memory\nfor segment tree and calls constructSTUtil() to\nfill the allocated memory \"\"\"\ndef constructST(arr, n) :\n    # Allocate memory for the segment tree\n    # Height of segment tree\n    x = (int)(ceil(log2(n)));\n    # Maximum size of segment tree\n    max_size = 2 * (int)(2**x) - 1;\n    # Allocate memory\n    st = [0] * max_size;\n    # Fill the allocated memory st\n    constructSTUtil(arr, 0, n - 1, st, 0);\n    # Return the constructed segment tree\n    return st;\n# Driver Code\nif __name__ == \"__main__\" :\n    arr = [1, 3, 5, 7, 9, 11];\n    n = len(arr);\n    # Build segment tree from given array\n    st = constructST(arr, n);\n    # Print sum of values in array from index 1 to 3\n    print(\"Sum of values in given range = \",\n                       getSum(st, n, 1, 3));\n    # Update: set arr[1] = 10 and update\n    # corresponding segment tree nodes\n    updateValue(arr, st, n, 1, 10);\n    # Find sum after the value is updated\n    print(\"Updated sum of values in given range = \",\n                     getSum(st, n, 1, 3), end = \"\");\n# This code is contributed by AnkitRai01",
    "code_without_comments": "\n\nfrom math import ceil, log2;\n\n\ndef getMid(s, e) :\n    return s + (e -s) // 2;\n\"\"\" A recursive function to get the sum of values\n    in the given range of the array. The following\n    are parameters for this function.\n    st --> Pointer to segment tree\n    si --> Index of current node in the segment tree.\n           Initially 0 is passed as root is always at index 0\n    ss & se --> Starting and ending indexes of the segment\n                represented by current node, i.e., st[si]\n    qs & qe --> Starting and ending indexes of query range \"\"\"\ndef getSumUtil(st, ss, se, qs, qe, si) :\n\n\n    if (qs <= ss and qe >= se) :\n        return st[si];\n\n\n    if (se < qs or ss > qe) :\n        return 0;\n\n\n    mid = getMid(ss, se);\n    return (getSumUtil(st, ss, mid, qs, qe, 2 * si + 1) +\n           getSumUtil(st, mid + 1, se, qs, qe, 2 * si + 2));\n\"\"\" A recursive function to update the nodes\nwhich have the given index in their range.\nThe following are parameters st, si, ss and se\nare same as getSumUtil()\ni --> index of the element to be updated.\n      This index is in the input array.\ndiff --> Value to be added to all nodes\nwhich have i in range \"\"\"\ndef updateValueUtil(st, ss, se, i, diff, si) :\n\n\n    if (i < ss or i > se) :\n        return;\n\n\n    st[si] = st[si] + diff;\n    if (se != ss) :\n        mid = getMid(ss, se);\n        updateValueUtil(st, ss, mid, i,\n                        diff, 2 * si + 1);\n        updateValueUtil(st, mid + 1, se, i,\n                         diff, 2 * si + 2);\n\n\n\ndef updateValue(arr, st, n, i, new_val) :\n\n    if (i < 0 or i > n - 1) :\n        print(\"Invalid Input\", end = \"\");\n        return;\n\n\n    diff = new_val - arr[i];\n\n    arr[i] = new_val;\n\n    updateValueUtil(st, 0, n - 1, i, diff, 0);\n\n\n\ndef getSum(st, n, qs, qe) :\n\n    if (qs < 0 or qe > n - 1 or qs > qe) :\n        print(\"Invalid Input\", end = \"\");\n        return -1;\n    return getSumUtil(st, 0, n - 1, qs, qe, 0);\n\n\n\ndef constructSTUtil(arr, ss, se, st, si) :\n\n\n\n    if (ss == se) :\n        st[si] = arr[ss];\n        return arr[ss];\n\n\n\n    mid = getMid(ss, se);\n    st[si] = (constructSTUtil(arr, ss, mid, st, si * 2 + 1) +\n             constructSTUtil(arr, mid + 1, se, st, si * 2 + 2));\n    return st[si];\n\"\"\" Function to construct segment tree\nfrom given array. This function allocates memory\nfor segment tree and calls constructSTUtil() to\nfill the allocated memory \"\"\"\ndef constructST(arr, n) :\n\n\n    x = (int)(ceil(log2(n)));\n\n    max_size = 2 * (int)(2**x) - 1;\n\n    st = [0] * max_size;\n\n    constructSTUtil(arr, 0, n - 1, st, 0);\n\n    return st;\n\nif __name__ == \"__main__\" :\n    arr = [1, 3, 5, 7, 9, 11];\n    n = len(arr);\n\n    st = constructST(arr, n);\n\n    print(\"Sum of values in given range = \",\n                       getSum(st, n, 1, 3));\n\n\n    updateValue(arr, st, n, 1, 10);\n\n    print(\"Updated sum of values in given range = \",\n                     getSum(st, n, 1, 3), end = \"\");\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n// Node Structure\nclass Node {\npublic:\n    int data;\n    Node *left, *right;\n    Node(int x) {\n        data = x;\n        left = nullptr;\n        right = nullptr;\n    }\n};\n// Function to compute the height of a tree.\nint height(Node* root) {\n    if (root == nullptr)\n        return 0;\n    // If tree is not empty then height = 1 + max of left height and right heights\n    return 1 + max(height(root->left),\n                   height(root->right));\n}\n// Function to get diameter of a binary tree\nint diameter(Node* root) {\n    if (root == nullptr)\n        return 0;\n    // Get the height of left and right sub-trees\n    int lheight = height(root->left);\n    int rheight = height(root->right);\n    // Get the diameter of left and right sub-trees\n    int ldiameter = diameter(root->left);\n    int rdiameter = diameter(root->right);\n    return max({lheight + rheight, ldiameter, rdiameter});\n}\nint main() {\n    Node* root = new Node(1);\n    root->right = new Node(2);\n    root->right->left = new Node(3);\n    root->right->right = new Node(4);\n  \troot->right->left->left = new Node(5);\n  \troot->right->right->right = new Node(6);\n    cout << diameter(root) << endl;\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node *left, *right;\n    Node(int x) {\n        data = x;\n        left = nullptr;\n        right = nullptr;\n    }\n};\n\nint height(Node* root) {\n    if (root == nullptr)\n        return 0;\n\n    return 1 + max(height(root->left),\n                   height(root->right));\n}\n\nint diameter(Node* root) {\n    if (root == nullptr)\n        return 0;\n\n    int lheight = height(root->left);\n    int rheight = height(root->right);\n\n    int ldiameter = diameter(root->left);\n    int rdiameter = diameter(root->right);\n    return max({lheight + rheight, ldiameter, rdiameter});\n}\nint main() {\n    Node* root = new Node(1);\n    root->right = new Node(2);\n    root->right->left = new Node(3);\n    root->right->right = new Node(4);\n  \troot->right->left->left = new Node(5);\n  \troot->right->right->right = new Node(6);\n    cout << diameter(root) << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/diameter-of-a-binary-tree/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#include <stdio.h>\n#include <stdlib.h>\n// Node Structure\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n// Function to compute the height of a tree.\nint height(struct Node* root) {\n    if (root == NULL)\n        return 0;\n    // If tree is not empty then height = 1 + max of left height and right heights\n    int leftHeight = height(root->left);\n    int rightHeight = height(root->right);\n    return 1 +\n    (leftHeight > rightHeight ? leftHeight : rightHeight);\n}\n// Function to get diameter of a binary tree\nint diameter(struct Node* root) {\n    if (root == NULL)\n        return 0;\n    // Get the height of left and right sub-trees\n    int lheight = height(root->left);\n    int rheight = height(root->right);\n    // Get the diameter of left and right sub-trees\n    int ldiameter = diameter(root->left);\n    int rdiameter = diameter(root->right);\n    // Diameter of current subtree\n    int curr = lheight+rheight;\n    if (ldiameter > rdiameter && ldiameter > curr)\n        return ldiameter;\n    else if (rdiameter > ldiameter && rdiameter > curr)\n        return rdiameter;\n    return curr;\n}\nstruct Node* createNode(int x) {\n    struct Node* newNode =\n    \t(struct Node*)malloc(sizeof(struct Node));\n    newNode->data = x;\n    newNode->left = NULL;\n    newNode->right = NULL;\n    return newNode;\n}\nint main() {\n    struct Node* root = createNode(1);\n    root->right = createNode(2);\n    root->right->left = createNode(3);\n    root->right->right = createNode(4);\n  \troot->right->left->left = createNode(5);\n  \troot->right->right->right = createNode(6);\n    printf(\"%d\\n\", diameter(root));\n    return 0;\n}",
    "code_without_comments": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\nint height(struct Node* root) {\n    if (root == NULL)\n        return 0;\n\n    int leftHeight = height(root->left);\n    int rightHeight = height(root->right);\n    return 1 +\n    (leftHeight > rightHeight ? leftHeight : rightHeight);\n}\n\nint diameter(struct Node* root) {\n    if (root == NULL)\n        return 0;\n\n    int lheight = height(root->left);\n    int rheight = height(root->right);\n\n    int ldiameter = diameter(root->left);\n    int rdiameter = diameter(root->right);\n\n    int curr = lheight+rheight;\n    if (ldiameter > rdiameter && ldiameter > curr)\n        return ldiameter;\n    else if (rdiameter > ldiameter && rdiameter > curr)\n        return rdiameter;\n    return curr;\n}\nstruct Node* createNode(int x) {\n    struct Node* newNode =\n    \t(struct Node*)malloc(sizeof(struct Node));\n    newNode->data = x;\n    newNode->left = NULL;\n    newNode->right = NULL;\n    return newNode;\n}\nint main() {\n    struct Node* root = createNode(1);\n    root->right = createNode(2);\n    root->right->left = createNode(3);\n    root->right->right = createNode(4);\n  \troot->right->left->left = createNode(5);\n  \troot->right->right->right = createNode(6);\n    printf(\"%d\\n\", diameter(root));\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/diameter-of-a-binary-tree/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "# Node Structure\nclass Node:\n    def __init__(self, x):\n        self.data = x\n        self.left = None\n        self.right = None\n# Function to compute the height of a tree\ndef height(root):\n    if root is None:\n        return 0\n    # If tree is not empty then height = 1 + max of left height and right heights\n    return 1 + max(height(root.left), height(root.right))\n# Function to get diameter of a binary tree\ndef diameter(root):\n    if root is None:\n        return 0\n    # Get the height of left and right sub-trees\n    lheight = height(root.left)\n    rheight = height(root.right)\n    # Get the diameter of left and right sub-trees\n    ldiameter = diameter(root.left)\n    rdiameter = diameter(root.right)\n    return max(lheight + rheight, ldiameter, rdiameter)\nif __name__ == \"__main__\":\n    root = Node(1)\n    root.right = Node(2)\n    root.right.left = Node(3)\n    root.right.right = Node(4)\n    root.right.left.left = Node(5)\n    root.right.right.right = Node(6)\n    print(diameter(root))",
    "code_without_comments": "\nclass Node:\n    def __init__(self, x):\n        self.data = x\n        self.left = None\n        self.right = None\n\ndef height(root):\n    if root is None:\n        return 0\n\n    return 1 + max(height(root.left), height(root.right))\n\ndef diameter(root):\n    if root is None:\n        return 0\n\n    lheight = height(root.left)\n    rheight = height(root.right)\n\n    ldiameter = diameter(root.left)\n    rdiameter = diameter(root.right)\n    return max(lheight + rheight, ldiameter, rdiameter)\nif __name__ == \"__main__\":\n    root = Node(1)\n    root.right = Node(2)\n    root.right.left = Node(3)\n    root.right.right = Node(4)\n    root.right.left.left = Node(5)\n    root.right.right.right = Node(6)\n    print(diameter(root))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/diameter-of-a-binary-tree/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#include <iostream>\nusing namespace std;\n// Node Structure\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(int x) {\n        data = x;\n        left = nullptr;\n        right = nullptr;\n    }\n};\n// Global variable to store the maximum diameter\nint maxDiameter = 0;\nint diameterRecur(Node* root) {\n    if (!root)\n        return 0;\n    // Find the height of left and right subtree\n    int lHeight = diameterRecur(root->left);\n    int rHeight = diameterRecur(root->right);\n    // Update the global max diameter if this node gives a longer path\n    if (lHeight + rHeight > maxDiameter)\n        maxDiameter = lHeight + rHeight;\n    // Return height of current subtree\n    return 1 + max(lHeight, rHeight);\n}\n// Function to get diameter of a binary tree\nint diameter(Node* root) {\n    maxDiameter = 0;\n    diameterRecur(root);\n    return maxDiameter;\n}\nint main() {\n    Node* root = new Node(1);\n    root->right = new Node(2);\n    root->right->left = new Node(3);\n    root->right->right = new Node(4);\n  \troot->right->left->left = new Node(5);\n  \troot->right->right->right = new Node(6);\n    cout << diameter(root) << endl;\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(int x) {\n        data = x;\n        left = nullptr;\n        right = nullptr;\n    }\n};\n\nint maxDiameter = 0;\nint diameterRecur(Node* root) {\n    if (!root)\n        return 0;\n\n    int lHeight = diameterRecur(root->left);\n    int rHeight = diameterRecur(root->right);\n\n    if (lHeight + rHeight > maxDiameter)\n        maxDiameter = lHeight + rHeight;\n\n    return 1 + max(lHeight, rHeight);\n}\n\nint diameter(Node* root) {\n    maxDiameter = 0;\n    diameterRecur(root);\n    return maxDiameter;\n}\nint main() {\n    Node* root = new Node(1);\n    root->right = new Node(2);\n    root->right->left = new Node(3);\n    root->right->right = new Node(4);\n  \troot->right->left->left = new Node(5);\n  \troot->right->right->right = new Node(6);\n    cout << diameter(root) << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/diameter-of-a-binary-tree/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#include <stdio.h>\n#include <stdlib.h>\n// Node Structure\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n// Function to create a new Node\nstruct Node* createNode(int x) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = x;\n    node->left = NULL;\n    node->right = NULL;\n    return node;\n}\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n// Global variable to store the maximum diameter\nint maxDiameter = 0;\nint diameterRecur(struct Node* root) {\n    if (root == NULL)\n        return 0;\n    // Find the height of left and right subtree\n    int lHeight = diameterRecur(root->left);\n    int rHeight = diameterRecur(root->right);\n    // Update the global max diameter if this node gives a longer path\n    if (lHeight + rHeight > maxDiameter)\n        maxDiameter = lHeight + rHeight;\n    // Return height of current subtree\n    return 1 + max(lHeight, rHeight);\n}\n// Function to get diameter of a binary tree\nint diameter(struct Node* root) {\n    maxDiameter = 0;\n    diameterRecur(root);\n    return maxDiameter;\n}\nint main() {\n    struct Node* root = createNode(1);\n    root->right = createNode(2);\n    root->right->left = createNode(3);\n    root->right->right = createNode(4);\n  \troot->right->left->left = createNode(5);\n  \troot->right->right->right = createNode(6);\n    printf(\"%d\\n\", diameter(root));\n    return 0;\n}",
    "code_without_comments": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\nstruct Node* createNode(int x) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = x;\n    node->left = NULL;\n    node->right = NULL;\n    return node;\n}\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint maxDiameter = 0;\nint diameterRecur(struct Node* root) {\n    if (root == NULL)\n        return 0;\n\n    int lHeight = diameterRecur(root->left);\n    int rHeight = diameterRecur(root->right);\n\n    if (lHeight + rHeight > maxDiameter)\n        maxDiameter = lHeight + rHeight;\n\n    return 1 + max(lHeight, rHeight);\n}\n\nint diameter(struct Node* root) {\n    maxDiameter = 0;\n    diameterRecur(root);\n    return maxDiameter;\n}\nint main() {\n    struct Node* root = createNode(1);\n    root->right = createNode(2);\n    root->right->left = createNode(3);\n    root->right->right = createNode(4);\n  \troot->right->left->left = createNode(5);\n  \troot->right->right->right = createNode(6);\n    printf(\"%d\\n\", diameter(root));\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/diameter-of-a-binary-tree/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "# Node Structure\nclass Node:\n    def __init__(self, x):\n        self.data = x\n        self.left = None\n        self.right = None\n# Global variable to store the maximum diameter\nmaxDiameter = 0\n# Recursive function to calculate height and update diameter\ndef diameterRecur(root):\n    global maxDiameter\n    if root is None:\n        return 0\n    # Find the height of left and right subtree\n    lHeight = diameterRecur(root.left)\n    rHeight = diameterRecur(root.right)\n    # Update the global max diameter if this node gives a longer path\n    maxDiameter = max(maxDiameter, lHeight + rHeight)\n    # Return height of current subtree\n    return 1 + max(lHeight, rHeight)\n# Function to get diameter of a binary tree\ndef diameter(root):\n    global maxDiameter\n    maxDiameter = 0\n    diameterRecur(root)\n    return maxDiameter\nif __name__ == \"__main__\":\n    root = Node(1)\n    root.right = Node(2)\n    root.right.left = Node(3)\n    root.right.right = Node(4)\n    root.right.left.left = Node(5)\n    root.right.right.right = Node(6)\n    print(diameter(root))",
    "code_without_comments": "\nclass Node:\n    def __init__(self, x):\n        self.data = x\n        self.left = None\n        self.right = None\n\nmaxDiameter = 0\n\ndef diameterRecur(root):\n    global maxDiameter\n    if root is None:\n        return 0\n\n    lHeight = diameterRecur(root.left)\n    rHeight = diameterRecur(root.right)\n\n    maxDiameter = max(maxDiameter, lHeight + rHeight)\n\n    return 1 + max(lHeight, rHeight)\n\ndef diameter(root):\n    global maxDiameter\n    maxDiameter = 0\n    diameterRecur(root)\n    return maxDiameter\nif __name__ == \"__main__\":\n    root = Node(1)\n    root.right = Node(2)\n    root.right.left = Node(3)\n    root.right.right = Node(4)\n    root.right.left.left = Node(5)\n    root.right.right.right = Node(6)\n    print(diameter(root))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/diameter-of-a-binary-tree/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#include <iostream>\nusing namespace std;\n// Node Structure\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(int value) {\n        data = value;\n        left = right = nullptr;\n    }\n};\n// returns true if val is present\n// in the subtree of root\nbool hasNode(Node* root, Node* node) {\n    if (root == nullptr) return false;\n    return (root == node) ||\n            hasNode(root->left, node) ||\n            hasNode(root->right, node);\n}\nNode* lca(Node* root, Node* n1, Node* n2) {\n    if (root == nullptr) return nullptr;\n    if (hasNode(root->left, n1) && hasNode(root->right, n2))\n        return root;\n    if (hasNode(root->left, n2) && hasNode(root->right, n1))\n        return root;\n    Node* lcaLeft = lca(root->left, n1, n2);\n    Node* lcaRight = lca(root->right, n1, n2);\n    return lcaLeft != nullptr ? lcaLeft : lcaRight;\n}\nint main() {\n    // Create binary tree:\n    //\t\t\t   1\n    //           /   \\\n    //          2     3\n    //               / \\\n    //              6   7\n    //             /\n    //            8\n    Node* root = new Node(1);\n    root->left = new Node(2);\n    root->right = new Node(3);\n    root->right->left = new Node(6);\n    root->right->right = new Node(7);\n    root->right->left->left = new Node(8);\n    // Node 7\n    Node* n1 = root->right->right;\n    // Node 8\n    Node* n2 = root->right->left->left;\n    Node* ans = lca(root, n1, n2);\n    cout << ans->data << endl;\n}",
    "code_without_comments": "#include <iostream>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(int value) {\n        data = value;\n        left = right = nullptr;\n    }\n};\n\n\nbool hasNode(Node* root, Node* node) {\n    if (root == nullptr) return false;\n    return (root == node) ||\n            hasNode(root->left, node) ||\n            hasNode(root->right, node);\n}\nNode* lca(Node* root, Node* n1, Node* n2) {\n    if (root == nullptr) return nullptr;\n    if (hasNode(root->left, n1) && hasNode(root->right, n2))\n        return root;\n    if (hasNode(root->left, n2) && hasNode(root->right, n1))\n        return root;\n    Node* lcaLeft = lca(root->left, n1, n2);\n    Node* lcaRight = lca(root->right, n1, n2);\n    return lcaLeft != nullptr ? lcaLeft : lcaRight;\n}\nint main() {\n\n\n\n\n\n\n\n\n    Node* root = new Node(1);\n    root->left = new Node(2);\n    root->right = new Node(3);\n    root->right->left = new Node(6);\n    root->right->right = new Node(7);\n    root->right->left->left = new Node(8);\n\n    Node* n1 = root->right->right;\n\n    Node* n2 = root->right->left->left;\n    Node* ans = lca(root, n1, n2);\n    cout << ans->data << endl;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/lowest-common-ancestor-binary-tree-set-1/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n// Node Structure\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n// Create a new node\nstruct Node* newNode(int value) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = value;\n    node->left = NULL;\n    node->right = NULL;\n    return node;\n}\n// returns true if val is present\n// in the subtree of root\nbool hasNode(struct Node* root, struct Node* node) {\n    if (root == NULL) return false;\n    return (root == node) ||\n            hasNode(root->left, node) ||\n            hasNode(root->right, node);\n}\nstruct Node* lca(struct Node* root, struct Node* n1, struct Node* n2) {\n    if (root == NULL) return NULL;\n    if (hasNode(root->left, n1) && hasNode(root->right, n2))\n        return root;\n    if (hasNode(root->left, n2) && hasNode(root->right, n1))\n        return root;\n    struct Node* lcaLeft = lca(root->left, n1, n2);\n    struct Node* lcaRight = lca(root->right, n1, n2);\n    return (lcaLeft != NULL) ? lcaLeft : lcaRight;\n}\nint main() {\n    // Create binary tree:\n    //\t\t\t   1\n    //           /   \\\n    //          2     3\n    //               / \\\n    //              6   7\n    //             /\n    //            8\n    struct Node* root = newNode(1);\n    root->left = newNode(2);\n    root->right = newNode(3);\n    root->right->left = newNode(6);\n    root->right->right = newNode(7);\n    root->right->left->left = newNode(8);\n    // Node 7\n    struct Node* n1 = root->right->right;\n    // Node 8\n    struct Node* n2 = root->right->left->left;\n    struct Node* ans = lca(root, n1, n2);\n    printf(\"%d\\n\", ans->data);\n}",
    "code_without_comments": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\nstruct Node* newNode(int value) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = value;\n    node->left = NULL;\n    node->right = NULL;\n    return node;\n}\n\n\nbool hasNode(struct Node* root, struct Node* node) {\n    if (root == NULL) return false;\n    return (root == node) ||\n            hasNode(root->left, node) ||\n            hasNode(root->right, node);\n}\nstruct Node* lca(struct Node* root, struct Node* n1, struct Node* n2) {\n    if (root == NULL) return NULL;\n    if (hasNode(root->left, n1) && hasNode(root->right, n2))\n        return root;\n    if (hasNode(root->left, n2) && hasNode(root->right, n1))\n        return root;\n    struct Node* lcaLeft = lca(root->left, n1, n2);\n    struct Node* lcaRight = lca(root->right, n1, n2);\n    return (lcaLeft != NULL) ? lcaLeft : lcaRight;\n}\nint main() {\n\n\n\n\n\n\n\n\n    struct Node* root = newNode(1);\n    root->left = newNode(2);\n    root->right = newNode(3);\n    root->right->left = newNode(6);\n    root->right->right = newNode(7);\n    root->right->left->left = newNode(8);\n\n    struct Node* n1 = root->right->right;\n\n    struct Node* n2 = root->right->left->left;\n    struct Node* ans = lca(root, n1, n2);\n    printf(\"%d\\n\", ans->data);\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/lowest-common-ancestor-binary-tree-set-1/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "# Node Structure\nclass Node:\n    def __init__(self, value):\n        self.data = value\n        self.left = None\n        self.right = None\n# returns true if val is present\n# in the subtree of root\ndef hasNode(root, node):\n    if root is None:\n        return False\n    return root == node or \\\n           hasNode(root.left, node) or \\\n           hasNode(root.right, node)\ndef lca(root, n1, n2):\n    if root is None:\n        return None\n    if hasNode(root.left, n1) and hasNode(root.right, n2):\n        return root\n    if hasNode(root.left, n2) and hasNode(root.right, n1):\n        return root\n    lcaLeft = lca(root.left, n1, n2)\n    lcaRight = lca(root.right, n1, n2)\n    return lcaLeft if lcaLeft is not None else lcaRight\n# Create binary tree:\n#\t\t\t   1\n#           /   \\\n#          2     3\n#               / \\\n#              6   7\n#             /\n#            8\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.right.left = Node(6)\nroot.right.right = Node(7)\nroot.right.left.left = Node(8)\n# Node 7\nn1 = root.right.right\n# Node 8\nn2 = root.right.left.left\nans = lca(root, n1, n2)\nprint(ans.data)",
    "code_without_comments": "\nclass Node:\n    def __init__(self, value):\n        self.data = value\n        self.left = None\n        self.right = None\n\n\ndef hasNode(root, node):\n    if root is None:\n        return False\n    return root == node or \\\n           hasNode(root.left, node) or \\\n           hasNode(root.right, node)\ndef lca(root, n1, n2):\n    if root is None:\n        return None\n    if hasNode(root.left, n1) and hasNode(root.right, n2):\n        return root\n    if hasNode(root.left, n2) and hasNode(root.right, n1):\n        return root\n    lcaLeft = lca(root.left, n1, n2)\n    lcaRight = lca(root.right, n1, n2)\n    return lcaLeft if lcaLeft is not None else lcaRight\n\n\n\n\n\n\n\n\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.right.left = Node(6)\nroot.right.right = Node(7)\nroot.right.left.left = Node(8)\n\nn1 = root.right.right\n\nn2 = root.right.left.left\nans = lca(root, n1, n2)\nprint(ans.data)",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/lowest-common-ancestor-binary-tree-set-1/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\n// Node Structure\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(int value) {\n        data = value;\n        left = right = nullptr;\n    }\n};\n// Finds the path from root to given node\nbool findPath(Node* root, vector<Node*>& path, Node* n) {\n    if (root == nullptr) return false;\n    // Store current node\n    path.push_back(root);\n    if (root == n || findPath(root->left, path, n) || findPath(root->right, path, n)) {\n        return true;\n    }\n    // remove root from path and return false\n    path.pop_back();\n    return false;\n}\nNode* lca(Node* root, Node* n1, Node* n2) {\n    vector<Node*> path1, path2;\n    // Find paths from root to n1\n    // and root to n2\n    if (!findPath(root, path1, n1) || !findPath(root, path2, n2)) return nullptr;\n    // Compare the paths to get\n    // the first different value\n    int i = 0;\n    for (i = 0; i < path1.size() && i < path2.size(); i++) {\n        if (path1[i] != path2[i]) return path1[i - 1];\n    }\n    return path1[i - 1];\n}\nint main() {\n    // Create binary tree:\n    //\t\t\t   1\n    //           /   \\\n    //          2     3\n    //               / \\\n    //              6   7\n    //             /\n    //            8\n    Node* root = new Node(1);\n    root->left = new Node(2);\n    root->right = new Node(3);\n    root->right->left = new Node(6);\n    root->right->right = new Node(7);\n    root->right->left->left = new Node(8);\n    Node* n1 = root->right->right;\n    Node* n2 = root->right->left->left;\n    Node* ans = lca(root, n1, n2);\n    if (ans) cout << ans->data << endl;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(int value) {\n        data = value;\n        left = right = nullptr;\n    }\n};\n\nbool findPath(Node* root, vector<Node*>& path, Node* n) {\n    if (root == nullptr) return false;\n\n    path.push_back(root);\n    if (root == n || findPath(root->left, path, n) || findPath(root->right, path, n)) {\n        return true;\n    }\n\n    path.pop_back();\n    return false;\n}\nNode* lca(Node* root, Node* n1, Node* n2) {\n    vector<Node*> path1, path2;\n\n\n    if (!findPath(root, path1, n1) || !findPath(root, path2, n2)) return nullptr;\n\n\n    int i = 0;\n    for (i = 0; i < path1.size() && i < path2.size(); i++) {\n        if (path1[i] != path2[i]) return path1[i - 1];\n    }\n    return path1[i - 1];\n}\nint main() {\n\n\n\n\n\n\n\n\n    Node* root = new Node(1);\n    root->left = new Node(2);\n    root->right = new Node(3);\n    root->right->left = new Node(6);\n    root->right->right = new Node(7);\n    root->right->left->left = new Node(8);\n    Node* n1 = root->right->right;\n    Node* n2 = root->right->left->left;\n    Node* ans = lca(root, n1, n2);\n    if (ans) cout << ans->data << endl;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/lowest-common-ancestor-binary-tree-set-1/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n// Node Structure\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n// Create new node\nstruct Node* newNode(int value) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = value;\n    node->left = node->right = NULL;\n    return node;\n}\n// Finds the path from root to given node\nbool findPath(struct Node* root, struct Node** path, int* pathLen, struct Node* n) {\n    if (root == NULL) return false;\n    // Store current node\n    path[(*pathLen)++] = root;\n    if (root == n || findPath(root->left, path, pathLen, n) || findPath(root->right, path, pathLen, n))\n        return true;\n    // remove root from path and return false\n    (*pathLen)--;\n    return false;\n}\nstruct Node* lca(struct Node* root, struct Node* n1, struct Node* n2) {\n    struct Node* path1[100]; int len1 = 0;\n    struct Node* path2[100]; int len2 = 0;\n    // Find paths from root to n1\n    // and root to n2.\n    if (!findPath(root, path1, &len1, n1) || !findPath(root, path2, &len2, n2))\n        return NULL;\n    // Compare the paths to get the first\n    // different value\n    int i = 0;\n    for (i = 0; i < len1 && i < len2; i++) {\n        if (path1[i] != path2[i]) return path1[i-1];\n    }\n    return path1[i-1];\n}\nint main() {\n    // Create binary tree:\n    //\t\t\t   1\n    //           /   \\\n    //          2     3\n    //               / \\\n    //              6   7\n    //             /\n    //            8\n    struct Node* root = newNode(1);\n    root->left = newNode(2);\n    root->right = newNode(3);\n    root->right->left = newNode(6);\n    root->right->right = newNode(7);\n    root->right->left->left = newNode(8);\n    struct Node* n1 = root->right->right;\n    struct Node* n2 = root->right->left->left;\n    struct Node* ans = lca(root, n1, n2);\n    if (ans != NULL)\n        printf(\"%d\\n\", ans->data);\n}",
    "code_without_comments": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\nstruct Node* newNode(int value) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = value;\n    node->left = node->right = NULL;\n    return node;\n}\n\nbool findPath(struct Node* root, struct Node** path, int* pathLen, struct Node* n) {\n    if (root == NULL) return false;\n\n    path[(*pathLen)++] = root;\n    if (root == n || findPath(root->left, path, pathLen, n) || findPath(root->right, path, pathLen, n))\n        return true;\n\n    (*pathLen)--;\n    return false;\n}\nstruct Node* lca(struct Node* root, struct Node* n1, struct Node* n2) {\n    struct Node* path1[100]; int len1 = 0;\n    struct Node* path2[100]; int len2 = 0;\n\n\n    if (!findPath(root, path1, &len1, n1) || !findPath(root, path2, &len2, n2))\n        return NULL;\n\n\n    int i = 0;\n    for (i = 0; i < len1 && i < len2; i++) {\n        if (path1[i] != path2[i]) return path1[i-1];\n    }\n    return path1[i-1];\n}\nint main() {\n\n\n\n\n\n\n\n\n    struct Node* root = newNode(1);\n    root->left = newNode(2);\n    root->right = newNode(3);\n    root->right->left = newNode(6);\n    root->right->right = newNode(7);\n    root->right->left->left = newNode(8);\n    struct Node* n1 = root->right->right;\n    struct Node* n2 = root->right->left->left;\n    struct Node* ans = lca(root, n1, n2);\n    if (ans != NULL)\n        printf(\"%d\\n\", ans->data);\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/lowest-common-ancestor-binary-tree-set-1/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "# Node Structure\nclass Node:\n    def __init__(self, value):\n        self.data = value\n        self.left = None\n        self.right = None\n# Finds the path from root to given node\ndef findPath(root, path, n):\n    if root is None:\n        return False\n    # Store current node\n    path.append(root)\n    if root == n or findPath(root.left, path, n) or findPath(root.right, path, n):\n        return True\n    # remove root from path and return false\n    path.pop()\n    return False\ndef lca(root, n1, n2):\n    path1 = []\n    path2 = []\n    # Find paths from root to n1\n    # and root to n2\n    if not findPath(root, path1, n1) or not findPath(root, path2, n2):\n        return None\n    # Compare the paths to get\n    # the first different value\n    i = 0\n    while i < len(path1) and i < len(path2):\n        if path1[i] != path2[i]:\n            return path1[i-1]\n        i += 1\n    return path1[i-1]\n# Create binary tree:\n#\t\t\t   1\n#           /   \\\n#          2     3\n#               / \\\n#              6   7\n#             /\n#            8\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.right.left = Node(6)\nroot.right.right = Node(7)\nroot.right.left.left = Node(8)\nn1 = root.right.right\nn2 = root.right.left.left\nans = lca(root, n1, n2)\nprint(ans.data)",
    "code_without_comments": "\nclass Node:\n    def __init__(self, value):\n        self.data = value\n        self.left = None\n        self.right = None\n\ndef findPath(root, path, n):\n    if root is None:\n        return False\n\n    path.append(root)\n    if root == n or findPath(root.left, path, n) or findPath(root.right, path, n):\n        return True\n\n    path.pop()\n    return False\ndef lca(root, n1, n2):\n    path1 = []\n    path2 = []\n\n\n    if not findPath(root, path1, n1) or not findPath(root, path2, n2):\n        return None\n\n\n    i = 0\n    while i < len(path1) and i < len(path2):\n        if path1[i] != path2[i]:\n            return path1[i-1]\n        i += 1\n    return path1[i-1]\n\n\n\n\n\n\n\n\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.right.left = Node(6)\nroot.right.right = Node(7)\nroot.right.left.left = Node(8)\nn1 = root.right.right\nn2 = root.right.left.left\nans = lca(root, n1, n2)\nprint(ans.data)",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/lowest-common-ancestor-binary-tree-set-1/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#include <iostream>\nusing namespace std;\n// Node Structure\nclass Node {\npublic:\n    Node *left, *right;\n    int data;\n    Node(int k) {\n        data = k;\n        left = nullptr;\n        right = nullptr;\n    }\n};\nNode* lca(Node* root, Node* n1, Node* n2) {\n    if (!root)\n        return nullptr;\n    // If either key matches with root data, return root\n    if (root == n1 || root == n2)\n        return root;\n    Node* leftLca = lca(root->left, n1, n2);\n    Node* rightLca = lca(root->right, n1, n2);\n    // If both of the above calls return Non-NULL, then one\n    // data is present in one subtree and the other is present\n    // in the other, so this node is the LCA\n    if (leftLca && rightLca)\n        return root;\n    // Otherwise check if left subtree or\n    // right subtree is LCA\n    return leftLca ? leftLca : rightLca;\n}\nint main() {\n    // Create binary tree:\n    //\t\t\t   1\n    //           /   \\\n    //          2     3\n    //               / \\\n    //              6   7\n    //             /\n    //            8\n    Node* root = new Node(1);\n    root->left = new Node(2);\n    root->right = new Node(3);\n    root->right->left = new Node(6);\n    root->right->right = new Node(7);\n    root->right->left->left = new Node(8);\n    Node* n1 = root->right->right;\n    Node* n2 = root->right->left->left;\n    Node* ans = lca(root, n1, n2);\n    cout<<ans->data;\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\nusing namespace std;\n\nclass Node {\npublic:\n    Node *left, *right;\n    int data;\n    Node(int k) {\n        data = k;\n        left = nullptr;\n        right = nullptr;\n    }\n};\nNode* lca(Node* root, Node* n1, Node* n2) {\n    if (!root)\n        return nullptr;\n\n    if (root == n1 || root == n2)\n        return root;\n    Node* leftLca = lca(root->left, n1, n2);\n    Node* rightLca = lca(root->right, n1, n2);\n\n\n\n    if (leftLca && rightLca)\n        return root;\n\n\n    return leftLca ? leftLca : rightLca;\n}\nint main() {\n\n\n\n\n\n\n\n\n    Node* root = new Node(1);\n    root->left = new Node(2);\n    root->right = new Node(3);\n    root->right->left = new Node(6);\n    root->right->right = new Node(7);\n    root->right->left->left = new Node(8);\n    Node* n1 = root->right->right;\n    Node* n2 = root->right->left->left;\n    Node* ans = lca(root, n1, n2);\n    cout<<ans->data;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/lowest-common-ancestor-binary-tree-set-1/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#include <stdio.h>\n#include <stdlib.h>\n// Node Structure\nstruct Node {\n    struct Node *left, *right;\n    int key;\n};\nstruct Node* lca(struct Node* root, struct Node* n1, struct Node* n2) {\n    if (root == NULL)\n        return NULL;\n    // If either key matches with root data, return root\n    if (root == n1 || root == n2)\n        return root;\n    struct Node* leftLca = lca(root->left, n1, n2);\n    struct Node* rightLca = lca(root->right, n1, n2);\n    // If both of the above calls return Non-NULL, then one\n    // key is present in once subtree and other is present\n    // in other, so this node is the LCA\n    if (leftLca && rightLca)\n        return root;\n    // Otherwise check if left subtree or\n    // right subtree is LCA\n    return (leftLca != NULL) ? leftLca : rightLca;\n}\nstruct Node* createnode(int key) {\n    struct Node* newnode =\n      \t(struct Node*)malloc(sizeof(struct Node));\n    newnode->key = key;\n    newnode->left = newnode->right = NULL;\n    return newnode;\n}\nint main() {\n    // construct the binary tree\n    //\t\t\t   1\n    //           /   \\\n    //          2     3\n    //         / \\   / \\\n    //        4  5  6   7\n    //             /\n    //            8\n    struct Node* root = createnode(1);\n    root->left = createnode(2);\n    root->right = createnode(3);\n    root->right->left = createnode(6);\n    root->right->right = createnode(7);\n    root->right->left->left = createnode(8);\n    struct Node* n1 = root->right->right;\n    struct Node* n2 = root->right->left->left;\n    struct Node* ans = lca(root, n1, n2);\n    printf(\"%d\", ans->key);\n    return 0;\n}",
    "code_without_comments": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    struct Node *left, *right;\n    int key;\n};\nstruct Node* lca(struct Node* root, struct Node* n1, struct Node* n2) {\n    if (root == NULL)\n        return NULL;\n\n    if (root == n1 || root == n2)\n        return root;\n    struct Node* leftLca = lca(root->left, n1, n2);\n    struct Node* rightLca = lca(root->right, n1, n2);\n\n\n\n    if (leftLca && rightLca)\n        return root;\n\n\n    return (leftLca != NULL) ? leftLca : rightLca;\n}\nstruct Node* createnode(int key) {\n    struct Node* newnode =\n      \t(struct Node*)malloc(sizeof(struct Node));\n    newnode->key = key;\n    newnode->left = newnode->right = NULL;\n    return newnode;\n}\nint main() {\n\n\n\n\n\n\n\n\n    struct Node* root = createnode(1);\n    root->left = createnode(2);\n    root->right = createnode(3);\n    root->right->left = createnode(6);\n    root->right->right = createnode(7);\n    root->right->left->left = createnode(8);\n    struct Node* n1 = root->right->right;\n    struct Node* n2 = root->right->left->left;\n    struct Node* ans = lca(root, n1, n2);\n    printf(\"%d\", ans->key);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/lowest-common-ancestor-binary-tree-set-1/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "# Node Structure\nclass Node:\n    def __init__(self, k):\n        self.data = k\n        self.left = None\n        self.right = None\ndef lca(root, n1, n2):\n    if not root:\n        return None\n    # If either key matches with root data, return root\n    if root == n1 or root == n2:\n        return root\n    leftLca = lca(root.left, n1, n2)\n    rightLca = lca(root.right, n1, n2)\n    # If both of the above calls return Non-NULL, then one\n    # data is present in one subtree and the other is present\n    # in the other, so this node is the LCA\n    if leftLca and rightLca:\n        return root\n    # Otherwise check if left subtree or\n    # right subtree is LCA\n    return leftLca if leftLca else rightLca\nif __name__ == \"__main__\":\n    #  Create binary tree:\n    # \t\t\t   1\n    #            /   \\\n    #           2     3\n    #                / \\\n    #               6   7\n    #              /\n    #             8\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.right.left = Node(6)\n    root.right.right = Node(7)\n    root.right.left.left = Node(8)\n    n1 = root.right.right;\n    n2 = root.right.left.left;\n    ans = lca(root, n1, n2);\n    print(ans.data)",
    "code_without_comments": "\nclass Node:\n    def __init__(self, k):\n        self.data = k\n        self.left = None\n        self.right = None\ndef lca(root, n1, n2):\n    if not root:\n        return None\n\n    if root == n1 or root == n2:\n        return root\n    leftLca = lca(root.left, n1, n2)\n    rightLca = lca(root.right, n1, n2)\n\n\n\n    if leftLca and rightLca:\n        return root\n\n\n    return leftLca if leftLca else rightLca\nif __name__ == \"__main__\":\n\n\n\n\n\n\n\n\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.right.left = Node(6)\n    root.right.right = Node(7)\n    root.right.left.left = Node(8)\n    n1 = root.right.right;\n    n2 = root.right.left.left;\n    ans = lca(root, n1, n2);\n    print(ans.data)",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/lowest-common-ancestor-binary-tree-set-1/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "// C++ program to calculate width of binary tree\n#include <bits/stdc++.h>\nusing namespace std;\n/* A binary tree node has data, pointer to left child\nand a pointer to right child */\nclass node {\npublic:\n    int data;\n    node* left;\n    node* right;\n    node (int d){\n      this->data = d;\n      this->left = this->right = NULL;\n    }\n};\n/*Function prototypes*/\nint getWidth(node* root, int level);\nint height(node* node);\n/* Function to get the maximum width of a binary tree*/\nint getMaxWidth(node* root)\n{\n    int maxWidth = 0;\n    int width;\n    int h = height(root);\n    int i;\n    /* Get width of each level and compare\n        the width with maximum width so far */\n    for (i = 1; i <= h; i++) {\n        width = getWidth(root, i);\n        if (width > maxWidth)\n            maxWidth = width;\n    }\n    return maxWidth;\n}\n/* Get width of a given level */\nint getWidth(node* root, int level)\n{\n    if (root == NULL)\n        return 0;\n    if (level == 1)\n        return 1;\n    else if (level > 1)\n        return getWidth(root->left, level - 1)\n               + getWidth(root->right, level - 1);\n}\n/* UTILITY FUNCTIONS */\n/* Compute the \"height\" of a tree -- the number of\n    nodes along the longest path from the root node\n    down to the farthest leaf node.*/\nint height(node* node)\n{\n    if (node == NULL)\n        return 0;\n    else {\n        /* compute the height of each subtree */\n        int lHeight = height(node->left);\n        int rHeight = height(node->right);\n        /* use the larger one */\n        return (lHeight > rHeight) ? (lHeight + 1)\n                                   : (rHeight + 1);\n    }\n}\n/* Driver code*/\nint main()\n{\n    node* root = new node(1);\n    root->left = new node(2);\n    root->right = new node(3);\n    root->left->left = new node(4);\n    root->left->right = new node(5);\n    root->right->right = new node(8);\n    root->right->right->left = new node(6);\n    root->right->right->right = new node(7);\n    /*\n    Constructed binary tree is:\n             1\n            / \\\n           2   3\n          / \\   \\\n         4   5   8\n                / \\\n               6   7\n    */\n    // Function call\n    cout << \"Maximum width is \" << getMaxWidth(root)\n         << endl;\n    return 0;\n}\n// This code is contributed by rathbhupendra",
    "code_without_comments": "\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass node {\npublic:\n    int data;\n    node* left;\n    node* right;\n    node (int d){\n      this->data = d;\n      this->left = this->right = NULL;\n    }\n};\n\nint getWidth(node* root, int level);\nint height(node* node);\n\nint getMaxWidth(node* root)\n{\n    int maxWidth = 0;\n    int width;\n    int h = height(root);\n    int i;\n\n    for (i = 1; i <= h; i++) {\n        width = getWidth(root, i);\n        if (width > maxWidth)\n            maxWidth = width;\n    }\n    return maxWidth;\n}\n\nint getWidth(node* root, int level)\n{\n    if (root == NULL)\n        return 0;\n    if (level == 1)\n        return 1;\n    else if (level > 1)\n        return getWidth(root->left, level - 1)\n               + getWidth(root->right, level - 1);\n}\n\n\nint height(node* node)\n{\n    if (node == NULL)\n        return 0;\n    else {\n\n        int lHeight = height(node->left);\n        int rHeight = height(node->right);\n\n        return (lHeight > rHeight) ? (lHeight + 1)\n                                   : (rHeight + 1);\n    }\n}\n\nint main()\n{\n    node* root = new node(1);\n    root->left = new node(2);\n    root->right = new node(3);\n    root->left->left = new node(4);\n    root->left->right = new node(5);\n    root->right->right = new node(8);\n    root->right->right->left = new node(6);\n    root->right->right->right = new node(7);\n\n\n    cout << \"Maximum width is \" << getMaxWidth(root)\n         << endl;\n    return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/maximum-width-of-a-binary-tree/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "// C program to calculate width of binary tree\n#include <stdio.h>\n#include <stdlib.h>\n/* A binary tree node has data, pointer to left child\n   and a pointer to right child */\nstruct node {\n    int data;\n    struct node* left;\n    struct node* right;\n};\n/*Function prototypes*/\nint getWidth(struct node* root, int level);\nint height(struct node* node);\nstruct node* newNode(int data);\n/* Function to get the maximum width of a binary tree*/\nint getMaxWidth(struct node* root)\n{\n    int maxWidth = 0;\n    int width;\n    int h = height(root);\n    int i;\n    /* Get width of each level and compare\n       the width with maximum width so far */\n    for (i = 1; i <= h; i++) {\n        width = getWidth(root, i);\n        if (width > maxWidth)\n            maxWidth = width;\n    }\n    return maxWidth;\n}\n/* Get width of a given level */\nint getWidth(struct node* root, int level)\n{\n    if (root == NULL)\n        return 0;\n    if (level == 1)\n        return 1;\n    else if (level > 1)\n        return getWidth(root->left, level - 1)\n               + getWidth(root->right, level - 1);\n}\n/* UTILITY FUNCTIONS */\n/* Compute the \"height\" of a tree -- the number of\n    nodes along the longest path from the root node\n    down to the farthest leaf node.*/\nint height(struct node* node)\n{\n    if (node == NULL)\n        return 0;\n    else {\n        /* compute the height of each subtree */\n        int lHeight = height(node->left);\n        int rHeight = height(node->right);\n        /* use the larger one */\n        return (lHeight > rHeight) ? (lHeight + 1)\n                                   : (rHeight + 1);\n    }\n}\n/* Helper function that allocates a new node with the\n   given data and NULL left and right pointers. */\nstruct node* newNode(int data)\n{\n    struct node* node\n        = (struct node*)malloc(sizeof(struct node));\n    node->data = data;\n    node->left = NULL;\n    node->right = NULL;\n    return (node);\n}\n/* Driver code*/\nint main()\n{\n    struct node* root = newNode(1);\n    root->left = newNode(2);\n    root->right = newNode(3);\n    root->left->left = newNode(4);\n    root->left->right = newNode(5);\n    root->right->right = newNode(8);\n    root->right->right->left = newNode(6);\n    root->right->right->right = newNode(7);\n    /*\n     Constructed binary tree is:\n            1\n          /  \\\n         2    3\n       /  \\     \\\n      4   5     8\n                /  \\\n               6   7\n    */\n    // Function call\n    printf(\"Maximum width is %d \\n\", getMaxWidth(root));\n    getchar();\n    return 0;\n}",
    "code_without_comments": "\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct node {\n    int data;\n    struct node* left;\n    struct node* right;\n};\n\nint getWidth(struct node* root, int level);\nint height(struct node* node);\nstruct node* newNode(int data);\n\nint getMaxWidth(struct node* root)\n{\n    int maxWidth = 0;\n    int width;\n    int h = height(root);\n    int i;\n\n    for (i = 1; i <= h; i++) {\n        width = getWidth(root, i);\n        if (width > maxWidth)\n            maxWidth = width;\n    }\n    return maxWidth;\n}\n\nint getWidth(struct node* root, int level)\n{\n    if (root == NULL)\n        return 0;\n    if (level == 1)\n        return 1;\n    else if (level > 1)\n        return getWidth(root->left, level - 1)\n               + getWidth(root->right, level - 1);\n}\n\n\nint height(struct node* node)\n{\n    if (node == NULL)\n        return 0;\n    else {\n\n        int lHeight = height(node->left);\n        int rHeight = height(node->right);\n\n        return (lHeight > rHeight) ? (lHeight + 1)\n                                   : (rHeight + 1);\n    }\n}\n\nstruct node* newNode(int data)\n{\n    struct node* node\n        = (struct node*)malloc(sizeof(struct node));\n    node->data = data;\n    node->left = NULL;\n    node->right = NULL;\n    return (node);\n}\n\nint main()\n{\n    struct node* root = newNode(1);\n    root->left = newNode(2);\n    root->right = newNode(3);\n    root->left->left = newNode(4);\n    root->left->right = newNode(5);\n    root->right->right = newNode(8);\n    root->right->right->left = newNode(6);\n    root->right->right->right = newNode(7);\n\n\n    printf(\"Maximum width is %d \\n\", getMaxWidth(root));\n    getchar();\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/maximum-width-of-a-binary-tree/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "# Python program to find the maximum width of\n# binary tree using Level Order Traversal.\n# A binary tree node\nclass Node:\n    # Constructor to create a new node\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n# Function to get the maximum width of a binary tree\ndef getMaxWidth(root):\n    maxWidth = 0\n    h = height(root)\n    # Get width of each level and compare the\n    # width with maximum width so far\n    for i in range(1, h+1):\n        width = getWidth(root, i)\n        if (width > maxWidth):\n            maxWidth = width\n    return maxWidth\n# Get width of a given level\ndef getWidth(root, level):\n    if root is None:\n        return 0\n    if level == 1:\n        return 1\n    elif level > 1:\n        return (getWidth(root.left, level-1) +\n                getWidth(root.right, level-1))\n# UTILITY FUNCTIONS\n# Compute the \"height\" of a tree -- the number of\n# nodes along the longest path from the root node\n# down to the farthest leaf node.\ndef height(node):\n    if node is None:\n        return 0\n    else:\n        # compute the height of each subtree\n        lHeight = height(node.left)\n        rHeight = height(node.right)\n        # use the larger one\n        return (lHeight+1) if (lHeight > rHeight) else (rHeight+1)\n# Driver code\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.right = Node(8)\nroot.right.right.left = Node(6)\nroot.right.right.right = Node(7)\n\"\"\"\nConstructed binary tree is:\n    1\n    / \\\n    2 3\n    / \\     \\\n4 5 8\n        / \\\n        6 7\n\"\"\"\n# Function call\nprint (\"Maximum width is %d\" % (getMaxWidth(root)))\n# This code is contributed by Naveen Aili",
    "code_without_comments": "\n\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef getMaxWidth(root):\n    maxWidth = 0\n    h = height(root)\n\n\n    for i in range(1, h+1):\n        width = getWidth(root, i)\n        if (width > maxWidth):\n            maxWidth = width\n    return maxWidth\n\ndef getWidth(root, level):\n    if root is None:\n        return 0\n    if level == 1:\n        return 1\n    elif level > 1:\n        return (getWidth(root.left, level-1) +\n                getWidth(root.right, level-1))\n\n# Compute the \"height\" of a tree -- the number of\n\n\ndef height(node):\n    if node is None:\n        return 0\n    else:\n\n        lHeight = height(node.left)\n        rHeight = height(node.right)\n\n        return (lHeight+1) if (lHeight > rHeight) else (rHeight+1)\n\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.right = Node(8)\nroot.right.right.left = Node(6)\nroot.right.right.right = Node(7)\n\"\"\"\nConstructed binary tree is:\n    1\n    / \\\n    2 3\n    / \\     \\\n4 5 8\n        / \\\n        6 7\n\"\"\"\n\nprint (\"Maximum width is %d\" % (getMaxWidth(root)))\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/maximum-width-of-a-binary-tree/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "// A queue based C++ program to find maximum width\n// of a Binary Tree\n#include <bits/stdc++.h>\nusing namespace std;\n/* A binary tree node has data, pointer to left child\n   and a pointer to right child */\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n    Node(int d)\n    {\n        this->data = d;\n        this->left = this->right = NULL;\n    }\n};\n// Function to find the maximum width of the tree\n// using level order traversal\nint maxWidth(struct Node* root)\n{\n    // Base case\n    if (root == NULL)\n        return 0;\n    // Initialize result\n    int result = 0;\n    // Do Level order traversal keeping track of number\n    // of nodes at every level.\n    queue<Node*> q;\n    q.push(root);\n    while (!q.empty()) {\n        // Get the size of queue when the level order\n        // traversal for one level finishes\n        int count = q.size();\n        // Update the maximum node count value\n        result = max(count, result);\n        // Iterate for all the nodes in the queue currently\n        while (count--) {\n            // Dequeue an node from queue\n            Node* temp = q.front();\n            q.pop();\n            // Enqueue left and right children of\n            // dequeued node\n            if (temp->left != NULL)\n                q.push(temp->left);\n            if (temp->right != NULL)\n                q.push(temp->right);\n        }\n    }\n    return result;\n}\n// Driver code\nint main()\n{\n    struct Node* root = new Node(1);\n    root->left = new Node(2);\n    root->right = new Node(3);\n    root->left->left = new Node(4);\n    root->left->right = new Node(5);\n    root->right->right = new Node(8);\n    root->right->right->left = new Node(6);\n    root->right->right->right = new Node(7);\n    /*   Constructed Binary tree is:\n                 1\n               /   \\\n              2      3\n             /  \\     \\\n            4    5     8\n                     /   \\\n                    6     7    */\n    // Function call\n    cout << \"Maximum width is \" << maxWidth(root) << endl;\n    return 0;\n}\n// This code is contributed by Nikhil Kumar\n// Singh(nickzuck_007)",
    "code_without_comments": "\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n    Node(int d)\n    {\n        this->data = d;\n        this->left = this->right = NULL;\n    }\n};\n\n\nint maxWidth(struct Node* root)\n{\n\n    if (root == NULL)\n        return 0;\n\n    int result = 0;\n\n\n    queue<Node*> q;\n    q.push(root);\n    while (!q.empty()) {\n\n\n        int count = q.size();\n\n        result = max(count, result);\n\n        while (count--) {\n\n            Node* temp = q.front();\n            q.pop();\n\n\n            if (temp->left != NULL)\n                q.push(temp->left);\n            if (temp->right != NULL)\n                q.push(temp->right);\n        }\n    }\n    return result;\n}\n\nint main()\n{\n    struct Node* root = new Node(1);\n    root->left = new Node(2);\n    root->right = new Node(3);\n    root->left->left = new Node(4);\n    root->left->right = new Node(5);\n    root->right->right = new Node(8);\n    root->right->right->left = new Node(6);\n    root->right->right->right = new Node(7);\n\n\n    cout << \"Maximum width is \" << maxWidth(root) << endl;\n    return 0;\n}\n\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/maximum-width-of-a-binary-tree/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "// Java program to calculate maximum width\n// of a binary tree using queue\nimport java.util.LinkedList;\nimport java.util.Queue;\npublic class maxwidthusingqueue\n{\n    /* A binary tree node has data, pointer to\n       left child and a pointer to right child */\n    static class node\n    {\n        int data;\n        node left, right;\n        public node(int data) { this.data = data; }\n    }\n    // Function to find the maximum width of\n    // the tree using level order traversal\n    static int maxwidth(node root)\n    {\n        // Base case\n        if (root == null)\n            return 0;\n        // Initialize result\n        int maxwidth = 0;\n        // Do Level order traversal keeping\n        // track of number of nodes at every level\n        Queue<node> q = new LinkedList<>();\n        q.add(root);\n        while (!q.isEmpty())\n        {\n            // Get the size of queue when the level order\n            // traversal for one level finishes\n            int count = q.size();\n            // Update the maximum node count value\n            maxwidth = Math.max(maxwidth, count);\n            // Iterate for all the nodes in\n            // the queue currently\n            while (count-- > 0) {\n                // Dequeue an node from queue\n                node temp = q.remove();\n                // Enqueue left and right children\n                // of dequeued node\n                if (temp.left != null)\n                {\n                    q.add(temp.left);\n                }\n                if (temp.right != null)\n                {\n                    q.add(temp.right);\n                }\n            }\n        }\n        return maxwidth;\n    }\n    // Function call\n    public static void main(String[] args)\n    {\n        node root = new node(1);\n        root.left = new node(2);\n        root.right = new node(3);\n        root.left.left = new node(4);\n        root.left.right = new node(5);\n        root.right.right = new node(8);\n        root.right.right.left = new node(6);\n        root.right.right.right = new node(7);\n        /*   Constructed Binary tree is:\n        1\n      /   \\\n    2      3\n  /  \\      \\\n 4    5      8\n           /   \\\n          6     7    */\n        // Function call\n        System.out.println(\"Maximum width = \"\n                           + maxwidth(root));\n    }\n}\n// This code is contributed by Rishabh Mahrsee",
    "code_without_comments": "// Java program to calculate maximum width\n// of a binary tree using queue\nimport java.util.LinkedList;\nimport java.util.Queue;\npublic class maxwidthusingqueue\n{\n    /* A binary tree node has data, pointer to\n       left child and a pointer to right child */\n    static class node\n    {\n        int data;\n        node left, right;\n        public node(int data) { this.data = data; }\n    }\n    // Function to find the maximum width of\n    // the tree using level order traversal\n    static int maxwidth(node root)\n    {\n        // Base case\n        if (root == null)\n            return 0;\n        // Initialize result\n        int maxwidth = 0;\n        // Do Level order traversal keeping\n        // track of number of nodes at every level\n        Queue<node> q = new LinkedList<>();\n        q.add(root);\n        while (!q.isEmpty())\n        {\n            // Get the size of queue when the level order\n            // traversal for one level finishes\n            int count = q.size();\n            // Update the maximum node count value\n            maxwidth = Math.max(maxwidth, count);\n            // Iterate for all the nodes in\n            // the queue currently\n            while (count-- > 0) {\n                // Dequeue an node from queue\n                node temp = q.remove();\n                // Enqueue left and right children\n                // of dequeued node\n                if (temp.left != null)\n                {\n                    q.add(temp.left);\n                }\n                if (temp.right != null)\n                {\n                    q.add(temp.right);\n                }\n            }\n        }\n        return maxwidth;\n    }\n    // Function call\n    public static void main(String[] args)\n    {\n        node root = new node(1);\n        root.left = new node(2);\n        root.right = new node(3);\n        root.left.left = new node(4);\n        root.left.right = new node(5);\n        root.right.right = new node(8);\n        root.right.right.left = new node(6);\n        root.right.right.right = new node(7);\n        /*   Constructed Binary tree is:\n        1\n      /   \\\n    2      3\n  /  \\      \\\n 4    5      8\n           /   \\\n          6     7    */\n        // Function call\n        System.out.println(\"Maximum width = \"\n                           + maxwidth(root));\n    }\n}\n// This code is contributed by Rishabh Mahrsee",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/maximum-width-of-a-binary-tree/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "# Python program to find the maximum width of binary\n# tree using Level Order Traversal with queue.\nfrom _collections import deque\n# A binary tree node\nclass Node:\n    # Constructor to create a new node\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n# Function to get the maximum width of a binary tree\ndef getMaxWidth(root):\n    # base case\n    if root is None:\n        return 0\n    q = deque()\n    maxWidth = 0\n    q.append(root)\n    while q:\n        # Get the size of queue when the level order\n        # traversal for one level finishes\n        count = len(q)\n        # Update the maximum node count value\n        maxWidth = max(count, maxWidth)\n        while (count is not 0):\n            count = count-1\n            temp = q.popleft()\n            if temp.left is not None:\n                q.append(temp.left)\n            if temp.right is not None:\n                q.append(temp.right)\n    return maxWidth\n# Driver program to test above function\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.right = Node(8)\nroot.right.right.left = Node(6)\nroot.right.right.right = Node(7)\n\"\"\"\nConstructed binary tree is:\n       1\n      / \\\n     2   3\n    / \\    \\\n   4   5   8\n          / \\\n         6   7\n\"\"\"\n# Function call\nprint (\"Maximum width is %d\" % (getMaxWidth(root)))\n# This code is contributed by Naveen Aili",
    "code_without_comments": "\n\nfrom _collections import deque\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef getMaxWidth(root):\n\n    if root is None:\n        return 0\n    q = deque()\n    maxWidth = 0\n    q.append(root)\n    while q:\n\n\n        count = len(q)\n\n        maxWidth = max(count, maxWidth)\n        while (count is not 0):\n            count = count-1\n            temp = q.popleft()\n            if temp.left is not None:\n                q.append(temp.left)\n            if temp.right is not None:\n                q.append(temp.right)\n    return maxWidth\n\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.right = Node(8)\nroot.right.right.left = Node(6)\nroot.right.right.right = Node(7)\n\"\"\"\nConstructed binary tree is:\n       1\n      / \\\n     2   3\n    / \\    \\\n   4   5   8\n          / \\\n         6   7\n\"\"\"\n\nprint (\"Maximum width is %d\" % (getMaxWidth(root)))\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/maximum-width-of-a-binary-tree/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "// C++ program to calculate width of binary tree\n#include <bits/stdc++.h>\nusing namespace std;\n/* A binary tree node has data, pointer to left child\nand a pointer to right child */\nclass node {\npublic:\n    int data;\n    node* left;\n    node* right;\n    node(int d)\n    {\n        this->data = d;\n        this->left = this->right = NULL;\n    }\n};\n// A utility function to get\n// height of a binary tree\nint height(node* node);\n// A utility function that returns\n// maximum value in arr[] of size n\nint getMax(int arr[], int n);\n// A function that fills count array\n// with count of nodes at every\n// level of given binary tree\nvoid getMaxWidthRecur(node* root, int count[], int level);\n/* Function to get the maximum\nwidth of a binary tree*/\nint getMaxWidth(node* root)\n{\n    int width;\n    int h = height(root);\n    // Create an array that will\n    // store count of nodes at each level\n    int* count = new int[h];\n    int level = 0;\n    // Fill the count array using preorder traversal\n    getMaxWidthRecur(root, count, level);\n    // Return the maximum value from count array\n    return getMax(count, h);\n}\n// A function that fills count array\n// with count of nodes at every\n// level of given binary tree\nvoid getMaxWidthRecur(node* root,\n                      int count[], int level)\n{\n    if (root) {\n        count[level]++;\n        getMaxWidthRecur(root->left, count, level + 1);\n        getMaxWidthRecur(root->right, count, level + 1);\n    }\n}\n/* UTILITY FUNCTIONS */\n/* Compute the \"height\" of a tree -- the number of\n    nodes along the longest path from the root node\n    down to the farthest leaf node.*/\nint height(node* node)\n{\n    if (node == NULL)\n        return 0;\n    else {\n        /* compute the height of each subtree */\n        int lHeight = height(node->left);\n        int rHeight = height(node->right);\n        /* use the larger one */\n        return (lHeight > rHeight) ? (lHeight + 1)\n                                   : (rHeight + 1);\n    }\n}\n// Return the maximum value from count array\nint getMax(int arr[], int n)\n{\n    int max = arr[0];\n    int i;\n    for (i = 0; i < n; i++) {\n        if (arr[i] > max)\n            max = arr[i];\n    }\n    return max;\n}\n/* Driver code*/\nint main()\n{\n    node* root = new node(1);\n    root->left = new node(2);\n    root->right = new node(3);\n    root->left->left = new node(4);\n    root->left->right = new node(5);\n    root->right->right = new node(8);\n    root->right->right->left = new node(6);\n    root->right->right->right = new node(7);\n    cout << \"Maximum width is \" << getMaxWidth(root)\n         << endl;\n    return 0;\n}\n// This is code is contributed by rathbhupendra",
    "code_without_comments": "\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass node {\npublic:\n    int data;\n    node* left;\n    node* right;\n    node(int d)\n    {\n        this->data = d;\n        this->left = this->right = NULL;\n    }\n};\n\n\nint height(node* node);\n\n\nint getMax(int arr[], int n);\n\n\n\nvoid getMaxWidthRecur(node* root, int count[], int level);\n\nint getMaxWidth(node* root)\n{\n    int width;\n    int h = height(root);\n\n\n    int* count = new int[h];\n    int level = 0;\n\n    getMaxWidthRecur(root, count, level);\n\n    return getMax(count, h);\n}\n\n\n\nvoid getMaxWidthRecur(node* root,\n                      int count[], int level)\n{\n    if (root) {\n        count[level]++;\n        getMaxWidthRecur(root->left, count, level + 1);\n        getMaxWidthRecur(root->right, count, level + 1);\n    }\n}\n\n\nint height(node* node)\n{\n    if (node == NULL)\n        return 0;\n    else {\n\n        int lHeight = height(node->left);\n        int rHeight = height(node->right);\n\n        return (lHeight > rHeight) ? (lHeight + 1)\n                                   : (rHeight + 1);\n    }\n}\n\nint getMax(int arr[], int n)\n{\n    int max = arr[0];\n    int i;\n    for (i = 0; i < n; i++) {\n        if (arr[i] > max)\n            max = arr[i];\n    }\n    return max;\n}\n\nint main()\n{\n    node* root = new node(1);\n    root->left = new node(2);\n    root->right = new node(3);\n    root->left->left = new node(4);\n    root->left->right = new node(5);\n    root->right->right = new node(8);\n    root->right->right->left = new node(6);\n    root->right->right->right = new node(7);\n    cout << \"Maximum width is \" << getMaxWidth(root)\n         << endl;\n    return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/maximum-width-of-a-binary-tree/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "// C program to calculate width of binary tree\n#include <stdio.h>\n#include <stdlib.h>\n/* A binary tree node has data, pointer to left child\n   and a pointer to right child */\nstruct node {\n    int data;\n    struct node* left;\n    struct node* right;\n};\n// A utility function to get height of a binary tree\nint height(struct node* node);\n// A utility function to allocate a new node with given data\nstruct node* newNode(int data);\n// A utility function that returns maximum value in arr[] of\n// size n\nint getMax(int arr[], int n);\n// A function that fills count array with count of nodes at\n// every level of given binary tree\nvoid getMaxWidthRecur(struct node* root, int count[],\n                      int level);\n/* Function to get the maximum width of a binary tree*/\nint getMaxWidth(struct node* root)\n{\n    int width;\n    int h = height(root);\n    // Create an array that will store count of nodes at\n    // each level\n    int* count = (int*)calloc(sizeof(int), h);\n    int level = 0;\n    // Fill the count array using preorder traversal\n    getMaxWidthRecur(root, count, level);\n    // Return the maximum value from count array\n    return getMax(count, h);\n}\n// A function that fills count array with count of nodes at\n// every level of given binary tree\nvoid getMaxWidthRecur(struct node* root, int count[],\n                      int level)\n{\n    if (root) {\n        count[level]++;\n        getMaxWidthRecur(root->left, count, level + 1);\n        getMaxWidthRecur(root->right, count, level + 1);\n    }\n}\n/* UTILITY FUNCTIONS */\n/* Compute the \"height\" of a tree -- the number of\n    nodes along the longest path from the root node\n    down to the farthest leaf node.*/\nint height(struct node* node)\n{\n    if (node == NULL)\n        return 0;\n    else {\n        /* compute the height of each subtree */\n        int lHeight = height(node->left);\n        int rHeight = height(node->right);\n        /* use the larger one */\n        return (lHeight > rHeight) ? (lHeight + 1)\n                                   : (rHeight + 1);\n    }\n}\n/* Helper function that allocates a new node with the\n   given data and NULL left and right pointers. */\nstruct node* newNode(int data)\n{\n    struct node* node\n        = (struct node*)malloc(sizeof(struct node));\n    node->data = data;\n    node->left = NULL;\n    node->right = NULL;\n    return (node);\n}\n// Return the maximum value from count array\nint getMax(int arr[], int n)\n{\n    int max = arr[0];\n    int i;\n    for (i = 0; i < n; i++) {\n        if (arr[i] > max)\n            max = arr[i];\n    }\n    return max;\n}\n/* Driver program to test above functions*/\nint main()\n{\n    struct node* root = newNode(1);\n    root->left = newNode(2);\n    root->right = newNode(3);\n    root->left->left = newNode(4);\n    root->left->right = newNode(5);\n    root->right->right = newNode(8);\n    root->right->right->left = newNode(6);\n    root->right->right->right = newNode(7);\n    /*\n     Constructed binary tree is:\n            1\n          /  \\\n         2    3\n       /  \\     \\\n      4   5     8\n                /  \\\n               6   7\n    */\n    printf(\"Maximum width is %d \\n\", getMaxWidth(root));\n    getchar();\n    return 0;\n}",
    "code_without_comments": "\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct node {\n    int data;\n    struct node* left;\n    struct node* right;\n};\n\nint height(struct node* node);\n\nstruct node* newNode(int data);\n\n\nint getMax(int arr[], int n);\n\n\nvoid getMaxWidthRecur(struct node* root, int count[],\n                      int level);\n\nint getMaxWidth(struct node* root)\n{\n    int width;\n    int h = height(root);\n\n\n    int* count = (int*)calloc(sizeof(int), h);\n    int level = 0;\n\n    getMaxWidthRecur(root, count, level);\n\n    return getMax(count, h);\n}\n\n\nvoid getMaxWidthRecur(struct node* root, int count[],\n                      int level)\n{\n    if (root) {\n        count[level]++;\n        getMaxWidthRecur(root->left, count, level + 1);\n        getMaxWidthRecur(root->right, count, level + 1);\n    }\n}\n\n\nint height(struct node* node)\n{\n    if (node == NULL)\n        return 0;\n    else {\n\n        int lHeight = height(node->left);\n        int rHeight = height(node->right);\n\n        return (lHeight > rHeight) ? (lHeight + 1)\n                                   : (rHeight + 1);\n    }\n}\n\nstruct node* newNode(int data)\n{\n    struct node* node\n        = (struct node*)malloc(sizeof(struct node));\n    node->data = data;\n    node->left = NULL;\n    node->right = NULL;\n    return (node);\n}\n\nint getMax(int arr[], int n)\n{\n    int max = arr[0];\n    int i;\n    for (i = 0; i < n; i++) {\n        if (arr[i] > max)\n            max = arr[i];\n    }\n    return max;\n}\n\nint main()\n{\n    struct node* root = newNode(1);\n    root->left = newNode(2);\n    root->right = newNode(3);\n    root->left->left = newNode(4);\n    root->left->right = newNode(5);\n    root->right->right = newNode(8);\n    root->right->right->left = newNode(6);\n    root->right->right->right = newNode(7);\n\n    printf(\"Maximum width is %d \\n\", getMaxWidth(root));\n    getchar();\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/maximum-width-of-a-binary-tree/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "# Python program to find the maximum width of\n# binary tree using Preorder Traversal.\n# A binary tree node\nclass Node:\n    # Constructor to create a new node\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n# Function to get the maximum width of a binary tree\ndef getMaxWidth(root):\n    h = height(root)\n    # Create an array that will store count of nodes at each level\n    count = [0] * h\n    level = 0\n    # Fill the count array using preorder traversal\n    getMaxWidthRecur(root, count, level)\n    # Return the maximum value from count array\n    return getMax(count, h)\n# A function that fills count array with count of nodes at every\n# level of given binary tree\ndef getMaxWidthRecur(root, count, level):\n    if root is not None:\n        count[level] += 1\n        getMaxWidthRecur(root.left, count, level+1)\n        getMaxWidthRecur(root.right, count, level+1)\n# UTILITY FUNCTIONS\n# Compute the \"height\" of a tree -- the number of\n# nodes along the longest path from the root node\n# down to the farthest leaf node.\ndef height(node):\n    if node is None:\n        return 0\n    else:\n        # compute the height of each subtree\n        lHeight = height(node.left)\n        rHeight = height(node.right)\n        # use the larger one\n        return (lHeight+1) if (lHeight > rHeight) else (rHeight+1)\n# Return the maximum value from count array\ndef getMax(count, n):\n    max = count[0]\n    for i in range(1, n):\n        if (count[i] > max):\n            max = count[i]\n    return max\n# Driver program to test above function\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.right = Node(8)\nroot.right.right.left = Node(6)\nroot.right.right.right = Node(7)\n\"\"\"\nConstructed binary tree is:\n       1\n      / \\\n     2   3\n    / \\   \\\n   4   5   8\n          / \\\n         6   7\n\"\"\"\nprint (\"Maximum width is %d\" % (getMaxWidth(root)))\n# This code is contributed by Naveen Aili",
    "code_without_comments": "\n\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef getMaxWidth(root):\n    h = height(root)\n\n    count = [0] * h\n    level = 0\n\n    getMaxWidthRecur(root, count, level)\n\n    return getMax(count, h)\n\n\ndef getMaxWidthRecur(root, count, level):\n    if root is not None:\n        count[level] += 1\n        getMaxWidthRecur(root.left, count, level+1)\n        getMaxWidthRecur(root.right, count, level+1)\n\n# Compute the \"height\" of a tree -- the number of\n\n\ndef height(node):\n    if node is None:\n        return 0\n    else:\n\n        lHeight = height(node.left)\n        rHeight = height(node.right)\n\n        return (lHeight+1) if (lHeight > rHeight) else (rHeight+1)\n\ndef getMax(count, n):\n    max = count[0]\n    for i in range(1, n):\n        if (count[i] > max):\n            max = count[i]\n    return max\n\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.right = Node(8)\nroot.right.right.left = Node(6)\nroot.right.right.right = Node(7)\n\"\"\"\nConstructed binary tree is:\n       1\n      / \\\n     2   3\n    / \\   \\\n   4   5   8\n          / \\\n         6   7\n\"\"\"\nprint (\"Maximum width is %d\" % (getMaxWidth(root)))\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/maximum-width-of-a-binary-tree/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#include <bits/stdc++.h>\nusing namespace std;\nstruct node {\n  int data;\n  struct node * left, * right;\n};\nint widthOfBinaryTree(node * root) {\n  if (!root)\n    return 0;\n  int ans = 0;\n  queue < pair < node * , int >> q;\n  q.push({\n    root,\n    0\n  });\n  while (!q.empty()) {\n    int size = q.size();\n    int curMin = q.front().second;\n    int leftMost, rightMost;\n    for (int i = 0; i < size; i++) {\n      int cur_id = q.front().second - curMin; // subtracted to prevent integer overflow\n      node * temp = q.front().first;\n      q.pop();\n      if (i == 0) leftMost = cur_id;\n      if (i == size - 1) rightMost = cur_id;\n      if (temp -> left)\n        q.push({\n          temp -> left,\n          cur_id * 2 + 1\n        });\n      if (temp -> right)\n        q.push({\n          temp -> right,\n          cur_id * 2 + 2\n        });\n    }\n    ans = max(ans, rightMost - leftMost + 1);\n  }\n  return ans;\n}\nstruct node * newNode(int data) {\n  struct node * node = (struct node * ) malloc(sizeof(struct node));\n  node -> data = data;\n  node -> left = NULL;\n  node -> right = NULL;\n  return (node);\n}\nint main() {\n  struct node * root = newNode(1);\n  root -> left = newNode(3);\n  root -> left -> left = newNode(5);\n  root -> left -> left -> left = newNode(7);\n  root -> right = newNode(2);\n  root -> right -> right = newNode(4);\n  root -> right -> right -> right = newNode(6);\n  int maxWidth = widthOfBinaryTree(root);\n  cout << \"The maximum width of the Binary Tree is \" << maxWidth;\n  return 0;\n}\n//This code is given by Kushagra Mishra.",
    "code_without_comments": "#include <bits/stdc++.h>\nusing namespace std;\nstruct node {\n  int data;\n  struct node * left, * right;\n};\nint widthOfBinaryTree(node * root) {\n  if (!root)\n    return 0;\n  int ans = 0;\n  queue < pair < node * , int >> q;\n  q.push({\n    root,\n    0\n  });\n  while (!q.empty()) {\n    int size = q.size();\n    int curMin = q.front().second;\n    int leftMost, rightMost;\n    for (int i = 0; i < size; i++) {\n      int cur_id = q.front().second - curMin;\n      node * temp = q.front().first;\n      q.pop();\n      if (i == 0) leftMost = cur_id;\n      if (i == size - 1) rightMost = cur_id;\n      if (temp -> left)\n        q.push({\n          temp -> left,\n          cur_id * 2 + 1\n        });\n      if (temp -> right)\n        q.push({\n          temp -> right,\n          cur_id * 2 + 2\n        });\n    }\n    ans = max(ans, rightMost - leftMost + 1);\n  }\n  return ans;\n}\nstruct node * newNode(int data) {\n  struct node * node = (struct node * ) malloc(sizeof(struct node));\n  node -> data = data;\n  node -> left = NULL;\n  node -> right = NULL;\n  return (node);\n}\nint main() {\n  struct node * root = newNode(1);\n  root -> left = newNode(3);\n  root -> left -> left = newNode(5);\n  root -> left -> left -> left = newNode(7);\n  root -> right = newNode(2);\n  root -> right -> right = newNode(4);\n  root -> right -> right -> right = newNode(6);\n  int maxWidth = widthOfBinaryTree(root);\n  cout << \"The maximum width of the Binary Tree is \" << maxWidth;\n  return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/maximum-width-of-a-binary-tree/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "/*package whatever //do not write package name here */\nimport java.util.*;\nclass TreeNode {\n  int data;\n  TreeNode  left,  right;\n  TreeNode(int data)\n  {\n      this.data=data;\n      left=null;\n      right=null;\n  }\n}\nclass Pair {\n    TreeNode node;\n    int num;\n    Pair(TreeNode _node, int _num) {\n        num = _num;\n        node = _node;\n    }\n}\nclass Solution {\n    public static int widthOfBinaryTree(TreeNode root) {\n        if(root == null) return 0;\n        int ans = 0;\n        Queue<Pair> q = new LinkedList<>();\n        q.offer(new Pair(root, 0));\n        while(!q.isEmpty()){\n            int size = q.size();\n            int mmin = q.peek().num;    //to make the id starting from zero\n            int first = 0,last = 0;\n            for(int i=0; i<size; i++){\n                int cur_id = q.peek().num-mmin;\n                TreeNode node = q.peek().node;\n                q.poll();\n                if(i==0) first = cur_id;\n                if(i==size-1) last = cur_id;\n                if(node.left != null)\n                    q.offer(new Pair(node.left, cur_id*2+1));\n                if(node.right != null)\n                    q.offer(new Pair(node.right, cur_id*2+2));\n            }\n            ans = Math.max(ans, last-first+1);\n        }\n        return ans;\n    }\npublic static void main(String args[]) {\n  TreeNode  root = new TreeNode(1);\n  root . left = new TreeNode(3);\n  root . left . left = new TreeNode(5);\n  root . left . left . left = new TreeNode(7);\n  root . right = new TreeNode(2);\n  root . right . right = new TreeNode(4);\n  root . right . right . right = new TreeNode(6);\n  int maxWidth = widthOfBinaryTree(root);\n  System.out.println(\"The maximum width of the Binary Tree is \"+maxWidth);\n  //This code is given by Kushagra Mishra.\n}\n}",
    "code_without_comments": "/*package whatever //do not write package name here */\nimport java.util.*;\nclass TreeNode {\n  int data;\n  TreeNode  left,  right;\n  TreeNode(int data)\n  {\n      this.data=data;\n      left=null;\n      right=null;\n  }\n}\nclass Pair {\n    TreeNode node;\n    int num;\n    Pair(TreeNode _node, int _num) {\n        num = _num;\n        node = _node;\n    }\n}\nclass Solution {\n    public static int widthOfBinaryTree(TreeNode root) {\n        if(root == null) return 0;\n        int ans = 0;\n        Queue<Pair> q = new LinkedList<>();\n        q.offer(new Pair(root, 0));\n        while(!q.isEmpty()){\n            int size = q.size();\n            int mmin = q.peek().num;    //to make the id starting from zero\n            int first = 0,last = 0;\n            for(int i=0; i<size; i++){\n                int cur_id = q.peek().num-mmin;\n                TreeNode node = q.peek().node;\n                q.poll();\n                if(i==0) first = cur_id;\n                if(i==size-1) last = cur_id;\n                if(node.left != null)\n                    q.offer(new Pair(node.left, cur_id*2+1));\n                if(node.right != null)\n                    q.offer(new Pair(node.right, cur_id*2+2));\n            }\n            ans = Math.max(ans, last-first+1);\n        }\n        return ans;\n    }\npublic static void main(String args[]) {\n  TreeNode  root = new TreeNode(1);\n  root . left = new TreeNode(3);\n  root . left . left = new TreeNode(5);\n  root . left . left . left = new TreeNode(7);\n  root . right = new TreeNode(2);\n  root . right . right = new TreeNode(4);\n  root . right . right . right = new TreeNode(6);\n  int maxWidth = widthOfBinaryTree(root);\n  System.out.println(\"The maximum width of the Binary Tree is \"+maxWidth);\n  //This code is given by Kushagra Mishra.\n}\n}",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/maximum-width-of-a-binary-tree/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "# Python program to find the maximum width of\n# binary tree using Preorder Traversal.\nfrom collections import deque\n# A binary tree node\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n# function to find the width of binary tree\ndef widthOfBinaryTree(root):\n    if not root:\n        return 0\n    ans = 0\n    q = deque([(root, 0)])\n    while q:\n        size = len(q)\n        cur_min = q[0][1]\n        left_most, right_most = None, None\n        for i in range(size):\n            cur_id = q[0][1] - cur_min  # subtracted to prevent integer overflow\n            temp, _ = q.popleft()\n            if i == 0:\n                left_most = cur_id\n            if i == size - 1:\n                right_most = cur_id\n            if temp.left:\n                q.append((temp.left, cur_id * 2 + 1))\n            if temp.right:\n                q.append((temp.right, cur_id * 2 + 2))\n        ans = max(ans, right_most - left_most + 1)\n    return ans\n# Utility function to create a new node\ndef newNode(data):\n    node = Node(data)\n    return node\n# Driver code to test above functions\ndef main():\n    root = newNode(1)\n    root.left = newNode(3)\n    root.left.left = newNode(5)\n    root.left.left.left = newNode(7)\n    root.right = newNode(2)\n    root.right.right = newNode(4)\n    root.right.right.right = newNode(6)\n    maxWidth = widthOfBinaryTree(root)\n    print(\"The maximum width of the Binary Tree is\", maxWidth)\nif __name__ == \"__main__\":\n    main()",
    "code_without_comments": "\n\nfrom collections import deque\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef widthOfBinaryTree(root):\n    if not root:\n        return 0\n    ans = 0\n    q = deque([(root, 0)])\n    while q:\n        size = len(q)\n        cur_min = q[0][1]\n        left_most, right_most = None, None\n        for i in range(size):\n            cur_id = q[0][1] - cur_min\n            temp, _ = q.popleft()\n            if i == 0:\n                left_most = cur_id\n            if i == size - 1:\n                right_most = cur_id\n            if temp.left:\n                q.append((temp.left, cur_id * 2 + 1))\n            if temp.right:\n                q.append((temp.right, cur_id * 2 + 2))\n        ans = max(ans, right_most - left_most + 1)\n    return ans\n\ndef newNode(data):\n    node = Node(data)\n    return node\n\ndef main():\n    root = newNode(1)\n    root.left = newNode(3)\n    root.left.left = newNode(5)\n    root.left.left.left = newNode(7)\n    root.right = newNode(2)\n    root.right.right = newNode(4)\n    root.right.right.right = newNode(6)\n    maxWidth = widthOfBinaryTree(root)\n    print(\"The maximum width of the Binary Tree is\", maxWidth)\nif __name__ == \"__main__\":\n    main()",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/maximum-width-of-a-binary-tree/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <iostream>\n#include<vector>\nusing namespace std;\n// Node structure\nclass Node {\npublic:\n    int data;\n    Node *left, *right;\n    Node(int val) {\n        data = val;\n        left = right = nullptr;\n    }\n};\n//Driver Code Ends\n// Performs inorder traversal of BST\n// and stores values in sorted order\nvoid inorder(Node* root, vector<int>& sortedInorder) {\n    // Base Case\n    if (root == nullptr) return;\n    // Traverse left subtree\n    inorder(root->left, sortedInorder);\n    sortedInorder.push_back(root->data);\n    // Traverse right subtree\n    inorder(root->right, sortedInorder);\n}\n// Returns the minimum value in a BST\nint minValue(Node* root) {\n    if (root == nullptr) {\n        return -1;\n    }\n    vector<int> sortedInorder;\n    // Get all BST values in sorted order\n    inorder(root, sortedInorder);\n    return sortedInorder[0];\n}\n//Driver Code Starts\nint main() {\n    // Create BST\n    //        5\n    //       / \\\n    //      4   6\n    //     /     \\\n    //    3       7\n    //   /\n    //  1\n    Node* root = new Node(5);\n    root->left = new Node(4);\n    root->right = new Node(6);\n    root->left->left = new Node(3);\n    root->right->right = new Node(7);\n    root->left->left->left = new Node(1);\n    cout << minValue(root) << \"\n\";\n    return 0;\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <iostream>\n#include<vector>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node *left, *right;\n    Node(int val) {\n        data = val;\n        left = right = nullptr;\n    }\n};\n\n\n\nvoid inorder(Node* root, vector<int>& sortedInorder) {\n\n    if (root == nullptr) return;\n\n    inorder(root->left, sortedInorder);\n    sortedInorder.push_back(root->data);\n\n    inorder(root->right, sortedInorder);\n}\n\nint minValue(Node* root) {\n    if (root == nullptr) {\n        return -1;\n    }\n    vector<int> sortedInorder;\n\n    inorder(root, sortedInorder);\n    return sortedInorder[0];\n}\n\nint main() {\n\n\n\n\n\n\n\n\n    Node* root = new Node(5);\n    root->left = new Node(4);\n    root->right = new Node(6);\n    root->left->left = new Node(3);\n    root->right->right = new Node(7);\n    root->left->left->left = new Node(1);\n    cout << minValue(root) << \"\n\";\n    return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/find-the-minimum-element-in-a-binary-search-tree/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#define MAX_SIZE 100000\n// Node structure\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\nstruct Node* createNode(int val) {\n    struct Node* node\n      = (struct Node*)malloc(sizeof(struct Node));\n    node->data = val;\n    node->left = node->right = NULL;\n//Driver Code Ends\n    return node;\n}\n// Performs inorder traversal of BST and stores values in sorted order\nvoid inorder(struct Node* root, int *sortedInorder, int *index) {\n    if (root == NULL) return;\n    // Traverse left subtree\n    inorder(root->left, sortedInorder, index);\n    sortedInorder[(*index)++] = root->data;\n    // Traverse right subtree\n    inorder(root->right, sortedInorder, index);\n}\n// Returns the minimum value in a BST\nint minValue(struct Node* root) {\n    if (root == NULL) return -1;\n    // Array to hold inorder elements\n    int sortedInorder[MAX_SIZE];\n    int index = 0;\n    // Get all BST values in sorted order\n    inorder(root, sortedInorder, &index);\n    return sortedInorder[0];\n//Driver Code Starts\n}\nint main() {\n    // Create BST\n    //        5\n    //       / \\\n    //      4   6\n    //     /     \\\n    //    3       7\n    //   /\n    //  1\n    struct Node* root = createNode(5);\n    root->left = createNode(4);\n    root->right = createNode(6);\n    root->left->left = createNode(3);\n    root->right->right = createNode(7);\n    root->left->left->left = createNode(1);\n    printf(\"%d\n\", minValue(root));\n    return 0;\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#define MAX_SIZE 100000\n\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\nstruct Node* createNode(int val) {\n    struct Node* node\n      = (struct Node*)malloc(sizeof(struct Node));\n    node->data = val;\n    node->left = node->right = NULL;\n\n    return node;\n}\n\nvoid inorder(struct Node* root, int *sortedInorder, int *index) {\n    if (root == NULL) return;\n\n    inorder(root->left, sortedInorder, index);\n    sortedInorder[(*index)++] = root->data;\n\n    inorder(root->right, sortedInorder, index);\n}\n\nint minValue(struct Node* root) {\n    if (root == NULL) return -1;\n\n    int sortedInorder[MAX_SIZE];\n    int index = 0;\n\n    inorder(root, sortedInorder, &index);\n    return sortedInorder[0];\n\n}\nint main() {\n\n\n\n\n\n\n\n\n    struct Node* root = createNode(5);\n    root->left = createNode(4);\n    root->right = createNode(6);\n    root->left->left = createNode(3);\n    root->right->right = createNode(7);\n    root->left->left->left = createNode(1);\n    printf(\"%d\n\", minValue(root));\n    return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/find-the-minimum-element-in-a-binary-search-tree/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#Driver Code Starts\n# Node structure\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n#Driver Code Ends\n# Performs inorder traversal of BST\n# and stores values in sorted order\ndef inorder(root, sortedInorder):\n    if root is None:\n        return\n    # Traverse left subtree\n    inorder(root.left, sortedInorder)\n    sortedInorder.append(root.data)\n    # Traverse right subtree\n    inorder(root.right, sortedInorder)\n# Returns the minimum value in a BST\ndef minValue(root):\n    if root is None:\n        return -1\n    sortedInorder = []\n    # Get all BST values in sorted order\n    inorder(root, sortedInorder)\n    return sortedInorder[0]\n#Driver Code Starts\nif __name__ == \"__main__\":\n    # Create BST\n    #        5\n    #       / \\\n    #      4   6\n    #     /     \\\n    #    3       7\n    #   /\n    #  1\n    root = Node(5)\n    root.left = Node(4)\n    root.right = Node(6)\n    root.left.left = Node(3)\n    root.right.right = Node(7)\n    root.left.left.left = Node(1)\n    print(minValue(root))\n#Driver Code Ends",
    "code_without_comments": "\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\n\n\ndef inorder(root, sortedInorder):\n    if root is None:\n        return\n\n    inorder(root.left, sortedInorder)\n    sortedInorder.append(root.data)\n\n    inorder(root.right, sortedInorder)\n\ndef minValue(root):\n    if root is None:\n        return -1\n    sortedInorder = []\n\n    inorder(root, sortedInorder)\n    return sortedInorder[0]\n\nif __name__ == \"__main__\":\n\n\n\n\n\n\n\n\n    root = Node(5)\n    root.left = Node(4)\n    root.right = Node(6)\n    root.left.left = Node(3)\n    root.right.right = Node(7)\n    root.left.left.left = Node(1)\n    print(minValue(root))\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/find-the-minimum-element-in-a-binary-search-tree/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <iostream>\nusing namespace std;\n// Node structure\nclass Node {\npublic:\n    int data;\n    Node *left, *right;\n    Node(int x) {\n        data = x;\n        left = right = nullptr;\n    }\n};\n//Driver Code Ends\nint minValue(Node* root) {\n    // If left child is null, root is minimum\n    if (root->left == nullptr) return root->data;\n    // Recurse on left child\n    return minValue(root->left);\n}\n//Driver Code Starts\nint main() {\n    // Create BST\n    //        5\n    //       / \\\n    //      4   6\n    //     /     \\\n    //    3       7\n    //   /\n    //  1\n    Node* root = new Node(5);\n    root->left = new Node(4);\n    root->right = new Node(6);\n    root->left->left = new Node(3);\n    root->right->right = new Node(7);\n    root->left->left->left = new Node(1);\n    cout << minValue(root) << endl;\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <iostream>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node *left, *right;\n    Node(int x) {\n        data = x;\n        left = right = nullptr;\n    }\n};\n\nint minValue(Node* root) {\n\n    if (root->left == nullptr) return root->data;\n\n    return minValue(root->left);\n}\n\nint main() {\n\n\n\n\n\n\n\n\n    Node* root = new Node(5);\n    root->left = new Node(4);\n    root->right = new Node(6);\n    root->left->left = new Node(3);\n    root->right->right = new Node(7);\n    root->left->left->left = new Node(1);\n    cout << minValue(root) << endl;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/find-the-minimum-element-in-a-binary-search-tree/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#Driver Code Starts\n# Node structure\nclass Node:\n    def __init__(self, x):\n        self.data = x\n        self.left = None\n        self.right = None\n#Driver Code Ends\ndef minValue(root):\n    # If left child is null, root is minimum\n    if root.left is None:\n        return root.data\n    # Recurse on left child\n    return minValue(root.left)\n#Driver Code Starts\nif __name__ == \"__main__\":\n    # Create BST\n    #        5\n    #       / \\\n    #      4   6\n    #     /     \\\n    #    3       7\n    #   /\n    #  1\n    root = Node(5)\n    root.left = Node(4)\n    root.right = Node(6)\n    root.left.left = Node(3)\n    root.right.right = Node(7)\n    root.left.left.left = Node(1)\n    print(minValue(root))\n#Driver Code Ends",
    "code_without_comments": "\n\nclass Node:\n    def __init__(self, x):\n        self.data = x\n        self.left = None\n        self.right = None\n\ndef minValue(root):\n\n    if root.left is None:\n        return root.data\n\n    return minValue(root.left)\n\nif __name__ == \"__main__\":\n\n\n\n\n\n\n\n\n    root = Node(5)\n    root.left = Node(4)\n    root.right = Node(6)\n    root.left.left = Node(3)\n    root.right.right = Node(7)\n    root.left.left.left = Node(1)\n    print(minValue(root))\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/find-the-minimum-element-in-a-binary-search-tree/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <iostream>\nusing namespace std;\n// Node structure\nstruct Node {\n    int data;\n    Node *left, *right;\n    Node(int val) {\n        data = val;\n        left = right = nullptr;\n    }\n};\n//Driver Code Ends\nint minValue(Node* root) {\n    if (root == nullptr) {\n        return -1;\n    }\n    Node* curr = root;\n    // leftmost node is minimum so we move in BST till\n    // left node is not nullptr\n    while (curr->left != nullptr) {\n        curr = curr->left;\n    }\n    // returning the data at the leftmost node\n    return curr->data;\n}\n//Driver Code Starts\nint main() {\n    // Representation of input binary search tree\n    //        5\n    //       / \\\n    //      4   6\n    //     /     \\\n    //    3       7\n    //   /\n    //  1\n    Node* root = new Node(5);\n    root->left = new Node(4);\n    root->right = new Node(6);\n    root->left->left = new Node(3);\n    root->right->right = new Node(7);\n    root->left->left->left = new Node(1);\n    cout << minValue(root) << \"\n\";\n    return 0;\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <iostream>\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node *left, *right;\n    Node(int val) {\n        data = val;\n        left = right = nullptr;\n    }\n};\n\nint minValue(Node* root) {\n    if (root == nullptr) {\n        return -1;\n    }\n    Node* curr = root;\n\n\n    while (curr->left != nullptr) {\n        curr = curr->left;\n    }\n\n    return curr->data;\n}\n\nint main() {\n\n\n\n\n\n\n\n\n    Node* root = new Node(5);\n    root->left = new Node(4);\n    root->right = new Node(6);\n    root->left->left = new Node(3);\n    root->right->right = new Node(7);\n    root->left->left->left = new Node(1);\n    cout << minValue(root) << \"\n\";\n    return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/find-the-minimum-element-in-a-binary-search-tree/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n// Node structure\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\nstruct Node* createNode(int val) {\n    struct Node* node\n            = (struct Node*)malloc(sizeof(struct Node));\n    node->data = val;\n    node->left = node->right = NULL;\n    return node;\n}\n//Driver Code Ends\nint minValue(struct Node* root) {\n    if (root == NULL) {\n        return -1;\n    }\n    struct Node* curr = root;\n    // leftmost node is minimum, so move\n    // till left is not NULL\n    while (curr->left != NULL) {\n        curr = curr->left;\n    }\n    // returning the data at the leftmost node\n    return curr->data;\n}\n//Driver Code Starts\nint main() {\n    // Representation of input binary search tree\n    //        5\n    //       / \\\n    //      4   6\n    //     /     \\\n    //    3       7\n    //   /\n    //  1\n    struct Node* root = createNode(5);\n    root->left = createNode(4);\n    root->right = createNode(6);\n    root->left->left = createNode(3);\n    root->right->right = createNode(7);\n    root->left->left->left = createNode(1);\n    printf(\"%d\n\", minValue(root));\n    return 0;\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\nstruct Node* createNode(int val) {\n    struct Node* node\n            = (struct Node*)malloc(sizeof(struct Node));\n    node->data = val;\n    node->left = node->right = NULL;\n    return node;\n}\n\nint minValue(struct Node* root) {\n    if (root == NULL) {\n        return -1;\n    }\n    struct Node* curr = root;\n\n\n    while (curr->left != NULL) {\n        curr = curr->left;\n    }\n\n    return curr->data;\n}\n\nint main() {\n\n\n\n\n\n\n\n\n    struct Node* root = createNode(5);\n    root->left = createNode(4);\n    root->right = createNode(6);\n    root->left->left = createNode(3);\n    root->right->right = createNode(7);\n    root->left->left->left = createNode(1);\n    printf(\"%d\n\", minValue(root));\n    return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/find-the-minimum-element-in-a-binary-search-tree/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#Driver Code Starts\n# Node structure\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n#Driver Code Ends\ndef minValue(root):\n    if root is None:\n        return -1\n    curr = root\n    # leftmost node is minimum, so move\n    # till left is not None\n    while curr.left is not None:\n        curr = curr.left\n    # returning the data at the leftmost node\n    return curr.data\n#Driver Code Starts\nif __name__ == \"__main__\":\n    # Representation of input binary search tree\n    #        5\n    #       / \\\n    #      4   6\n    #     /     \\\n    #    3       7\n    #   /\n    #  1\n    root = Node(5)\n    root.left = Node(4)\n    root.right = Node(6)\n    root.left.left = Node(3)\n    root.right.right = Node(7)\n    root.left.left.left = Node(1)\n    print(minValue(root))\n#Driver Code Ends",
    "code_without_comments": "\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef minValue(root):\n    if root is None:\n        return -1\n    curr = root\n\n\n    while curr.left is not None:\n        curr = curr.left\n\n    return curr.data\n\nif __name__ == \"__main__\":\n\n\n\n\n\n\n\n\n    root = Node(5)\n    root.left = Node(4)\n    root.right = Node(6)\n    root.left.left = Node(3)\n    root.right.right = Node(7)\n    root.left.left.left = Node(1)\n    print(minValue(root))\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/find-the-minimum-element-in-a-binary-search-tree/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <iostream>\n#include <vector>\nusing namespace std;\n// Node Structure\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(int x) {\n        data = x;\n        left = right = nullptr;\n    }\n};\n//Driver Code Ends\n// traversal to find\n// predecessor and successor\nvoid preorder(Node* root, int key, Node*& pre, Node*& suc) {\n    if (root == nullptr) return;\n    if (root->data < key && (pre == nullptr || pre->data < root->data)) {\n        pre = root;\n    }\n    if (root->data > key && (suc == nullptr || suc->data > root->data)) {\n        suc = root;\n    }\n    preorder(root->left, key, pre, suc);\n    preorder(root->right, key, pre, suc);\n}\n// return vector with predecessor at\n// index 0 and successor at index 1\nvector<Node*> findPreSuc(Node* root, int key) {\n    Node* pre = nullptr;\n    Node* suc = nullptr;\n    preorder(root, key, pre, suc);\n    return {pre, suc};\n}\n//Driver Code Starts\nint main() {\n    // Create BST:\n    //      50\n    //     /  \\\n    //   30     70\n    //   / \\    / \\\n    // 20  40  60  80\n    int key = 65;\n    Node* root = new Node(50);\n    root->left = new Node(30);\n    root->right = new Node(70);\n    root->left->left = new Node(20);\n    root->left->right = new Node(40);\n    root->right->left = new Node(60);\n    root->right->right = new Node(80);\n    vector<Node*> result = findPreSuc(root, key);\n    Node* pre = result[0];\n    Node* suc = result[1];\n    cout << (pre ? to_string(pre->data) : \"NULL\") << \" \";\n    cout << (suc ? to_string(suc->data) : \"NULL\") << endl;\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(int x) {\n        data = x;\n        left = right = nullptr;\n    }\n};\n\n\n\nvoid preorder(Node* root, int key, Node*& pre, Node*& suc) {\n    if (root == nullptr) return;\n    if (root->data < key && (pre == nullptr || pre->data < root->data)) {\n        pre = root;\n    }\n    if (root->data > key && (suc == nullptr || suc->data > root->data)) {\n        suc = root;\n    }\n    preorder(root->left, key, pre, suc);\n    preorder(root->right, key, pre, suc);\n}\n\n\nvector<Node*> findPreSuc(Node* root, int key) {\n    Node* pre = nullptr;\n    Node* suc = nullptr;\n    preorder(root, key, pre, suc);\n    return {pre, suc};\n}\n\nint main() {\n\n\n\n\n\n\n    int key = 65;\n    Node* root = new Node(50);\n    root->left = new Node(30);\n    root->right = new Node(70);\n    root->left->left = new Node(20);\n    root->left->right = new Node(40);\n    root->right->left = new Node(60);\n    root->right->right = new Node(80);\n    vector<Node*> result = findPreSuc(root, key);\n    Node* pre = result[0];\n    Node* suc = result[1];\n    cout << (pre ? to_string(pre->data) : \"NULL\") << \" \";\n    cout << (suc ? to_string(suc->data) : \"NULL\") << endl;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/inorder-predecessor-successor-given-key-bst/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#Driver Code Starts\n# Node Structure\nclass Node:\n    def __init__(self, x):\n        self.data = x\n        self.left = None\n        self.right = None\n#Driver Code Ends\n# traversal to find predecessor and successor\ndef preorder(root, key, pre, suc):\n    if root is None:\n        return\n    if root.data < key and (pre[0] is None or pre[0].data < root.data):\n        pre[0] = root\n    if root.data > key and (suc[0] is None or suc[0].data > root.data):\n        suc[0] = root\n    preorder(root.left, key, pre, suc)\n    preorder(root.right, key, pre, suc)\n# return list with predecessor at index 0 and successor at index 1\ndef findPreSuc(root, key):\n    pre = [None]\n    suc = [None]\n    preorder(root, key, pre, suc)\n    return [pre[0], suc[0]]\n#Driver Code Starts\nif __name__ == \"__main__\":\n    # Create BST:\n    #      50\n    #     /  \\\n    #   30     70\n    #   / \\    / \\\n    # 20  40  60  80\n    key = 65\n    root = Node(50)\n    root.left = Node(30)\n    root.right = Node(70)\n    root.left.left = Node(20)\n    root.left.right = Node(40)\n    root.right.left = Node(60)\n    root.right.right = Node(80)\n    result = findPreSuc(root, key)\n    pre = result[0]\n    suc = result[1]\n    print((str(pre.data) if pre else \"NULL\"), (str(suc.data) if suc else \"NULL\"))\n#Driver Code Ends",
    "code_without_comments": "\n\nclass Node:\n    def __init__(self, x):\n        self.data = x\n        self.left = None\n        self.right = None\n\n\ndef preorder(root, key, pre, suc):\n    if root is None:\n        return\n    if root.data < key and (pre[0] is None or pre[0].data < root.data):\n        pre[0] = root\n    if root.data > key and (suc[0] is None or suc[0].data > root.data):\n        suc[0] = root\n    preorder(root.left, key, pre, suc)\n    preorder(root.right, key, pre, suc)\n\ndef findPreSuc(root, key):\n    pre = [None]\n    suc = [None]\n    preorder(root, key, pre, suc)\n    return [pre[0], suc[0]]\n\nif __name__ == \"__main__\":\n\n\n\n\n\n\n    key = 65\n    root = Node(50)\n    root.left = Node(30)\n    root.right = Node(70)\n    root.left.left = Node(20)\n    root.left.right = Node(40)\n    root.right.left = Node(60)\n    root.right.right = Node(80)\n    result = findPreSuc(root, key)\n    pre = result[0]\n    suc = result[1]\n    print((str(pre.data) if pre else \"NULL\"), (str(suc.data) if suc else \"NULL\"))\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/inorder-predecessor-successor-given-key-bst/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <vector>\n#include <iostream>\nusing namespace std;\n// Node Structure\nclass Node {\n  public:\n    int data;\n    Node* left;\n    Node* right;\n    Node(int val) {\n        data = val;\n        left = right = nullptr;\n    }\n};\n//Driver Code Ends\n// Finding predecessor of key\nNode* findPredecessor(Node* root, int key) {\n    Node* predecessor = NULL;\n    while (root) {\n        if (key > root->data) {\n            // potential predecessor\n            predecessor = root;\n            // look for larger predecessors\n            root = root->right;\n        } else {\n            root = root->left;\n        }\n    }\n    return predecessor;\n}\n// Finding successor of key\nNode* findSuccessor(Node* root, int key) {\n    Node* successor = NULL;\n    while (root) {\n        if (key < root->data) {\n            // potential successor\n            successor = root;\n            // look for smaller successor\n            root = root->left;\n        } else {\n            root = root->right;\n        }\n    }\n    return successor;\n}\n// return vector with predecessor at index 0\n// and successor at index 1\nvector<Node*> findPreSuc(Node* root, int key) {\n    Node* pre = findPredecessor(root, key);\n    Node* suc = findSuccessor(root, key);\n    return {pre, suc};\n}\n//Driver Code Starts\nint main() {\n    // Create BST:\n    //      50\n    //     /  \\\n    //   30     70\n    //   / \\    / \\\n    // 20  40  60  80\n    Node* root = new Node(50);\n    root->left = new Node(30);\n    root->right = new Node(70);\n    root->left->left = new Node(20);\n    root->left->right = new Node(40);\n    root->right->left = new Node(60);\n    root->right->right = new Node(80);\n    int key = 65;\n    vector<Node*> result = findPreSuc(root, key);\n    Node* pre = result[0];\n    Node* suc = result[1];\n    cout << (pre ? to_string(pre->data) : string(\"NULL\")) << \" \"\n     << (suc ? to_string(suc->data) : string(\"NULL\"));\n    return 0;\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <vector>\n#include <iostream>\nusing namespace std;\n\nclass Node {\n  public:\n    int data;\n    Node* left;\n    Node* right;\n    Node(int val) {\n        data = val;\n        left = right = nullptr;\n    }\n};\n\n\nNode* findPredecessor(Node* root, int key) {\n    Node* predecessor = NULL;\n    while (root) {\n        if (key > root->data) {\n\n            predecessor = root;\n\n            root = root->right;\n        } else {\n            root = root->left;\n        }\n    }\n    return predecessor;\n}\n\nNode* findSuccessor(Node* root, int key) {\n    Node* successor = NULL;\n    while (root) {\n        if (key < root->data) {\n\n            successor = root;\n\n            root = root->left;\n        } else {\n            root = root->right;\n        }\n    }\n    return successor;\n}\n\n\nvector<Node*> findPreSuc(Node* root, int key) {\n    Node* pre = findPredecessor(root, key);\n    Node* suc = findSuccessor(root, key);\n    return {pre, suc};\n}\n\nint main() {\n\n\n\n\n\n\n    Node* root = new Node(50);\n    root->left = new Node(30);\n    root->right = new Node(70);\n    root->left->left = new Node(20);\n    root->left->right = new Node(40);\n    root->right->left = new Node(60);\n    root->right->right = new Node(80);\n    int key = 65;\n    vector<Node*> result = findPreSuc(root, key);\n    Node* pre = result[0];\n    Node* suc = result[1];\n    cout << (pre ? to_string(pre->data) : string(\"NULL\")) << \" \"\n     << (suc ? to_string(suc->data) : string(\"NULL\"));\n    return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/inorder-predecessor-successor-given-key-bst/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#Driver Code Starts\n# Node Structure\nclass Node:\n    def __init__(self, x):\n        self.data = x\n        self.left = None\n        self.right = None\n#Driver Code Ends\n# Finding predecessor of key\ndef findPredecessor(root, key):\n    predecessor = None\n    while root:\n        if key > root.data:\n            #  potential predecessor\n            predecessor = root;\n            #  look for larger predecessors\n            root = root.right\n        else:\n            root = root.left\n    return predecessor\n# Finding successor of key\ndef findSuccessor(root, key):\n    successor = None\n    while root:\n        if key < root.data:\n            # potential successor\n            successor = root\n            # look for smaller successor\n            root = root.left\n        else:\n            root = root.right\n    return successor\n#  return list with predecessor at index 0\n#  and successor at index 1\ndef findPreSuc(root, key):\n    return [findPredecessor(root, key), findSuccessor(root, key)]\n#Driver Code Starts\nif __name__ == '__main__':\n    # Create BST:\n    #          50\n    #         /  \\\n    #       30     70\n    #       / \\    / \\\n    #     20  40  60  80\n    root = Node(50)\n    root.left = Node(30)\n    root.right = Node(70)\n    root.left.left = Node(20)\n    root.left.right = Node(40)\n    root.right.left = Node(60)\n    root.right.right = Node(80)\n    key = 65\n    pre, suc = findPreSuc(root, key)\n    print((pre.data if pre else \"NULL\"),\n          (suc.data if suc else \"NULL\"))\n#Driver Code Ends",
    "code_without_comments": "\n\nclass Node:\n    def __init__(self, x):\n        self.data = x\n        self.left = None\n        self.right = None\n\n\ndef findPredecessor(root, key):\n    predecessor = None\n    while root:\n        if key > root.data:\n\n            predecessor = root;\n\n            root = root.right\n        else:\n            root = root.left\n    return predecessor\n\ndef findSuccessor(root, key):\n    successor = None\n    while root:\n        if key < root.data:\n\n            successor = root\n\n            root = root.left\n        else:\n            root = root.right\n    return successor\n\n\ndef findPreSuc(root, key):\n    return [findPredecessor(root, key), findSuccessor(root, key)]\n\nif __name__ == '__main__':\n\n\n\n\n\n\n    root = Node(50)\n    root.left = Node(30)\n    root.right = Node(70)\n    root.left.left = Node(20)\n    root.left.right = Node(40)\n    root.right.left = Node(60)\n    root.right.right = Node(80)\n    key = 65\n    pre, suc = findPreSuc(root, key)\n    print((pre.data if pre else \"NULL\"),\n          (suc.data if suc else \"NULL\"))\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/inorder-predecessor-successor-given-key-bst/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n#include <vector>\n#include <iostream>\nusing namespace std;\n// Node Structure\nclass Node {\n  public:\n    int data;\n    Node* left;\n    Node* right;\n    Node(int val) {\n        data = val;\n        left = right = nullptr;\n    }\n};\n//Driver Code Ends\nNode* rightMost(Node* node) {\n    while (node->right)\n        node = node->right;\n    return node;\n}\nNode* leftMost(Node* node) {\n    while (node->left)\n        node = node->left;\n    return node;\n}\n// return vector with predecessor at index 0\n// and successor at index 1\nvector<Node*> findPreSuc(Node* root, int key) {\n    Node* pre = NULL;\n    Node* suc = NULL;\n    Node* curr = root;\n    while (curr) {\n        if (curr->data < key) {\n            pre = curr;\n            // look for predecessor with greater value\n            curr = curr->right;\n        } else if (curr->data > key) {\n            suc = curr;\n            // look for successor with smaller value\n            curr = curr->left;\n        } else {\n            if (curr->left)\n                pre = rightMost(curr->left);\n            if (curr->right)\n                suc = leftMost(curr->right);\n            break;\n        }\n    }\n    return {pre, suc};\n}\n//Driver Code Starts\nint main() {\n    int key = 65;\n    // Create BST:\n    //      50\n    //     /  \\\n    //   30     70\n    //   / \\    / \\\n    // 20  40  60  80\n    Node* root = new Node(50);\n    root->left = new Node(30);\n    root->right = new Node(70);\n    root->left->left = new Node(20);\n    root->left->right = new Node(40);\n    root->right->left = new Node(60);\n    root->right->right = new Node(80);\n    vector<Node*> result = findPreSuc(root, key);\n    Node* pre = result[0];\n    Node* suc = result[1];\n    cout << (pre ? to_string(pre->data) : \"NULL\") << \" \";\n    cout << (suc ? to_string(suc->data) : \"NULL\");\n}\n//Driver Code Ends",
    "code_without_comments": "\n#include <vector>\n#include <iostream>\nusing namespace std;\n\nclass Node {\n  public:\n    int data;\n    Node* left;\n    Node* right;\n    Node(int val) {\n        data = val;\n        left = right = nullptr;\n    }\n};\n\nNode* rightMost(Node* node) {\n    while (node->right)\n        node = node->right;\n    return node;\n}\nNode* leftMost(Node* node) {\n    while (node->left)\n        node = node->left;\n    return node;\n}\n\n\nvector<Node*> findPreSuc(Node* root, int key) {\n    Node* pre = NULL;\n    Node* suc = NULL;\n    Node* curr = root;\n    while (curr) {\n        if (curr->data < key) {\n            pre = curr;\n\n            curr = curr->right;\n        } else if (curr->data > key) {\n            suc = curr;\n\n            curr = curr->left;\n        } else {\n            if (curr->left)\n                pre = rightMost(curr->left);\n            if (curr->right)\n                suc = leftMost(curr->right);\n            break;\n        }\n    }\n    return {pre, suc};\n}\n\nint main() {\n    int key = 65;\n\n\n\n\n\n\n    Node* root = new Node(50);\n    root->left = new Node(30);\n    root->right = new Node(70);\n    root->left->left = new Node(20);\n    root->left->right = new Node(40);\n    root->right->left = new Node(60);\n    root->right->right = new Node(80);\n    vector<Node*> result = findPreSuc(root, key);\n    Node* pre = result[0];\n    Node* suc = result[1];\n    cout << (pre ? to_string(pre->data) : \"NULL\") << \" \";\n    cout << (suc ? to_string(suc->data) : \"NULL\");\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/inorder-predecessor-successor-given-key-bst/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#Driver Code Starts\n# Node Structure\nclass Node:\n    def __init__(self, x):\n        self.data = x\n        self.left = None\n        self.right = None\n#Driver Code Ends\ndef rightMost(node):\n    while node.right:\n        node = node.right\n    return node\ndef leftMost(node):\n    while node.left:\n        node = node.left\n    return node\n#  return list with predecessor at index 0\n#  and successor at index 1\ndef findPreSuc(root, key):\n    pre, suc = None, None\n    curr = root\n    while curr:\n        if curr.data < key:\n            pre = curr\n            #  look for predecessor with greater value\n            curr = curr.right\n        elif curr.data > key:\n            suc = curr\n            #  look for successor with smaller value\n            curr = curr.left\n        else:\n            if curr.left:\n                pre = rightMost(curr.left)\n            if curr.right:\n                suc = leftMost(curr.right)\n            break\n    return [pre, suc]\n#Driver Code Starts\nif __name__ == \"__main__\":\n    key = 65\n    # Create BST:\n    #      50\n    #     /  \\\n    #   30     70\n    #   / \\    / \\\n    # 20  40  60  80\n    root = Node(50)\n    root.left = Node(30)\n    root.right = Node(70)\n    root.left.left = Node(20)\n    root.left.right = Node(40)\n    root.right.left = Node(60)\n    root.right.right = Node(80)\n    pre, suc = findPreSuc(root, key)\n    print((pre.data if pre else \"NULL\"), (suc.data if suc else \"NULL\"))\n#Driver Code Ends",
    "code_without_comments": "\n\nclass Node:\n    def __init__(self, x):\n        self.data = x\n        self.left = None\n        self.right = None\n\ndef rightMost(node):\n    while node.right:\n        node = node.right\n    return node\ndef leftMost(node):\n    while node.left:\n        node = node.left\n    return node\n\n\ndef findPreSuc(root, key):\n    pre, suc = None, None\n    curr = root\n    while curr:\n        if curr.data < key:\n            pre = curr\n\n            curr = curr.right\n        elif curr.data > key:\n            suc = curr\n\n            curr = curr.left\n        else:\n            if curr.left:\n                pre = rightMost(curr.left)\n            if curr.right:\n                suc = leftMost(curr.right)\n            break\n    return [pre, suc]\n\nif __name__ == \"__main__\":\n    key = 65\n\n\n\n\n\n\n    root = Node(50)\n    root.left = Node(30)\n    root.right = Node(70)\n    root.left.left = Node(20)\n    root.left.right = Node(40)\n    root.right.left = Node(60)\n    root.right.right = Node(80)\n    pre, suc = findPreSuc(root, key)\n    print((pre.data if pre else \"NULL\"), (suc.data if suc else \"NULL\"))\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/inorder-predecessor-successor-given-key-bst/",
    "complexity_weight": 1.0
  }
]