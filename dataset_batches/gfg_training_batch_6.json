[
  {
    "code_with_comments": "// C++ program to check if a given tree is BST.\n#include <bits/stdc++.h>\nusing namespace std;\n/* A binary tree node has data, pointer to\nleft child and a pointer to right child */\nstruct Node {\n    int data;\n    struct Node *left, *right;\n    Node(int data)\n    {\n        this->data = data;\n        left = right = NULL;\n    }\n};\n// Utility function to check if Binary Tree is BST\nbool isBSTUtil(struct Node* root, int& prev)\n{\n    // traverse the tree in inorder fashion and\n    // keep track of prev node\n    if (root) {\n        if (!isBSTUtil(root->left, prev))\n            return false;\n        // Allows only distinct valued nodes\n        if (root->data <= prev)\n            return false;\n        // Initialize prev to current\n        prev = root->data;\n        return isBSTUtil(root->right, prev);\n    }\n    return true;\n}\n// Function to check if Binary Tree is BST\nbool isBST(Node* root)\n{\n    int prev = INT_MIN;\n    return isBSTUtil(root, prev);\n}\n/* Driver code*/\nint main()\n{\n    struct Node* root = new Node(5);\n    root->left = new Node(2);\n    root->right = new Node(15);\n    root->left->left = new Node(1);\n    root->left->right = new Node(4);\n    if (isBST(root))\n        cout << \"Is BST\";\n    else\n        cout << \"Not a BST\";\n    return 0;\n}",
    "code_without_comments": "\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Node {\n    int data;\n    struct Node *left, *right;\n    Node(int data)\n    {\n        this->data = data;\n        left = right = NULL;\n    }\n};\n\nbool isBSTUtil(struct Node* root, int& prev)\n{\n\n\n    if (root) {\n        if (!isBSTUtil(root->left, prev))\n            return false;\n\n        if (root->data <= prev)\n            return false;\n\n        prev = root->data;\n        return isBSTUtil(root->right, prev);\n    }\n    return true;\n}\n\nbool isBST(Node* root)\n{\n    int prev = INT_MIN;\n    return isBSTUtil(root, prev);\n}\n\nint main()\n{\n    struct Node* root = new Node(5);\n    root->left = new Node(2);\n    root->right = new Node(15);\n    root->left->left = new Node(1);\n    root->left->right = new Node(4);\n    if (isBST(root))\n        cout << \"Is BST\";\n    else\n        cout << \"Not a BST\";\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/check-if-a-binary-tree-is-bst-simple-and-efficient-approach/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "// Java program to check if a given tree is BST.\nclass GFG {\n    static int prev = Integer.MIN_VALUE;\n    /* A binary tree node has data, pointer to\n    left child and a pointer to right child */\n    static class Node {\n        int data;\n        Node left, right;\n        Node(int data)\n        {\n            this.data = data;\n            left = right = null;\n        }\n    };\n    // Utility function to check if Binary Tree is BST\n    static boolean isBSTUtil(Node root)\n    {\n        // traverse the tree in inorder fashion and\n        // keep track of prev node\n        if (root != null) {\n            if (!isBSTUtil(root.left))\n                return false;\n            // Allows only distinct valued nodes\n            if (root.data <= prev)\n                return false;\n            // Initialize prev to current\n            prev = root.data;\n            return isBSTUtil(root.right);\n        }\n        return true;\n    }\n    // Function to check if Binary Tree is BST\n    static boolean isBST(Node root)\n    {\n        return isBSTUtil(root);\n    }\n    /* Driver code*/\n    public static void main(String[] args)\n    {\n        Node root = new Node(5);\n        root.left = new Node(2);\n        root.right = new Node(15);\n        root.left.left = new Node(1);\n        root.left.right = new Node(4);\n        if (isBST(root))\n            System.out.print(\"Is BST\");\n        else\n            System.out.print(\"Not a BST\");\n    }\n}\n// This code is contributed by PrinciRaj1992",
    "code_without_comments": "// Java program to check if a given tree is BST.\nclass GFG {\n    static int prev = Integer.MIN_VALUE;\n    /* A binary tree node has data, pointer to\n    left child and a pointer to right child */\n    static class Node {\n        int data;\n        Node left, right;\n        Node(int data)\n        {\n            this.data = data;\n            left = right = null;\n        }\n    };\n    // Utility function to check if Binary Tree is BST\n    static boolean isBSTUtil(Node root)\n    {\n        // traverse the tree in inorder fashion and\n        // keep track of prev node\n        if (root != null) {\n            if (!isBSTUtil(root.left))\n                return false;\n            // Allows only distinct valued nodes\n            if (root.data <= prev)\n                return false;\n            // Initialize prev to current\n            prev = root.data;\n            return isBSTUtil(root.right);\n        }\n        return true;\n    }\n    // Function to check if Binary Tree is BST\n    static boolean isBST(Node root)\n    {\n        return isBSTUtil(root);\n    }\n    /* Driver code*/\n    public static void main(String[] args)\n    {\n        Node root = new Node(5);\n        root.left = new Node(2);\n        root.right = new Node(15);\n        root.left.left = new Node(1);\n        root.left.right = new Node(4);\n        if (isBST(root))\n            System.out.print(\"Is BST\");\n        else\n            System.out.print(\"Not a BST\");\n    }\n}\n// This code is contributed by PrinciRaj1992",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/check-if-a-binary-tree-is-bst-simple-and-efficient-approach/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "# Python3 program to check if a given tree is BST.\nimport math\nprev = -math.inf\nclass Node:\n    \"\"\"\n    Creates a Binary tree node that has data,\n    a pointer to it's left and right child\n    \"\"\"\n    def __init__(self, data):\n        self.left = None\n        self.right = None\n        self.data = data\ndef checkBST(root):\n    \"\"\"\n    Function to check if Binary Tree is\n    a Binary Search Tree\n    :param root: current root node\n    :return: Boolean value\n    \"\"\"\n    # traverse the tree in inorder\n    # fashion and update the prev node\n    global prev\n    if root:\n        if not checkBST(root.left):\n            return False\n        # Handles same valued nodes\n        if root.data < prev:\n            return False\n        # Set value of prev to current node\n        prev = root.data\n        return checkBST(root.right)\n    return True\n# Driver Code\ndef main():\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(15)\n    root.left.left = Node(1)\n    root.left.right = Node(4)\n    if checkBST(root):\n        print(\"Is BST\")\n    else:\n        print(\"Not a BST\")\nif __name__ == '__main__':\n    main()\n# This code is contributed by priyankapunjabi94",
    "code_without_comments": "\nimport math\nprev = -math.inf\nclass Node:\n    \"\"\"\n    Creates a Binary tree node that has data,\n    a pointer to it's left and right child\n    \"\"\"\n    def __init__(self, data):\n        self.left = None\n        self.right = None\n        self.data = data\ndef checkBST(root):\n    \"\"\"\n    Function to check if Binary Tree is\n    a Binary Search Tree\n    :param root: current root node\n    :return: Boolean value\n    \"\"\"\n\n\n    global prev\n    if root:\n        if not checkBST(root.left):\n            return False\n\n        if root.data < prev:\n            return False\n\n        prev = root.data\n        return checkBST(root.right)\n    return True\n\ndef main():\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(15)\n    root.left.left = Node(1)\n    root.left.right = Node(4)\n    if checkBST(root):\n        print(\"Is BST\")\n    else:\n        print(\"Not a BST\")\nif __name__ == '__main__':\n    main()\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/check-if-a-binary-tree-is-bst-simple-and-efficient-approach/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n// C++ program to find kth smallest value in BST\n#include <iostream>\nusing namespace std;\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(int x) {\n        data = x;\n        left = nullptr;\n        right = nullptr;\n    }\n};\n//Driver Code Ends\n// Function to find kth smallest element in a BST.\nint kthSmallest(Node* root, int k) {\n    int cnt = 0;\n    Node* curr = root;\n    while (curr != nullptr) {\n        // If left child is null, check\n        // curr node and move to right node.\n        if (curr->left == nullptr) {\n            cnt++;\n            // If curr is kth smallest node\n            if (cnt == k) return curr->data;\n            curr = curr->right;\n        }\n        else {\n            // Find the inorder predecessor of curr\n            Node* pre = curr->left;\n            while (pre->right != nullptr\n                   && pre->right != curr)\n                pre = pre->right;\n            // Make curr as the right child of its\n            // inorder predecessor and move to\n            // left node.\n            if (pre->right == nullptr) {\n                pre->right = curr;\n                curr = curr->left;\n            }\n            // Revert the changes made in the 'if' part to\n            // restore the original tree i.e., fix the right\n            // child of predecessor\n            else {\n                pre->right = nullptr;\n                cnt++;\n                if (cnt == k) return curr->data;\n                curr = curr->right;\n            }\n        }\n    }\n    // If k is greater than size of\n    // BST, return -1.\n    return -1;\n}\n//Driver Code Starts\nint main() {\n    // Binary search tree\n    //      20\n    //    /   \\\n    //   8     22\n    //  / \\\n    // 4   12\n    //    /  \\\n    //   10   14\n    Node* root = new Node(20);\n    root->left = new Node(8);\n    root->right = new Node(22);\n    root->left->left = new Node(4);\n    root->left->right = new Node(12);\n    root->left->right->left = new Node(10);\n    root->left->right->right = new Node(14);\n    int k = 3;\n    cout << kthSmallest(root, k) << endl;\n    return 0;\n}\n//Driver Code Ends",
    "code_without_comments": "\n\n#include <iostream>\nusing namespace std;\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(int x) {\n        data = x;\n        left = nullptr;\n        right = nullptr;\n    }\n};\n\n\nint kthSmallest(Node* root, int k) {\n    int cnt = 0;\n    Node* curr = root;\n    while (curr != nullptr) {\n\n\n        if (curr->left == nullptr) {\n            cnt++;\n\n            if (cnt == k) return curr->data;\n            curr = curr->right;\n        }\n        else {\n\n            Node* pre = curr->left;\n            while (pre->right != nullptr\n                   && pre->right != curr)\n                pre = pre->right;\n\n\n\n            if (pre->right == nullptr) {\n                pre->right = curr;\n                curr = curr->left;\n            }\n\n\n\n            else {\n                pre->right = nullptr;\n                cnt++;\n                if (cnt == k) return curr->data;\n                curr = curr->right;\n            }\n        }\n    }\n\n\n    return -1;\n}\n\nint main() {\n\n\n\n\n\n\n\n\n    Node* root = new Node(20);\n    root->left = new Node(8);\n    root->right = new Node(22);\n    root->left->left = new Node(4);\n    root->left->right = new Node(12);\n    root->left->right->left = new Node(10);\n    root->left->right->right = new Node(14);\n    int k = 3;\n    cout << kthSmallest(root, k) << endl;\n    return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/kth-smallest-element-in-bst-using-o1-extra-space/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "//Driver Code Starts\n// C program to find kth smallest value in BST\n#include <stdio.h>\n#include <stdlib.h>\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n//Driver Code Ends\n// Function to find kth smallest element in a BST.\nint kthSmallest(struct Node* root, int k) {\n    int cnt = 0;\n    struct Node* curr = root;\n    while (curr != NULL) {\n        // if left child is null, check\n        // curr node and move to right node.\n        if (curr->left == NULL) {\n            cnt++;\n            // If curr is kth smallest node\n            if (cnt == k) return curr->data;\n            curr = curr->right;\n        }\n        else {\n            // Find the inorder predecessor of curr\n            struct Node* pre = curr->left;\n            while (pre->right != NULL && pre->right != curr)\n                pre = pre->right;\n            // Make curr as the right child of its\n            // inorder predecessor and move to\n            // left node.\n            if (pre->right == NULL) {\n                pre->right = curr;\n                curr = curr->left;\n            }\n            // Revert the changes made in the 'if' part to\n            // restore the original tree i.e., fix the right\n            // child of predecessor\n            else {\n                pre->right = NULL;\n                cnt++;\n                if (cnt == k) return curr->data;\n                curr = curr->right;\n            }\n        }\n    }\n    // If k is greater than size of\n    // BST, return -1.\n    return -1;\n}\n//Driver Code Starts\nstruct Node* createNode(int x) {\n    struct Node* newNode =\n    \t(struct Node*)malloc(sizeof(struct Node));\n    newNode->data = x;\n    newNode->left = NULL;\n    newNode->right = NULL;\n    return newNode;\n}\nint main() {\n    // Binary search tree\n    //      20\n    //    /   \\\n    //   8     22\n    //  / \\\n    // 4   12\n    //    /  \\\n    //   10   14\n    struct Node* root = createNode(20);\n    root->left = createNode(8);\n    root->right = createNode(22);\n    root->left->left = createNode(4);\n    root->left->right = createNode(12);\n    root->left->right->left = createNode(10);\n    root->left->right->right = createNode(14);\n    int k = 3;\n    printf(\"%d\n\", kthSmallest(root, k));\n    return 0;\n}\n//Driver Code Ends",
    "code_without_comments": "\n\n#include <stdio.h>\n#include <stdlib.h>\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\n\nint kthSmallest(struct Node* root, int k) {\n    int cnt = 0;\n    struct Node* curr = root;\n    while (curr != NULL) {\n\n\n        if (curr->left == NULL) {\n            cnt++;\n\n            if (cnt == k) return curr->data;\n            curr = curr->right;\n        }\n        else {\n\n            struct Node* pre = curr->left;\n            while (pre->right != NULL && pre->right != curr)\n                pre = pre->right;\n\n\n\n            if (pre->right == NULL) {\n                pre->right = curr;\n                curr = curr->left;\n            }\n\n\n\n            else {\n                pre->right = NULL;\n                cnt++;\n                if (cnt == k) return curr->data;\n                curr = curr->right;\n            }\n        }\n    }\n\n\n    return -1;\n}\n\nstruct Node* createNode(int x) {\n    struct Node* newNode =\n    \t(struct Node*)malloc(sizeof(struct Node));\n    newNode->data = x;\n    newNode->left = NULL;\n    newNode->right = NULL;\n    return newNode;\n}\nint main() {\n\n\n\n\n\n\n\n\n    struct Node* root = createNode(20);\n    root->left = createNode(8);\n    root->right = createNode(22);\n    root->left->left = createNode(4);\n    root->left->right = createNode(12);\n    root->left->right->left = createNode(10);\n    root->left->right->right = createNode(14);\n    int k = 3;\n    printf(\"%d\n\", kthSmallest(root, k));\n    return 0;\n}\n",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/kth-smallest-element-in-bst-using-o1-extra-space/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#Driver Code Starts\n# Python program to find kth smallest value in BST\nclass Node:\n    def __init__(self, x):\n        self.data = x\n        self.left = None\n        self.right = None\n#Driver Code Ends\n# Function to find kth smallest element in a BST.\ndef kthSmallest(root, k):\n    cnt = 0\n    curr = root\n    while curr:\n        # if left child is null, check\n        # curr node and move to right node.\n        if not curr.left:\n            cnt += 1\n            # If curr is kth smallest node\n            if cnt == k:\n                return curr.data\n            curr = curr.right\n        else:\n            # Find the inorder predecessor of curr\n            pre = curr.left\n            while pre.right and pre.right != curr:\n                pre = pre.right\n            # Make curr as the right child of its\n            # inorder predecessor and move to\n            # left node.\n            if not pre.right:\n                pre.right = curr\n                curr = curr.left\n            else:\n                # Revert the changes made in the 'if' part to\n                # restore the original tree i.e., fix the right\n                # child of predecessor\n                pre.right = None\n                cnt += 1\n                if cnt == k:\n                    return curr.data\n                curr = curr.right\n    # If k is greater than size of\n    # BST, return -1.\n    return -1\n#Driver Code Starts\nif __name__ == \"__main__\":\n    # Binary search tree\n    #      20\n    #    /   \\\n    #   8     22\n    #  / \\\n    # 4   12\n    #    /  \\\n    #   10   14\n    root = Node(20)\n    root.left = Node(8)\n    root.right = Node(22)\n    root.left.left = Node(4)\n    root.left.right = Node(12)\n    root.left.right.left = Node(10)\n    root.left.right.right = Node(14)\n    k = 3\n    print(kthSmallest(root, k))\n#Driver Code Ends",
    "code_without_comments": "\n\nclass Node:\n    def __init__(self, x):\n        self.data = x\n        self.left = None\n        self.right = None\n\n\ndef kthSmallest(root, k):\n    cnt = 0\n    curr = root\n    while curr:\n\n\n        if not curr.left:\n            cnt += 1\n\n            if cnt == k:\n                return curr.data\n            curr = curr.right\n        else:\n\n            pre = curr.left\n            while pre.right and pre.right != curr:\n                pre = pre.right\n\n\n\n            if not pre.right:\n                pre.right = curr\n                curr = curr.left\n            else:\n                # Revert the changes made in the 'if' part to\n\n\n                pre.right = None\n                cnt += 1\n                if cnt == k:\n                    return curr.data\n                curr = curr.right\n\n\n    return -1\n\nif __name__ == \"__main__\":\n\n\n\n\n\n\n\n\n    root = Node(20)\n    root.left = Node(8)\n    root.right = Node(22)\n    root.left.left = Node(4)\n    root.left.right = Node(12)\n    root.left.right.left = Node(10)\n    root.left.right.right = Node(14)\n    k = 3\n    print(kthSmallest(root, k))\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/kth-smallest-element-in-bst-using-o1-extra-space/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <string>\nusing namespace std;\n// Node structure with explicit pointers for tree navigation\nstruct Node {\n    int data;\n    string color; // \"RED\" or \"BLACK\"\n    Node *left, *right, *parent;\n    Node(int data) : data(data), color(\"RED\"),\n                     left(nullptr), right(nullptr), parent(nullptr) {}\n};\nclass RedBlackTree {\nprivate:\n    Node* root;\n    Node* NIL; // Sentinel node used to represent leaves (always BLACK)\n    // --- Rotations: Essential for maintaining tree balance ---\n    void leftRotate(Node* x) {\n        Node* y = x->right;\n        x->right = y->left;\n        if (y->left != NIL) y->left->parent = x;\n        y->parent = x->parent;\n        if (x->parent == nullptr)      root = y;\n        else if (x == x->parent->left) x->parent->left = y;\n        else                          x->parent->right = y;\n        y->left = x;\n        x->parent = y;\n    }\n    void rightRotate(Node* x) {\n        Node* y = x->left;\n        x->left = y->right;\n        if (y->right != NIL) y->right->parent = x;\n        y->parent = x->parent;\n        if (x->parent == nullptr)       root = y;\n        else if (x == x->parent->right) x->parent->right = y;\n        else                           x->parent->left = y;\n        y->right = x;\n        x->parent = y;\n    }\n    // --- RB Fix-up: Resolves Double-Red violations ---\n    void fixInsert(Node* k) {\n        // Continue while the parent is Red (violates RB property)\n        while (k != root && k->parent->color == \"RED\") {\n            if (k->parent == k->parent->parent->left) {\n                Node* uncle = k->parent->parent->right;\n                if (uncle->color == \"RED\") {\n                    // Case 1: Uncle is Red -> Recolor parent, uncle, and grandparent\n                    k->parent->color = \"BLACK\";\n                    uncle->color = \"BLACK\";\n                    k->parent->parent->color = \"RED\";\n                    k = k->parent->parent;\n                } else {\n                    if (k == k->parent->right) {\n                        // Case 2: Triangle shape -> Left rotate parent to form a line\n                        k = k->parent;\n                        leftRotate(k);\n                    }\n                    // Case 3: Line shape -> Recolor and right rotate grandparent\n                    k->parent->color = \"BLACK\";\n                    k->parent->parent->color = \"RED\";\n                    rightRotate(k->parent->parent);\n                }\n            } else {\n                // Mirror Case: Parent is the right child\n                Node* uncle = k->parent->parent->left;\n                if (uncle->color == \"RED\") {\n                    k->parent->color = \"BLACK\";\n                    uncle->color = \"BLACK\";\n                    k->parent->parent->color = \"RED\";\n                    k = k->parent->parent;\n                } else {\n                    if (k == k->parent->left) {\n                        k = k->parent;\n                        rightRotate(k);\n                    }\n                    k->parent->color = \"BLACK\";\n                    k->parent->parent->color = \"RED\";\n                    leftRotate(k->parent->parent);\n                }\n            }\n        }\n        root->color = \"BLACK\"; // Root must always be Black\n    }\npublic:\n    RedBlackTree() {\n        NIL = new Node(0);\n        NIL->color = \"BLACK\";\n        NIL->left = NIL->right = NIL;\n        root = NIL;\n    }\n    void insert(int data) {\n        Node* node = new Node(data);\n        node->left = node->right = NIL;\n        Node* parent = nullptr;\n        Node* current = root;\n        // Step 1: Standard Binary Search Tree insertion\n        while (current != NIL) {\n            parent = current;\n            if (node->data < current->data) current = current->left;\n            else current = current->right;\n        }\n        node->parent = parent;\n        if (parent == nullptr)      root = node;\n        else if (node->data < parent->data) parent->left = node;\n        else                               parent->right = node;\n        // Step 2: Handle edge cases and fix RB properties\n        if (node->parent == nullptr) {\n            node->color = \"BLACK\";\n            return;\n        }\n        if (node->parent->parent == nullptr) return;\n        fixInsert(node);\n    }\n    void inorder(Node* node) {\n        if (node != NIL) {\n            inorder(node->left);\n            cout << node->data << \"(\" << node->color << \") \";\n            inorder(node->right);\n        }\n    }\n    Node* getRoot() { return root; }\n};\nint main() {\n    RedBlackTree rbt;\n    rbt.insert(10);\n    rbt.insert(20);\n    rbt.insert(30);\n    rbt.insert(15);\n    cout << \"Inorder Traversal -> \";\n    rbt.inorder(rbt.getRoot());\n    cout << endl;\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct Node {\n    int data;\n    string color;\n    Node *left, *right, *parent;\n    Node(int data) : data(data), color(\"RED\"),\n                     left(nullptr), right(nullptr), parent(nullptr) {}\n};\nclass RedBlackTree {\nprivate:\n    Node* root;\n    Node* NIL;\n\n    void leftRotate(Node* x) {\n        Node* y = x->right;\n        x->right = y->left;\n        if (y->left != NIL) y->left->parent = x;\n        y->parent = x->parent;\n        if (x->parent == nullptr)      root = y;\n        else if (x == x->parent->left) x->parent->left = y;\n        else                          x->parent->right = y;\n        y->left = x;\n        x->parent = y;\n    }\n    void rightRotate(Node* x) {\n        Node* y = x->left;\n        x->left = y->right;\n        if (y->right != NIL) y->right->parent = x;\n        y->parent = x->parent;\n        if (x->parent == nullptr)       root = y;\n        else if (x == x->parent->right) x->parent->right = y;\n        else                           x->parent->left = y;\n        y->right = x;\n        x->parent = y;\n    }\n\n    void fixInsert(Node* k) {\n\n        while (k != root && k->parent->color == \"RED\") {\n            if (k->parent == k->parent->parent->left) {\n                Node* uncle = k->parent->parent->right;\n                if (uncle->color == \"RED\") {\n\n                    k->parent->color = \"BLACK\";\n                    uncle->color = \"BLACK\";\n                    k->parent->parent->color = \"RED\";\n                    k = k->parent->parent;\n                } else {\n                    if (k == k->parent->right) {\n\n                        k = k->parent;\n                        leftRotate(k);\n                    }\n\n                    k->parent->color = \"BLACK\";\n                    k->parent->parent->color = \"RED\";\n                    rightRotate(k->parent->parent);\n                }\n            } else {\n\n                Node* uncle = k->parent->parent->left;\n                if (uncle->color == \"RED\") {\n                    k->parent->color = \"BLACK\";\n                    uncle->color = \"BLACK\";\n                    k->parent->parent->color = \"RED\";\n                    k = k->parent->parent;\n                } else {\n                    if (k == k->parent->left) {\n                        k = k->parent;\n                        rightRotate(k);\n                    }\n                    k->parent->color = \"BLACK\";\n                    k->parent->parent->color = \"RED\";\n                    leftRotate(k->parent->parent);\n                }\n            }\n        }\n        root->color = \"BLACK\";\n    }\npublic:\n    RedBlackTree() {\n        NIL = new Node(0);\n        NIL->color = \"BLACK\";\n        NIL->left = NIL->right = NIL;\n        root = NIL;\n    }\n    void insert(int data) {\n        Node* node = new Node(data);\n        node->left = node->right = NIL;\n        Node* parent = nullptr;\n        Node* current = root;\n\n        while (current != NIL) {\n            parent = current;\n            if (node->data < current->data) current = current->left;\n            else current = current->right;\n        }\n        node->parent = parent;\n        if (parent == nullptr)      root = node;\n        else if (node->data < parent->data) parent->left = node;\n        else                               parent->right = node;\n\n        if (node->parent == nullptr) {\n            node->color = \"BLACK\";\n            return;\n        }\n        if (node->parent->parent == nullptr) return;\n        fixInsert(node);\n    }\n    void inorder(Node* node) {\n        if (node != NIL) {\n            inorder(node->left);\n            cout << node->data << \"(\" << node->color << \") \";\n            inorder(node->right);\n        }\n    }\n    Node* getRoot() { return root; }\n};\nint main() {\n    RedBlackTree rbt;\n    rbt.insert(10);\n    rbt.insert(20);\n    rbt.insert(30);\n    rbt.insert(15);\n    cout << \"Inorder Traversal -> \";\n    rbt.inorder(rbt.getRoot());\n    cout << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/red-black-tree-set-1-introduction-2/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "from typing import Optional\n# Node structure with explicit pointers for tree navigation\nclass Node:\n    def __init__(self, data: int):\n        self.data = data\n        self.color = \"RED\"  # \"RED\" or \"BLACK\"\n        self.left = None\n        self.right = None\n        self.parent = None\nclass RedBlackTree:\n    def __init__(self):\n        self.NIL = Node(0)\n        self.NIL.color = \"BLACK\"\n        self.root = self.NIL\n    # --- Rotations: Essential for maintaining tree balance ---\n    def left_rotate(self, x: Node):\n        y = x.right\n        x.right = y.left\n        if y.left is not self.NIL:\n            y.left.parent = x\n        y.parent = x.parent\n        if x.parent is None:\n            self.root = y\n        elif x == x.parent.left:\n            x.parent.left = y\n        else:\n            x.parent.right = y\n        y.left = x\n        x.parent = y\n    def right_rotate(self, x: Node):\n        y = x.left\n        x.left = y.right\n        if y.right is not self.NIL:\n            y.right.parent = x\n        y.parent = x.parent\n        if x.parent is None:\n            self.root = y\n        elif x == x.parent.right:\n            x.parent.right = y\n        else:\n            x.parent.left = y\n        y.right = x\n        x.parent = y\n    # --- RB Fix-up: Resolves Double-Red violations ---\n    def fix_insert(self, k: Node):\n        while k!= self.root and k.parent.color == \"RED\":\n            if k.parent == k.parent.parent.left:\n                uncle = k.parent.parent.right\n                if uncle.color == \"RED\":\n                    k.parent.color = \"BLACK\"\n                    uncle.color = \"BLACK\"\n                    k.parent.parent.color = \"RED\"\n                    k = k.parent.parent\n                else:\n                    if k == k.parent.right:\n                        k = k.parent\n                        self.left_rotate(k)\n                    k.parent.color = \"BLACK\"\n                    k.parent.parent.color = \"RED\"\n                    self.right_rotate(k.parent.parent)\n            else:\n                uncle = k.parent.parent.left\n                if uncle.color == \"RED\":\n                    k.parent.color = \"BLACK\"\n                    uncle.color = \"BLACK\"\n                    k.parent.parent.color = \"RED\"\n                    k = k.parent.parent\n                else:\n                    if k == k.parent.left:\n                        k = k.parent\n                        self.right_rotate(k)\n                    k.parent.color = \"BLACK\"\n                    k.parent.parent.color = \"RED\"\n                    self.left_rotate(k.parent.parent)\n        self.root.color = \"BLACK\"  # Root must always be Black\n    def insert(self, data: int):\n        node = Node(data)\n        node.left = self.NIL\n        node.right = self.NIL\n        parent = None\n        current = self.root\n        # Step 1: Standard Binary Search Tree insertion\n        while current!= self.NIL:\n            parent = current\n            if node.data < current.data:\n                current = current.left\n            else:\n                current = current.right\n        node.parent = parent\n        if parent is None:\n            self.root = node\n        elif node.data < parent.data:\n            parent.left = node\n        else:\n            parent.right = node\n        # Step 2: Handle edge cases and fix RB properties\n        if node.parent is None:\n            node.color = \"BLACK\"\n            return\n        if node.parent.parent is None:\n            return\n        self.fix_insert(node)\n    def inorder(self, node: Node):\n        if node!= self.NIL:\n            self.inorder(node.left)\n            print(f\"{node.data}({node.color})\", end=\" \")\n            self.inorder(node.right)\nif __name__ == \"__main__\":\n    rbt = RedBlackTree()\n    rbt.insert(10)\n    rbt.insert(20)\n    rbt.insert(30)\n    rbt.insert(15)\n    print(\"Inorder Traversal ->\", end=\" \")\n    rbt.inorder(rbt.root)\n    print()",
    "code_without_comments": "from typing import Optional\n\nclass Node:\n    def __init__(self, data: int):\n        self.data = data\n        self.color = \"RED\"  # \"RED\" or \"BLACK\"\n        self.left = None\n        self.right = None\n        self.parent = None\nclass RedBlackTree:\n    def __init__(self):\n        self.NIL = Node(0)\n        self.NIL.color = \"BLACK\"\n        self.root = self.NIL\n\n    def left_rotate(self, x: Node):\n        y = x.right\n        x.right = y.left\n        if y.left is not self.NIL:\n            y.left.parent = x\n        y.parent = x.parent\n        if x.parent is None:\n            self.root = y\n        elif x == x.parent.left:\n            x.parent.left = y\n        else:\n            x.parent.right = y\n        y.left = x\n        x.parent = y\n    def right_rotate(self, x: Node):\n        y = x.left\n        x.left = y.right\n        if y.right is not self.NIL:\n            y.right.parent = x\n        y.parent = x.parent\n        if x.parent is None:\n            self.root = y\n        elif x == x.parent.right:\n            x.parent.right = y\n        else:\n            x.parent.left = y\n        y.right = x\n        x.parent = y\n\n    def fix_insert(self, k: Node):\n        while k!= self.root and k.parent.color == \"RED\":\n            if k.parent == k.parent.parent.left:\n                uncle = k.parent.parent.right\n                if uncle.color == \"RED\":\n                    k.parent.color = \"BLACK\"\n                    uncle.color = \"BLACK\"\n                    k.parent.parent.color = \"RED\"\n                    k = k.parent.parent\n                else:\n                    if k == k.parent.right:\n                        k = k.parent\n                        self.left_rotate(k)\n                    k.parent.color = \"BLACK\"\n                    k.parent.parent.color = \"RED\"\n                    self.right_rotate(k.parent.parent)\n            else:\n                uncle = k.parent.parent.left\n                if uncle.color == \"RED\":\n                    k.parent.color = \"BLACK\"\n                    uncle.color = \"BLACK\"\n                    k.parent.parent.color = \"RED\"\n                    k = k.parent.parent\n                else:\n                    if k == k.parent.left:\n                        k = k.parent\n                        self.right_rotate(k)\n                    k.parent.color = \"BLACK\"\n                    k.parent.parent.color = \"RED\"\n                    self.left_rotate(k.parent.parent)\n        self.root.color = \"BLACK\"  # Root must always be Black\n    def insert(self, data: int):\n        node = Node(data)\n        node.left = self.NIL\n        node.right = self.NIL\n        parent = None\n        current = self.root\n\n        while current!= self.NIL:\n            parent = current\n            if node.data < current.data:\n                current = current.left\n            else:\n                current = current.right\n        node.parent = parent\n        if parent is None:\n            self.root = node\n        elif node.data < parent.data:\n            parent.left = node\n        else:\n            parent.right = node\n\n        if node.parent is None:\n            node.color = \"BLACK\"\n            return\n        if node.parent.parent is None:\n            return\n        self.fix_insert(node)\n    def inorder(self, node: Node):\n        if node!= self.NIL:\n            self.inorder(node.left)\n            print(f\"{node.data}({node.color})\", end=\" \")\n            self.inorder(node.right)\nif __name__ == \"__main__\":\n    rbt = RedBlackTree()\n    rbt.insert(10)\n    rbt.insert(20)\n    rbt.insert(30)\n    rbt.insert(15)\n    print(\"Inorder Traversal ->\", end=\" \")\n    rbt.inorder(rbt.root)\n    print()",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/red-black-tree-set-1-introduction-2/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#include <iostream>\nusing namespace std;\nclass Node {\n  public:\n    int data;\n    Node *next;\n    Node(int new_data) {\n        data = new_data;\n        next = nullptr;\n    }\n};\nNode *reverseList(Node *head) {\n    Node *curr = head, *prev = nullptr, *next;\n    // Traverse all the nodes of Linked List\n    while (curr != nullptr) {\n        // Store next\n        next = curr->next;\n        // Reverse current node's next pointer\n        curr->next = prev;\n        // Move pointers one position ahead\n        prev = curr;\n        curr = next;\n    }\n    return prev;\n}\nvoid printList(Node *node) {\n    while (node != nullptr) {\n        cout << node->data;\n        if (node->next)\n            cout << \" -> \";\n        node = node->next;\n    }\n}\nint main() {\n    Node *head = new Node(1);\n    head->next = new Node(2);\n    head->next->next = new Node(3);\n    head->next->next->next = new Node(4);\n    head->next->next->next->next = new Node(5);\n    head = reverseList(head);\n    printList(head);\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\nusing namespace std;\nclass Node {\n  public:\n    int data;\n    Node *next;\n    Node(int new_data) {\n        data = new_data;\n        next = nullptr;\n    }\n};\nNode *reverseList(Node *head) {\n    Node *curr = head, *prev = nullptr, *next;\n\n    while (curr != nullptr) {\n\n        next = curr->next;\n\n        curr->next = prev;\n\n        prev = curr;\n        curr = next;\n    }\n    return prev;\n}\nvoid printList(Node *node) {\n    while (node != nullptr) {\n        cout << node->data;\n        if (node->next)\n            cout << \" -> \";\n        node = node->next;\n    }\n}\nint main() {\n    Node *head = new Node(1);\n    head->next = new Node(2);\n    head->next->next = new Node(3);\n    head->next->next->next = new Node(4);\n    head->next->next->next->next = new Node(5);\n    head = reverseList(head);\n    printList(head);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/reverse-a-linked-list/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <stdio.h>\nstruct Node {\n    int data;\n    struct Node *next;\n};\nstruct Node *reverseList(struct Node *head) {\n    struct Node *curr = head, *prev = NULL, *next;\n    // traverse all the nodes of Linked List\n    while (curr != NULL) {\n        // store next\n        next = curr->next;\n        // reverse current node's next pointer\n        curr->next = prev;\n        // move pointers one position ahead\n        prev = curr;\n        curr = next;\n    }\n    return prev;\n}\nvoid printList(struct Node *node) {\n    while (node != NULL) {\n        printf(\"%d\", node->data);\n        if (node->next)\n            printf(\" -> \");\n        node = node->next;\n    }\n}\nstruct Node *createNode(int new_data) {\n    struct Node *new_node = (struct Node *)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->next = NULL;\n    return new_node;\n}\nint main() {\n    struct Node *head = createNode(1);\n    head->next = createNode(2);\n    head->next->next = createNode(3);\n    head->next->next->next = createNode(4);\n    head->next->next->next->next = createNode(5);\n    head = reverseList(head);\n    printList(head);\n    return 0;\n}",
    "code_without_comments": "#include <stdio.h>\nstruct Node {\n    int data;\n    struct Node *next;\n};\nstruct Node *reverseList(struct Node *head) {\n    struct Node *curr = head, *prev = NULL, *next;\n\n    while (curr != NULL) {\n\n        next = curr->next;\n\n        curr->next = prev;\n\n        prev = curr;\n        curr = next;\n    }\n    return prev;\n}\nvoid printList(struct Node *node) {\n    while (node != NULL) {\n        printf(\"%d\", node->data);\n        if (node->next)\n            printf(\" -> \");\n        node = node->next;\n    }\n}\nstruct Node *createNode(int new_data) {\n    struct Node *new_node = (struct Node *)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->next = NULL;\n    return new_node;\n}\nint main() {\n    struct Node *head = createNode(1);\n    head->next = createNode(2);\n    head->next->next = createNode(3);\n    head->next->next->next = createNode(4);\n    head->next->next->next->next = createNode(5);\n    head = reverseList(head);\n    printList(head);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/reverse-a-linked-list/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "class Node:\n    def __init__(self, newData):\n        self.data = newData\n        self.next = None\ndef reverseList(head):\n    curr = head\n    prev = None\n    # traverse all the nodes of Linked List\n    while curr is not None:\n        # store next\n        nextNode = curr.next\n        # reverse current node's next pointer\n        curr.next = prev\n        # move pointers one position ahead\n        prev = curr\n        curr = nextNode\n    return prev\ndef printList(node):\n    while node is not None:\n        print(f\"{node.data}\", end=\"\")\n        if node.next is not None:\n            print(\" -> \", end=\"\")\n        node = node.next\n    print()\nif __name__ == \"__main__\":\n    head = Node(1)\n    head.next = Node(2)\n    head.next.next = Node(3)\n    head.next.next.next = Node(4)\n    head.next.next.next.next = Node(5)\n    head = reverseList(head)\n    printList(head)",
    "code_without_comments": "class Node:\n    def __init__(self, newData):\n        self.data = newData\n        self.next = None\ndef reverseList(head):\n    curr = head\n    prev = None\n\n    while curr is not None:\n\n        nextNode = curr.next\n        # reverse current node's next pointer\n        curr.next = prev\n\n        prev = curr\n        curr = nextNode\n    return prev\ndef printList(node):\n    while node is not None:\n        print(f\"{node.data}\", end=\"\")\n        if node.next is not None:\n            print(\" -> \", end=\"\")\n        node = node.next\n    print()\nif __name__ == \"__main__\":\n    head = Node(1)\n    head.next = Node(2)\n    head.next.next = Node(3)\n    head.next.next.next = Node(4)\n    head.next.next.next.next = Node(5)\n    head = reverseList(head)\n    printList(head)",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/reverse-a-linked-list/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\nusing namespace std;\nclass Node {\n  public:\n    int data;\n    Node *next;\n    Node(int new_data) {\n        data = new_data;\n        next = nullptr;\n    }\n};\nNode *reverseList(Node *head) {\n    if (head == NULL || head->next == NULL)\n        return head;\n    // reverse the rest of linked list and put\n    // the first element at the end\n    Node *rest = reverseList(head->next);\n    // Make the current head as last node of\n    // remaining linked list\n    head->next->next = head;\n    // Update next of current head to NULL\n    head->next = NULL;\n    return rest;\n}\nvoid printList(Node *node) {\n    while (node != nullptr) {\n        cout << node->data;\n        if (node->next)\n            cout << \" -> \";\n        node = node->next;\n    }\n}\nint main() {\n    Node *head = new Node(1);\n    head->next = new Node(2);\n    head->next->next = new Node(3);\n    head->next->next->next = new Node(4);\n    head->next->next->next->next = new Node(5);\n    head = reverseList(head);\n    printList(head);\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\nusing namespace std;\nclass Node {\n  public:\n    int data;\n    Node *next;\n    Node(int new_data) {\n        data = new_data;\n        next = nullptr;\n    }\n};\nNode *reverseList(Node *head) {\n    if (head == NULL || head->next == NULL)\n        return head;\n\n\n    Node *rest = reverseList(head->next);\n\n\n    head->next->next = head;\n\n    head->next = NULL;\n    return rest;\n}\nvoid printList(Node *node) {\n    while (node != nullptr) {\n        cout << node->data;\n        if (node->next)\n            cout << \" -> \";\n        node = node->next;\n    }\n}\nint main() {\n    Node *head = new Node(1);\n    head->next = new Node(2);\n    head->next->next = new Node(3);\n    head->next->next->next = new Node(4);\n    head->next->next->next->next = new Node(5);\n    head = reverseList(head);\n    printList(head);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/reverse-a-linked-list/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <stdio.h>\n#include <stdlib.h>\nstruct Node {\n    int data;\n    struct Node *next;\n};\nstruct Node *reverseList(struct Node *head) {\n    if (head == NULL || head->next == NULL)\n        return head;\n    // reverse the rest of linked list and put\n    // the first element at the end\n    struct Node *rest = reverseList(head->next);\n    // make the current head as last node of\n    // remaining linked list\n    head->next->next = head;\n    // update next of current head to NULL\n    head->next = NULL;\n    return rest;\n}\nvoid printList(struct Node *node) {\n    while (node != NULL) {\n        printf(\"%d\", node->data);\n        if (node->next)\n            printf(\" -> \");\n        node = node->next;\n    }\n    printf(\"\\n\");\n}\nstruct Node *createNode(int new_data) {\n    struct Node *new_node = (struct Node *)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->next = NULL;\n    return new_node;\n}\nint main() {\n    struct Node *head = createNode(1);\n    head->next = createNode(2);\n    head->next->next = createNode(3);\n    head->next->next->next = createNode(4);\n    head->next->next->next->next = createNode(5);\n    head = reverseList(head);\n    printList(head);\n    return 0;\n}",
    "code_without_comments": "#include <stdio.h>\n#include <stdlib.h>\nstruct Node {\n    int data;\n    struct Node *next;\n};\nstruct Node *reverseList(struct Node *head) {\n    if (head == NULL || head->next == NULL)\n        return head;\n\n\n    struct Node *rest = reverseList(head->next);\n\n\n    head->next->next = head;\n\n    head->next = NULL;\n    return rest;\n}\nvoid printList(struct Node *node) {\n    while (node != NULL) {\n        printf(\"%d\", node->data);\n        if (node->next)\n            printf(\" -> \");\n        node = node->next;\n    }\n    printf(\"\\n\");\n}\nstruct Node *createNode(int new_data) {\n    struct Node *new_node = (struct Node *)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->next = NULL;\n    return new_node;\n}\nint main() {\n    struct Node *head = createNode(1);\n    head->next = createNode(2);\n    head->next->next = createNode(3);\n    head->next->next->next = createNode(4);\n    head->next->next->next->next = createNode(5);\n    head = reverseList(head);\n    printList(head);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/reverse-a-linked-list/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "class Node:\n    def __init__(self, newData):\n        self.data = newData\n        self.next = None\ndef reverseList(head):\n    if head is None or head.next is None:\n        return head\n    # reverse the rest of linked list and put the\n    # first element at the end\n    rest = reverseList(head.next)\n    # make the current head as last node of\n    # remaining linked list\n    head.next.next = head\n    # update next of current head to NULL\n    head.next = None\n    return rest\ndef printList(node):\n    while node is not None:\n        print(f\"{node.data}\", end=\"\")\n        if node.next is not None:\n            print(\" -> \", end=\"\")\n        node = node.next\n    print()\nif __name__ == \"__main__\":\n    # Create a hard-coded linked list:\n    # 1 -> 2 -> 3 -> 4 -> 5\n    head = Node(1)\n    head.next = Node(2)\n    head.next.next = Node(3)\n    head.next.next.next = Node(4)\n    head.next.next.next.next = Node(5)\n    head = reverseList(head)\n    printList(head)",
    "code_without_comments": "class Node:\n    def __init__(self, newData):\n        self.data = newData\n        self.next = None\ndef reverseList(head):\n    if head is None or head.next is None:\n        return head\n\n\n    rest = reverseList(head.next)\n\n\n    head.next.next = head\n\n    head.next = None\n    return rest\ndef printList(node):\n    while node is not None:\n        print(f\"{node.data}\", end=\"\")\n        if node.next is not None:\n            print(\" -> \", end=\"\")\n        node = node.next\n    print()\nif __name__ == \"__main__\":\n\n\n    head = Node(1)\n    head.next = Node(2)\n    head.next.next = Node(3)\n    head.next.next.next = Node(4)\n    head.next.next.next.next = Node(5)\n    head = reverseList(head)\n    printList(head)",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/reverse-a-linked-list/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <stack>\nusing namespace std;\nclass Node {\n  public:\n    int data;\n    Node *next;\n    Node(int new_data) {\n        data = new_data;\n        next = nullptr;\n    }\n};\nNode *reverseList(Node *head) {\n    stack<Node *> s;\n    Node *temp = head;\n    // push all nodes except the last node into stack\n    while (temp->next != NULL) {\n        s.push(temp);\n        temp = temp->next;\n    }\n    // make the last node as new head of the linked list\n    head = temp;\n    // pop all the nodes and append to the linked list\n    while (!s.empty()) {\n        // append the top value of stack in list\n        temp->next = s.top();\n        s.pop();\n        temp = temp->next;\n    }\n    // update the next pointer of last node of stack to null\n    temp->next = NULL;\n    return head;\n}\nvoid printList(Node *node) {\n    while (node != nullptr) {\n        cout << node->data;\n        if (node->next)\n            cout << \" -> \";\n        node = node->next;\n    }\n}\nint main() {\n    Node *head = new Node(1);\n    head->next = new Node(2);\n    head->next->next = new Node(3);\n    head->next->next->next = new Node(4);\n    head->next->next->next->next = new Node(5);\n    head = reverseList(head);\n    printList(head);\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <stack>\nusing namespace std;\nclass Node {\n  public:\n    int data;\n    Node *next;\n    Node(int new_data) {\n        data = new_data;\n        next = nullptr;\n    }\n};\nNode *reverseList(Node *head) {\n    stack<Node *> s;\n    Node *temp = head;\n\n    while (temp->next != NULL) {\n        s.push(temp);\n        temp = temp->next;\n    }\n\n    head = temp;\n\n    while (!s.empty()) {\n\n        temp->next = s.top();\n        s.pop();\n        temp = temp->next;\n    }\n\n    temp->next = NULL;\n    return head;\n}\nvoid printList(Node *node) {\n    while (node != nullptr) {\n        cout << node->data;\n        if (node->next)\n            cout << \" -> \";\n        node = node->next;\n    }\n}\nint main() {\n    Node *head = new Node(1);\n    head->next = new Node(2);\n    head->next->next = new Node(3);\n    head->next->next->next = new Node(4);\n    head->next->next->next->next = new Node(5);\n    head = reverseList(head);\n    printList(head);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/reverse-a-linked-list/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <stdio.h>\n#include <stdlib.h>\nstruct Node {\n    int data;\n    struct Node *next;\n};\nstruct Node *createNode(int new_data) {\n    struct Node *new_node = (struct Node *)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->next = NULL;\n    return new_node;\n}\nstruct Node *reverseList(struct Node *head) {\n    struct Node *stack[100000];\n    int top = -1;\n    struct Node *temp = head;\n    // push all nodes into stack\n    while (temp != NULL) {\n        stack[++top] = temp;\n        temp = temp->next;\n    }\n    // make the last node as new head of the linked list\n    if (top >= 0) {\n        head = stack[top];\n        temp = head;\n        // pop all the nodes and append to the linked list\n        while (top > 0) {\n            // append the top value of stack in list\n            temp->next = stack[--top];\n            temp = temp->next;\n        }\n        // update the next pointer of last node of stack to null\n        temp->next = NULL;\n    }\n    return head;\n}\nvoid printList(struct Node *node) {\n    while (node != NULL) {\n        printf(\"%d\", node->data);\n        if (node->next)\n            printf(\" -> \");\n        node = node->next;\n    }\n    printf(\"\\n\");\n}\nint main() {\n    struct Node *head = createNode(1);\n    head->next = createNode(2);\n    head->next->next = createNode(3);\n    head->next->next->next = createNode(4);\n    head->next->next->next->next = createNode(5);\n    head = reverseList(head);\n    printList(head);\n    return 0;\n}",
    "code_without_comments": "#include <stdio.h>\n#include <stdlib.h>\nstruct Node {\n    int data;\n    struct Node *next;\n};\nstruct Node *createNode(int new_data) {\n    struct Node *new_node = (struct Node *)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->next = NULL;\n    return new_node;\n}\nstruct Node *reverseList(struct Node *head) {\n    struct Node *stack[100000];\n    int top = -1;\n    struct Node *temp = head;\n\n    while (temp != NULL) {\n        stack[++top] = temp;\n        temp = temp->next;\n    }\n\n    if (top >= 0) {\n        head = stack[top];\n        temp = head;\n\n        while (top > 0) {\n\n            temp->next = stack[--top];\n            temp = temp->next;\n        }\n\n        temp->next = NULL;\n    }\n    return head;\n}\nvoid printList(struct Node *node) {\n    while (node != NULL) {\n        printf(\"%d\", node->data);\n        if (node->next)\n            printf(\" -> \");\n        node = node->next;\n    }\n    printf(\"\\n\");\n}\nint main() {\n    struct Node *head = createNode(1);\n    head->next = createNode(2);\n    head->next->next = createNode(3);\n    head->next->next->next = createNode(4);\n    head->next->next->next->next = createNode(5);\n    head = reverseList(head);\n    printList(head);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/reverse-a-linked-list/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "class Node:\n    def __init__(self, new_data):\n        self.data = new_data\n        self.next = None\ndef reverseList(head):\n    stack = []\n    temp = head\n    # push all nodes except the last node into stack\n    while temp.next is not None:\n        stack.append(temp)\n        temp = temp.next\n    head = temp\n    # pop all the nodes and append to the linked list\n    while stack:\n        # append the top value of stack in list\n        temp.next = stack.pop()\n        temp = temp.next\n    temp.next = None\n    return head\ndef printList(node):\n    while node is not None:\n        print(f\"{node.data}\", end=\"\")\n        if node.next is not None:\n            print(\" -> \", end=\"\")\n        node = node.next\n    print()\nif __name__ == \"__main__\":\n    # create a hard-coded linked list:\n    # 1 -> 2 -> 3 -> 4 -> 5\n    head = Node(1)\n    head.next = Node(2)\n    head.next.next = Node(3)\n    head.next.next.next = Node(4)\n    head.next.next.next.next = Node(5)\n    head = reverseList(head)\n    printList(head)",
    "code_without_comments": "class Node:\n    def __init__(self, new_data):\n        self.data = new_data\n        self.next = None\ndef reverseList(head):\n    stack = []\n    temp = head\n\n    while temp.next is not None:\n        stack.append(temp)\n        temp = temp.next\n    head = temp\n\n    while stack:\n\n        temp.next = stack.pop()\n        temp = temp.next\n    temp.next = None\n    return head\ndef printList(node):\n    while node is not None:\n        print(f\"{node.data}\", end=\"\")\n        if node.next is not None:\n            print(\" -> \", end=\"\")\n        node = node.next\n    print()\nif __name__ == \"__main__\":\n\n\n    head = Node(1)\n    head.next = Node(2)\n    head.next.next = Node(3)\n    head.next.next.next = Node(4)\n    head.next.next.next.next = Node(5)\n    head = reverseList(head)\n    printList(head)",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/reverse-a-linked-list/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <unordered_set>\nusing namespace std;\nclass Node {\npublic:\n    int data;\n    Node* next;\n    Node(int x) {\n        this->data = x;\n        this->next = nullptr;\n    }\n};\nbool detectLoop(Node* head) {\n    unordered_set<Node*>st;\n    while (head != nullptr) {\n        // if this node is already present\n        // in hashmap it means there is a cycle\n        if (st.find(head) != st.end())\n            return true;\n        // if we are seeing the node for\n        // the first time, insert it in hash\n        st.insert(head);\n        head = head->next;\n    }\n    return false;\n}\nint main() {\n    Node* head = new Node(1);\n    head->next = new Node(3);\n    head->next->next = new Node(4);\n    head->next->next->next = head->next;\n    if (detectLoop(head))\n        cout << \"true\";\n    else\n        cout << \"false\";\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <unordered_set>\nusing namespace std;\nclass Node {\npublic:\n    int data;\n    Node* next;\n    Node(int x) {\n        this->data = x;\n        this->next = nullptr;\n    }\n};\nbool detectLoop(Node* head) {\n    unordered_set<Node*>st;\n    while (head != nullptr) {\n\n\n        if (st.find(head) != st.end())\n            return true;\n\n\n        st.insert(head);\n        head = head->next;\n    }\n    return false;\n}\nint main() {\n    Node* head = new Node(1);\n    head->next = new Node(3);\n    head->next->next = new Node(4);\n    head->next->next->next = head->next;\n    if (detectLoop(head))\n        cout << \"true\";\n    else\n        cout << \"false\";\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/detect-loop-in-a-linked-list/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "class Node:\n    def __init__(self, x):\n        self.data = x\n        self.next = None\ndef detectLoop(head):\n    st = set()\n    while head is not None:\n        # if this node is already present\n        # in hashmap it means there is a cycle\n        if head in st:\n            return True\n        # if we are seeing the node for\n        # the first time, insert it in hash\n        st.add(head)\n        head = head.next\n    return False\nif __name__ == \"__main__\":\n    head = Node(1)\n    head.next = Node(3)\n    head.next.next = Node(4)\n    head.next.next.next = head.next\n    if detectLoop(head):\n        print(\"true\")\n    else:\n        print(\"false\")",
    "code_without_comments": "class Node:\n    def __init__(self, x):\n        self.data = x\n        self.next = None\ndef detectLoop(head):\n    st = set()\n    while head is not None:\n\n\n        if head in st:\n            return True\n\n\n        st.add(head)\n        head = head.next\n    return False\nif __name__ == \"__main__\":\n    head = Node(1)\n    head.next = Node(3)\n    head.next.next = Node(4)\n    head.next.next.next = head.next\n    if detectLoop(head):\n        print(\"true\")\n    else:\n        print(\"false\")",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/detect-loop-in-a-linked-list/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\nusing namespace std;\nclass Node {\npublic:\n    int data;\n    Node* next;\n    Node(int x) {\n        this->data = x;\n        this->next = nullptr;\n    }\n};\nbool detectLoop(Node* head) {\n    // Fast and slow pointers\n    // initially points to the head\n    Node *slow = head, *fast = head;\n    // Loop that runs while fast and slow pointer are not\n    // nullptr and not equal\n    while (slow && fast && fast->next) {\n        slow = slow->next;\n        fast = fast->next->next;\n        // If fast and slow pointer points to the same node,\n        // then the cycle is detected\n        if (slow == fast) {\n            return true;\n        }\n    }\n    return false;\n}\nint main() {\n    Node* head = new Node(1);\n    head->next = new Node(3);\n    head->next->next = new Node(4);\n    head->next->next->next = head->next;\n    if (detectLoop(head))\n        cout << \"true\";\n    else\n        cout << \"false\";\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\nusing namespace std;\nclass Node {\npublic:\n    int data;\n    Node* next;\n    Node(int x) {\n        this->data = x;\n        this->next = nullptr;\n    }\n};\nbool detectLoop(Node* head) {\n\n\n    Node *slow = head, *fast = head;\n\n\n    while (slow && fast && fast->next) {\n        slow = slow->next;\n        fast = fast->next->next;\n\n\n        if (slow == fast) {\n            return true;\n        }\n    }\n    return false;\n}\nint main() {\n    Node* head = new Node(1);\n    head->next = new Node(3);\n    head->next->next = new Node(4);\n    head->next->next->next = head->next;\n    if (detectLoop(head))\n        cout << \"true\";\n    else\n        cout << \"false\";\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/detect-loop-in-a-linked-list/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\nstruct Node {\n    int data;\n    struct Node* next;\n};\nstruct Node* createNode(int new_data) {\n    struct Node* new_node\n        = (struct Node*)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->next = NULL;\n    return new_node;\n}\nint detectLoop(struct Node* head) {\n    // Fast and slow pointers initially points to the head\n    struct Node *slow = head, *fast = head;\n    // Loop that runs while fast and slow pointer are not\n    // nullptr and not equal\n    while (slow && fast && fast->next) {\n        slow = slow->next;\n        fast = fast->next->next;\n        // If fast and slow pointer points to the same node,\n        // then the cycle is detected\n        if (slow == fast) {\n            return true;\n        }\n    }\n    return false;\n}\nint main() {\n    struct Node* head = createNode(1);\n    head->next = createNode(3);\n    head->next->next = createNode(4);\n    head->next->next->next = head->next;\n    if (detectLoop(head))\n        printf(\"true\");\n    else\n        printf(\"false\");\n    return 0;\n}",
    "code_without_comments": "#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\nstruct Node {\n    int data;\n    struct Node* next;\n};\nstruct Node* createNode(int new_data) {\n    struct Node* new_node\n        = (struct Node*)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->next = NULL;\n    return new_node;\n}\nint detectLoop(struct Node* head) {\n\n    struct Node *slow = head, *fast = head;\n\n\n    while (slow && fast && fast->next) {\n        slow = slow->next;\n        fast = fast->next->next;\n\n\n        if (slow == fast) {\n            return true;\n        }\n    }\n    return false;\n}\nint main() {\n    struct Node* head = createNode(1);\n    head->next = createNode(3);\n    head->next->next = createNode(4);\n    head->next->next->next = head->next;\n    if (detectLoop(head))\n        printf(\"true\");\n    else\n        printf(\"false\");\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/detect-loop-in-a-linked-list/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "class Node:\n    def __init__(self, x):\n        self.data = x\n        self.next = None\ndef detectLoop(head):\n    # fast and slow pointers initially points to the head\n    slow = head\n    fast = head\n    # loop that runs while fast and slow pointer are not\n    # None and not equal\n    while slow and fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        # if fast and slow pointer points to the same node,\n        # then the cycle is detected\n        if slow == fast:\n            return True\n    return False\nif __name__ == \"__main__\":\n    head = Node(1)\n    head.next = Node(3)\n    head.next.next = Node(4)\n    head.next.next.next = head.next\n    if detectLoop(head):\n        print(\"true\")\n    else:\n        print(\"false\")",
    "code_without_comments": "class Node:\n    def __init__(self, x):\n        self.data = x\n        self.next = None\ndef detectLoop(head):\n\n    slow = head\n    fast = head\n\n\n    while slow and fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n\n        if slow == fast:\n            return True\n    return False\nif __name__ == \"__main__\":\n    head = Node(1)\n    head.next = Node(3)\n    head.next.next = Node(4)\n    head.next.next.next = head.next\n    if detectLoop(head):\n        print(\"true\")\n    else:\n        print(\"false\")",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/detect-loop-in-a-linked-list/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nclass Node {\n  public:\n    int data;\n    Node *next;\n    Node(int x) {\n        data = x;\n        next = nullptr;\n    }\n};\nNode *sortedMerge(Node *head1, Node *head2) {\n    vector<int> arr;\n    // pushing the values of the first linked list\n    while (head1 != nullptr) {\n        arr.push_back(head1->data);\n        head1 = head1->next;\n    }\n    // pushing the values of the second linked list\n    while (head2 != nullptr) {\n        arr.push_back(head2->data);\n        head2 = head2->next;\n    }\n    // sorting the vector\n    sort(arr.begin(), arr.end());\n    // creating a new list with sorted values\n    Node *dummy = new Node(-1);\n    Node *curr = dummy;\n    for (int i = 0; i < arr.size(); i++) {\n        curr->next = new Node(arr[i]);\n        curr = curr->next;\n    }\n    return dummy->next;\n}\nvoid printList(Node *curr) {\n    while (curr != nullptr) {\n        cout << curr->data;\n        if (curr->next != nullptr)\n            cout << \" -> \";\n        curr = curr->next;\n    }\n    cout << endl;\n}\nint main() {\n    Node *head1 = new Node(5);\n    head1->next = new Node(10);\n    head1->next->next = new Node(15);\n    head1->next->next->next = new Node(40);\n    Node *head2 = new Node(2);\n    head2->next = new Node(3);\n    head2->next->next = new Node(20);\n    Node *res = sortedMerge(head1, head2);\n    printList(res);\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nclass Node {\n  public:\n    int data;\n    Node *next;\n    Node(int x) {\n        data = x;\n        next = nullptr;\n    }\n};\nNode *sortedMerge(Node *head1, Node *head2) {\n    vector<int> arr;\n\n    while (head1 != nullptr) {\n        arr.push_back(head1->data);\n        head1 = head1->next;\n    }\n\n    while (head2 != nullptr) {\n        arr.push_back(head2->data);\n        head2 = head2->next;\n    }\n\n    sort(arr.begin(), arr.end());\n\n    Node *dummy = new Node(-1);\n    Node *curr = dummy;\n    for (int i = 0; i < arr.size(); i++) {\n        curr->next = new Node(arr[i]);\n        curr = curr->next;\n    }\n    return dummy->next;\n}\nvoid printList(Node *curr) {\n    while (curr != nullptr) {\n        cout << curr->data;\n        if (curr->next != nullptr)\n            cout << \" -> \";\n        curr = curr->next;\n    }\n    cout << endl;\n}\nint main() {\n    Node *head1 = new Node(5);\n    head1->next = new Node(10);\n    head1->next->next = new Node(15);\n    head1->next->next->next = new Node(40);\n    Node *head2 = new Node(2);\n    head2->next = new Node(3);\n    head2->next->next = new Node(20);\n    Node *res = sortedMerge(head1, head2);\n    printList(res);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/merge-two-sorted-linked-lists/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "class Node:\n    def __init__(self, x):\n        self.data = x\n        self.next = None\ndef sortedMerge(head1, head2):\n    arr = []\n    # pushing the values of the first linked list\n    while head1 is not None:\n        arr.append(head1.data)\n        head1 = head1.next\n    # pushing the values of the second linked list\n    while head2 is not None:\n        arr.append(head2.data)\n        head2 = head2.next\n    # sorting the list\n    arr.sort()\n    # creating a new list with sorted values\n    dummy = Node(-1)\n    curr = dummy\n    for value in arr:\n        curr.next = Node(value)\n        curr = curr.next\n    return dummy.next\ndef printList(node):\n    while node is not None:\n        print(f\"{node.data}\", end=\"\")\n        if node.next is not None:\n            print(\" -> \", end=\"\")\n        node = node.next\n    print()\nif __name__ == \"__main__\":\n    head1 = Node(5)\n    head1.next = Node(10)\n    head1.next.next = Node(15)\n    head1.next.next.next = Node(40)\n    head2 = Node(2)\n    head2.next = Node(3)\n    head2.next.next = Node(20)\n    res = sortedMerge(head1, head2)\n    printList(res)",
    "code_without_comments": "class Node:\n    def __init__(self, x):\n        self.data = x\n        self.next = None\ndef sortedMerge(head1, head2):\n    arr = []\n\n    while head1 is not None:\n        arr.append(head1.data)\n        head1 = head1.next\n\n    while head2 is not None:\n        arr.append(head2.data)\n        head2 = head2.next\n\n    arr.sort()\n\n    dummy = Node(-1)\n    curr = dummy\n    for value in arr:\n        curr.next = Node(value)\n        curr = curr.next\n    return dummy.next\ndef printList(node):\n    while node is not None:\n        print(f\"{node.data}\", end=\"\")\n        if node.next is not None:\n            print(\" -> \", end=\"\")\n        node = node.next\n    print()\nif __name__ == \"__main__\":\n    head1 = Node(5)\n    head1.next = Node(10)\n    head1.next.next = Node(15)\n    head1.next.next.next = Node(40)\n    head2 = Node(2)\n    head2.next = Node(3)\n    head2.next.next = Node(20)\n    res = sortedMerge(head1, head2)\n    printList(res)",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/merge-two-sorted-linked-lists/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\nusing namespace std;\nclass Node {\npublic:\n    int data;\n    Node* next;\n    Node(int x) {\n        data = x;\n        next = nullptr;\n    }\n};\nNode* sortedMerge(Node* head1, Node* head2) {\n    // base cases\n    if (head1 == nullptr)\n        return head2;\n    if (head2 == nullptr)\n        return head1;\n    // recursive merging based on smaller value\n    if (head1->data <= head2->data) {\n        head1->next = sortedMerge(head1->next, head2);\n        return head1;\n    } else {\n        head2->next = sortedMerge(head1, head2->next);\n        return head2;\n    }\n}\nvoid printList(Node* curr) {\n    while (curr != nullptr) {\n        cout << curr->data;\n        if (curr->next != nullptr)\n            cout << \" -> \";\n        curr = curr->next;\n    }\n    cout << endl;\n}\nint main() {\n    Node* head1 = new Node(5);\n    head1->next = new Node(10);\n    head1->next->next = new Node(15);\n    head1->next->next->next = new Node(40);\n    Node* head2 = new Node(2);\n    head2->next = new Node(3);\n    head2->next->next = new Node(20);\n    Node* res = sortedMerge(head1, head2);\n    printList(res);\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\nusing namespace std;\nclass Node {\npublic:\n    int data;\n    Node* next;\n    Node(int x) {\n        data = x;\n        next = nullptr;\n    }\n};\nNode* sortedMerge(Node* head1, Node* head2) {\n\n    if (head1 == nullptr)\n        return head2;\n    if (head2 == nullptr)\n        return head1;\n\n    if (head1->data <= head2->data) {\n        head1->next = sortedMerge(head1->next, head2);\n        return head1;\n    } else {\n        head2->next = sortedMerge(head1, head2->next);\n        return head2;\n    }\n}\nvoid printList(Node* curr) {\n    while (curr != nullptr) {\n        cout << curr->data;\n        if (curr->next != nullptr)\n            cout << \" -> \";\n        curr = curr->next;\n    }\n    cout << endl;\n}\nint main() {\n    Node* head1 = new Node(5);\n    head1->next = new Node(10);\n    head1->next->next = new Node(15);\n    head1->next->next->next = new Node(40);\n    Node* head2 = new Node(2);\n    head2->next = new Node(3);\n    head2->next->next = new Node(20);\n    Node* res = sortedMerge(head1, head2);\n    printList(res);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/merge-two-sorted-linked-lists/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <stdio.h>\n#include <stdlib.h>\nstruct Node {\n    int data;\n    struct Node *next;\n};\nstruct Node *sortedMerge(struct Node *head1, struct Node *head2) {\n    // base cases\n    if (head1 == NULL)\n        return head2;\n    if (head2 == NULL)\n        return head1;\n    // recursive merging based on smaller value\n    if (head1->data <= head2->data) {\n        head1->next = sortedMerge(head1->next, head2);\n        return head1;\n    }\n    else {\n        head2->next = sortedMerge(head1, head2->next);\n        return head2;\n    }\n}\nvoid printList(struct Node *curr) {\n    while (curr != NULL) {\n        printf(\"%d\", curr->data);\n        if (curr->next != NULL) {\n            printf(\" -> \");\n        }\n        curr = curr->next;\n    }\n    printf(\"\\n\");\n}\nstruct Node *createNode(int data) {\n    struct Node *newNode =\n      (struct Node *)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\nint main() {\n    struct Node *head1 = createNode(5);\n    head1->next = createNode(10);\n    head1->next->next = createNode(15);\n    head1->next->next->next = createNode(40);\n    struct Node *head2 = createNode(2);\n    head2->next = createNode(3);\n    head2->next->next = createNode(20);\n    struct Node *res = sortedMerge(head1, head2);\n    printList(res);\n    return 0;\n}",
    "code_without_comments": "#include <stdio.h>\n#include <stdlib.h>\nstruct Node {\n    int data;\n    struct Node *next;\n};\nstruct Node *sortedMerge(struct Node *head1, struct Node *head2) {\n\n    if (head1 == NULL)\n        return head2;\n    if (head2 == NULL)\n        return head1;\n\n    if (head1->data <= head2->data) {\n        head1->next = sortedMerge(head1->next, head2);\n        return head1;\n    }\n    else {\n        head2->next = sortedMerge(head1, head2->next);\n        return head2;\n    }\n}\nvoid printList(struct Node *curr) {\n    while (curr != NULL) {\n        printf(\"%d\", curr->data);\n        if (curr->next != NULL) {\n            printf(\" -> \");\n        }\n        curr = curr->next;\n    }\n    printf(\"\\n\");\n}\nstruct Node *createNode(int data) {\n    struct Node *newNode =\n      (struct Node *)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\nint main() {\n    struct Node *head1 = createNode(5);\n    head1->next = createNode(10);\n    head1->next->next = createNode(15);\n    head1->next->next->next = createNode(40);\n    struct Node *head2 = createNode(2);\n    head2->next = createNode(3);\n    head2->next->next = createNode(20);\n    struct Node *res = sortedMerge(head1, head2);\n    printList(res);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/merge-two-sorted-linked-lists/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "class Node:\n    def __init__(self, x):\n        self.data = x\n        self.next = None\ndef sortedMerge(head1, head2):\n    # base cases\n    if head1 is None:\n        return head2\n    if head2 is None:\n        return head1\n    # recursive merging based on smaller value\n    if head1.data <= head2.data:\n        head1.next = sortedMerge(head1.next, head2)\n        return head1\n    else:\n        head2.next = sortedMerge(head1, head2.next)\n        return head2\ndef printList(node):\n    while node is not None:\n        print(f\"{node.data}\", end=\"\")\n        if node.next is not None:\n            print(\" -> \", end=\"\")\n        node = node.next\n    print()\nif __name__ == \"__main__\":\n    head1 = Node(5)\n    head1.next = Node(10)\n    head1.next.next = Node(15)\n    head1.next.next.next = Node(40)\n    head2 = Node(2)\n    head2.next = Node(3)\n    head2.next.next = Node(20)\n    res = sortedMerge(head1, head2)\n    printList(res)",
    "code_without_comments": "class Node:\n    def __init__(self, x):\n        self.data = x\n        self.next = None\ndef sortedMerge(head1, head2):\n\n    if head1 is None:\n        return head2\n    if head2 is None:\n        return head1\n\n    if head1.data <= head2.data:\n        head1.next = sortedMerge(head1.next, head2)\n        return head1\n    else:\n        head2.next = sortedMerge(head1, head2.next)\n        return head2\ndef printList(node):\n    while node is not None:\n        print(f\"{node.data}\", end=\"\")\n        if node.next is not None:\n            print(\" -> \", end=\"\")\n        node = node.next\n    print()\nif __name__ == \"__main__\":\n    head1 = Node(5)\n    head1.next = Node(10)\n    head1.next.next = Node(15)\n    head1.next.next.next = Node(40)\n    head2 = Node(2)\n    head2.next = Node(3)\n    head2.next.next = Node(20)\n    res = sortedMerge(head1, head2)\n    printList(res)",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/merge-two-sorted-linked-lists/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\nusing namespace std;\nclass Node {\npublic:\n    int data;\n    Node* next;\n    Node(int x) {\n        data = x;\n        next = nullptr;\n    }\n};\nNode* sortedMerge(Node* head1, Node* head2) {\n    // create a dummy node to simplify\n    // the merging process\n    Node* dummy = new Node(-1);\n    Node* curr = dummy;\n    // iterate through both linked lists\n    while (head1 != nullptr && head2 != nullptr) {\n        // add the smaller node to the merged list\n        if (head1->data <= head2->data) {\n            curr->next = head1;\n            head1 = head1->next;\n        } else {\n            curr->next = head2;\n            head2 = head2->next;\n        }\n        curr = curr->next;\n    }\n    // if any list is left, append it to\n    // the merged list\n    if (head1 != nullptr) {\n        curr->next = head1;\n    } else {\n        curr->next = head2;\n    }\n    // return the merged list starting\n    // from the next of dummy node\n    return dummy->next;\n}\nvoid printList(Node* head) {\n    while (head != nullptr) {\n        cout << head->data;\n        if (head->next != nullptr)\n            cout << \" -> \";\n        head = head->next;\n    }\n    cout << endl;\n}\nint main() {\n    Node* head1 = new Node(5);\n    head1->next = new Node(10);\n    head1->next->next = new Node(15);\n    head1->next->next->next = new Node(40);\n    Node* head2 = new Node(2);\n    head2->next = new Node(3);\n    head2->next->next = new Node(20);\n    Node* res = sortedMerge(head1, head2);\n    printList(res);\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\nusing namespace std;\nclass Node {\npublic:\n    int data;\n    Node* next;\n    Node(int x) {\n        data = x;\n        next = nullptr;\n    }\n};\nNode* sortedMerge(Node* head1, Node* head2) {\n\n\n    Node* dummy = new Node(-1);\n    Node* curr = dummy;\n\n    while (head1 != nullptr && head2 != nullptr) {\n\n        if (head1->data <= head2->data) {\n            curr->next = head1;\n            head1 = head1->next;\n        } else {\n            curr->next = head2;\n            head2 = head2->next;\n        }\n        curr = curr->next;\n    }\n\n\n    if (head1 != nullptr) {\n        curr->next = head1;\n    } else {\n        curr->next = head2;\n    }\n\n\n    return dummy->next;\n}\nvoid printList(Node* head) {\n    while (head != nullptr) {\n        cout << head->data;\n        if (head->next != nullptr)\n            cout << \" -> \";\n        head = head->next;\n    }\n    cout << endl;\n}\nint main() {\n    Node* head1 = new Node(5);\n    head1->next = new Node(10);\n    head1->next->next = new Node(15);\n    head1->next->next->next = new Node(40);\n    Node* head2 = new Node(2);\n    head2->next = new Node(3);\n    head2->next->next = new Node(20);\n    Node* res = sortedMerge(head1, head2);\n    printList(res);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/merge-two-sorted-linked-lists/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <stdio.h>\n#include <stdlib.h>\nstruct Node {\n    int data;\n    struct Node* next;\n};\nstruct Node* createNode(int data);\nstruct Node* sortedMerge(struct Node* head1,\n                             struct Node* head2) {\n    // create a dummy node to simplify\n    // the merging process\n    struct Node* dummy = createNode(-1);\n    struct Node* curr = dummy;\n    // iterate through both linked lists\n    while (head1 != NULL && head2 != NULL) {\n        // add the smaller node to the merged list\n        if (head1->data <= head2->data) {\n            curr->next = head1;\n            head1 = head1->next;\n        } else {\n            curr->next = head2;\n            head2 = head2->next;\n        }\n        curr = curr->next;\n    }\n    // if any list is left, append it to\n    // the merged list\n    if (head1 != NULL) {\n        curr->next = head1;\n    } else {\n        curr->next = head2;\n    }\n    // return the merged list starting\n    // from the next of dummy node\n    return dummy->next;\n}\nvoid printList(struct Node* head) {\n    while (head != NULL) {\n        printf(\"%d\", head->data);\n        if (head->next != NULL) {\n            printf(\" -> \");\n        }\n        head = head->next;\n    }\n    printf(\"\\n\");\n}\nstruct Node* createNode(int data) {\n    struct Node* newNode\n      = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\nint main() {\n    struct Node* head1 = createNode(5);\n    head1->next = createNode(10);\n    head1->next->next = createNode(15);\n    head1->next->next->next = createNode(40);\n    struct Node* head2 = createNode(2);\n    head2->next = createNode(3);\n    head2->next->next = createNode(20);\n    struct Node* res = sortedMerge(head1, head2);\n    printList(res);\n    return 0;\n}",
    "code_without_comments": "#include <stdio.h>\n#include <stdlib.h>\nstruct Node {\n    int data;\n    struct Node* next;\n};\nstruct Node* createNode(int data);\nstruct Node* sortedMerge(struct Node* head1,\n                             struct Node* head2) {\n\n\n    struct Node* dummy = createNode(-1);\n    struct Node* curr = dummy;\n\n    while (head1 != NULL && head2 != NULL) {\n\n        if (head1->data <= head2->data) {\n            curr->next = head1;\n            head1 = head1->next;\n        } else {\n            curr->next = head2;\n            head2 = head2->next;\n        }\n        curr = curr->next;\n    }\n\n\n    if (head1 != NULL) {\n        curr->next = head1;\n    } else {\n        curr->next = head2;\n    }\n\n\n    return dummy->next;\n}\nvoid printList(struct Node* head) {\n    while (head != NULL) {\n        printf(\"%d\", head->data);\n        if (head->next != NULL) {\n            printf(\" -> \");\n        }\n        head = head->next;\n    }\n    printf(\"\\n\");\n}\nstruct Node* createNode(int data) {\n    struct Node* newNode\n      = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\nint main() {\n    struct Node* head1 = createNode(5);\n    head1->next = createNode(10);\n    head1->next->next = createNode(15);\n    head1->next->next->next = createNode(40);\n    struct Node* head2 = createNode(2);\n    head2->next = createNode(3);\n    head2->next->next = createNode(20);\n    struct Node* res = sortedMerge(head1, head2);\n    printList(res);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/merge-two-sorted-linked-lists/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "class Node:\n    def __init__(self, x):\n        self.data = x\n        self.next = None\ndef sortedMerge(head1, head2):\n    # create a dummy node to simplify\n    # the merging process\n    dummy = Node(-1)\n    curr = dummy\n    # iterate through both linked lists\n    while head1 is not None and head2 is not None:\n        # add the smaller node to the merged list\n        if head1.data <= head2.data:\n            curr.next = head1\n            head1 = head1.next\n        else:\n            curr.next = head2\n            head2 = head2.next\n        curr = curr.next\n    # if any list is left, append it to the merged list\n    if head1 is not None:\n        curr.next = head1\n    else:\n        curr.next = head2\n    # return the merged list starting from\n    # the next of dummy node\n    return dummy.next\ndef printList(head):\n    while head is not None:\n        if head.next is not None:\n            print(head.data, end=\" -> \")\n        else:\n            print(head.data)\n        head = head.next\nif __name__ == \"__main__\":\n    head1 = Node(5)\n    head1.next = Node(10)\n    head1.next.next = Node(15)\n    head1.next.next.next = Node(40)\n    head2 = Node(2)\n    head2.next = Node(3)\n    head2.next.next = Node(20)\n    res = sortedMerge(head1, head2)\n    printList(res)",
    "code_without_comments": "class Node:\n    def __init__(self, x):\n        self.data = x\n        self.next = None\ndef sortedMerge(head1, head2):\n\n\n    dummy = Node(-1)\n    curr = dummy\n\n    while head1 is not None and head2 is not None:\n\n        if head1.data <= head2.data:\n            curr.next = head1\n            head1 = head1.next\n        else:\n            curr.next = head2\n            head2 = head2.next\n        curr = curr.next\n\n    if head1 is not None:\n        curr.next = head1\n    else:\n        curr.next = head2\n\n\n    return dummy.next\ndef printList(head):\n    while head is not None:\n        if head.next is not None:\n            print(head.data, end=\" -> \")\n        else:\n            print(head.data)\n        head = head.next\nif __name__ == \"__main__\":\n    head1 = Node(5)\n    head1.next = Node(10)\n    head1.next.next = Node(15)\n    head1.next.next.next = Node(40)\n    head2 = Node(2)\n    head2.next = Node(3)\n    head2.next.next = Node(20)\n    res = sortedMerge(head1, head2)\n    printList(res)",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/merge-two-sorted-linked-lists/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "// C++ program for flattening a Linked List\n#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nclass Node {\npublic:\n    int data;\n    Node *next, *bottom;\n    Node(int newdata) {\n        data = newdata;\n        next = bottom = nullptr;\n    }\n};\n// function to flatten the linked list\nNode* flatten(Node* root) {\n    vector<int> values;\n    // Push values of all nodes into an array\n    while (root != nullptr) {\n        // Push the head node of the sub-linked-list\n        values.push_back(root->data);\n        // Push all the nodes of the sub-linked-list\n        Node* temp = root->bottom;\n        while (temp != nullptr) {\n            values.push_back(temp->data);\n            temp = temp->bottom;\n        }\n        // Move to the next head node\n        root = root->next;\n    }\n    // Sort the node values in ascending order\n    sort(values.begin(), values.end());\n    // Construct the new flattened linked list\n    Node* tail = nullptr;\n    Node* head = nullptr;\n    for (int i = 0; i < values.size(); i++) {\n        Node* newNode = new Node(values[i]);\n        // If this is the first node of the linked list,\n        // make the node as head\n        if (head == nullptr) {\n            head = newNode;\n        }\n        else {\n            tail->bottom = newNode;\n        }\n        tail = newNode;\n    }\n    return head;\n}\nvoid printList(Node* head) {\n    Node* temp = head;\n    while (temp != nullptr) {\n        cout << temp->data;\n        if(temp->bottom)\n        cout<<\" -> \";\n        temp = temp->bottom;\n    }\n    cout << endl;\n}\nint main() {\n    // Create a hard-coded linked list:\n    //   5 -> 10 -> 19 -> 28\n    //   |    |     |\n    //   V    V     V\n    //   7    20    22\n    //   |          |\n    //   V          V\n    //   8          50\n    //   |\n    //   V\n    //   30\n    Node* head = new Node(5);\n    head->bottom = new Node(7);\n    head->bottom->bottom = new Node(8);\n    head->bottom->bottom->bottom = new Node(30);\n    head->next = new Node(10);\n    head->next->bottom = new Node(20);\n    head->next->next = new Node(19);\n    head->next->next->bottom = new Node(22);\n    head->next->next->bottom->bottom = new Node(50);\n    head->next->next->next = new Node(28);\n    head = flatten(head);\n    printList(head);\n    return 0;\n}",
    "code_without_comments": "\n#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nclass Node {\npublic:\n    int data;\n    Node *next, *bottom;\n    Node(int newdata) {\n        data = newdata;\n        next = bottom = nullptr;\n    }\n};\n\nNode* flatten(Node* root) {\n    vector<int> values;\n\n    while (root != nullptr) {\n\n        values.push_back(root->data);\n\n        Node* temp = root->bottom;\n        while (temp != nullptr) {\n            values.push_back(temp->data);\n            temp = temp->bottom;\n        }\n\n        root = root->next;\n    }\n\n    sort(values.begin(), values.end());\n\n    Node* tail = nullptr;\n    Node* head = nullptr;\n    for (int i = 0; i < values.size(); i++) {\n        Node* newNode = new Node(values[i]);\n\n\n        if (head == nullptr) {\n            head = newNode;\n        }\n        else {\n            tail->bottom = newNode;\n        }\n        tail = newNode;\n    }\n    return head;\n}\nvoid printList(Node* head) {\n    Node* temp = head;\n    while (temp != nullptr) {\n        cout << temp->data;\n        if(temp->bottom)\n        cout<<\" -> \";\n        temp = temp->bottom;\n    }\n    cout << endl;\n}\nint main() {\n\n\n\n\n\n\n\n\n\n\n\n    Node* head = new Node(5);\n    head->bottom = new Node(7);\n    head->bottom->bottom = new Node(8);\n    head->bottom->bottom->bottom = new Node(30);\n    head->next = new Node(10);\n    head->next->bottom = new Node(20);\n    head->next->next = new Node(19);\n    head->next->next->bottom = new Node(22);\n    head->next->next->bottom->bottom = new Node(50);\n    head->next->next->next = new Node(28);\n    head = flatten(head);\n    printList(head);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/flattening-a-linked-list/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "# Python program for flattening a Linked List\nclass Node:\n    def __init__(self, new_data):\n        self.data = new_data\n        self.next = None\n        self.bottom = None\n# Function to flatten the linked list\ndef flatten(root):\n    values = []\n    # Push values of all nodes into an array\n    while root is not None:\n        # Push the head node of the sub-linked-list\n        values.append(root.data)\n        # Push all the nodes of the sub-linked-list\n        temp = root.bottom\n        while temp is not None:\n            values.append(temp.data)\n            temp = temp.bottom\n        # Move to the next head node\n        root = root.next\n    # Sort the node values in ascending order\n    values.sort()\n    # Construct the new flattened linked list\n    tail = None\n    head = None\n    for value in values:\n        newNode = Node(value)\n        # If this is the first node of the linked list,\n        # make the node as head\n        if head is None:\n            head = newNode\n        else:\n            tail.bottom = newNode\n        tail = newNode\n    return head\ndef printList(node):\n    while node is not None:\n        print(f\"{node.data}\", end=\"\")\n        if node.next is not None:\n            print(\" -> \", end=\"\")\n        node = node.next\n    print()\nif __name__ == \"__main__\":\n    # Create a hard-coded linked list:\n    # 5 -> 10 -> 19 -> 28\n    # |    |     |\n    # V    V     V\n    # 7    20    22\n    # |          |\n    # V          V\n    # 8          50\n    # |\n    # V\n    # 30\n    head = Node(5)\n    head.bottom = Node(7)\n    head.bottom.bottom = Node(8)\n    head.bottom.bottom.bottom = Node(30)\n    head.next = Node(10)\n    head.next.bottom = Node(20)\n    head.next.next = Node(19)\n    head.next.next.bottom = Node(22)\n    head.next.next.bottom.bottom = Node(50)\n    head.next.next.next = Node(28)\n    head = flatten(head)\n    printList(head)",
    "code_without_comments": "\nclass Node:\n    def __init__(self, new_data):\n        self.data = new_data\n        self.next = None\n        self.bottom = None\n\ndef flatten(root):\n    values = []\n\n    while root is not None:\n\n        values.append(root.data)\n\n        temp = root.bottom\n        while temp is not None:\n            values.append(temp.data)\n            temp = temp.bottom\n\n        root = root.next\n\n    values.sort()\n\n    tail = None\n    head = None\n    for value in values:\n        newNode = Node(value)\n\n\n        if head is None:\n            head = newNode\n        else:\n            tail.bottom = newNode\n        tail = newNode\n    return head\ndef printList(node):\n    while node is not None:\n        print(f\"{node.data}\", end=\"\")\n        if node.next is not None:\n            print(\" -> \", end=\"\")\n        node = node.next\n    print()\nif __name__ == \"__main__\":\n\n\n\n\n\n\n\n\n\n\n\n    head = Node(5)\n    head.bottom = Node(7)\n    head.bottom.bottom = Node(8)\n    head.bottom.bottom.bottom = Node(30)\n    head.next = Node(10)\n    head.next.bottom = Node(20)\n    head.next.next = Node(19)\n    head.next.next.bottom = Node(22)\n    head.next.next.bottom.bottom = Node(50)\n    head.next.next.next = Node(28)\n    head = flatten(head)\n    printList(head)",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/flattening-a-linked-list/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "// C++ program for flattening a Linked List\n#include <bits/stdc++.h>\nusing namespace std;\nclass Node {\npublic:\n    int data;\n    Node *next, *bottom;\n    Node(int newdata) {\n        data = newdata;\n        next = bottom = nullptr;\n    }\n};\n// Utility function to merge two sorted linked lists\n// using their bottom pointers\nNode* merge(Node* head1, Node* head2) {\n    // A dummy first node to store the result list\n    Node dummy(-1);\n    // Tail points to the last result node to add new nodes\n    // to the result\n    Node* tail = &dummy;\n    // Iterate till either head1 or head2 does not reach NULL\n    while (head1 && head2) {\n        if (head1->data <= head2->data) {\n            // append head1 to the result\n            tail->bottom = head1;\n            head1 = head1->bottom;\n        }\n        else {\n            // append head2 to the result\n            tail->bottom = head2;\n            head2 = head2->bottom;\n        }\n        // Move tail pointer to the next node\n        tail = tail->bottom;\n    }\n  \t// Append the remaining nodes of non-null linked list\n    if (!head1)\n        tail->bottom = head2;\n    else\n        tail->bottom = head1;\n    return (dummy.bottom);\n}\n// function to flatten the linked list\nNode* flatten(Node* root) {\n    // Base Cases\n    if (root == nullptr || root->next == nullptr)\n        return root;\n    // Recur for next list\n    root->next = flatten(root->next);\n    // Now merge the current and next list\n    root = merge(root, root->next);\n    // Return the root\n    return root;\n}\nvoid printList(Node* head) {\n    Node* temp = head;\n    while (temp != nullptr) {\n        cout << temp->data ;\n        if(temp->bottom)\n        cout<<\" -> \";\n        temp = temp->bottom;\n    }\n    cout << endl;\n}\nint main() {\n    /* Create a hard-coded linked list:\n        5 -> 10 -> 19 -> 28\n        |    |     |\n        V    V     V\n        7    20    22\n        |          |\n        V          V\n        8          50\n        |\n        V\n        30\n    */\n    Node* head = new Node(5);\n    head->bottom = new Node(7);\n    head->bottom->bottom = new Node(8);\n    head->bottom->bottom->bottom = new Node(30);\n    head->next = new Node(10);\n    head->next->bottom = new Node(20);\n    head->next->next = new Node(19);\n    head->next->next->bottom = new Node(22);\n    head->next->next->bottom->bottom = new Node(50);\n    head->next->next->next = new Node(28);\n    head = flatten(head);\n    printList(head);\n    return 0;\n}",
    "code_without_comments": "\n#include <bits/stdc++.h>\nusing namespace std;\nclass Node {\npublic:\n    int data;\n    Node *next, *bottom;\n    Node(int newdata) {\n        data = newdata;\n        next = bottom = nullptr;\n    }\n};\n\n\nNode* merge(Node* head1, Node* head2) {\n\n    Node dummy(-1);\n\n\n    Node* tail = &dummy;\n\n    while (head1 && head2) {\n        if (head1->data <= head2->data) {\n\n            tail->bottom = head1;\n            head1 = head1->bottom;\n        }\n        else {\n\n            tail->bottom = head2;\n            head2 = head2->bottom;\n        }\n\n        tail = tail->bottom;\n    }\n\n    if (!head1)\n        tail->bottom = head2;\n    else\n        tail->bottom = head1;\n    return (dummy.bottom);\n}\n\nNode* flatten(Node* root) {\n\n    if (root == nullptr || root->next == nullptr)\n        return root;\n\n    root->next = flatten(root->next);\n\n    root = merge(root, root->next);\n\n    return root;\n}\nvoid printList(Node* head) {\n    Node* temp = head;\n    while (temp != nullptr) {\n        cout << temp->data ;\n        if(temp->bottom)\n        cout<<\" -> \";\n        temp = temp->bottom;\n    }\n    cout << endl;\n}\nint main() {\n\n    Node* head = new Node(5);\n    head->bottom = new Node(7);\n    head->bottom->bottom = new Node(8);\n    head->bottom->bottom->bottom = new Node(30);\n    head->next = new Node(10);\n    head->next->bottom = new Node(20);\n    head->next->next = new Node(19);\n    head->next->next->bottom = new Node(22);\n    head->next->next->bottom->bottom = new Node(50);\n    head->next->next->next = new Node(28);\n    head = flatten(head);\n    printList(head);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/flattening-a-linked-list/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "// C program for flattening a Linked List\n#include <stdio.h>\nstruct Node {\n    int data;\n    struct Node *next, *bottom;\n};\n// Utility function to merge two sorted linked lists using\n// their bottom pointers\nstruct Node* merge(struct Node* head1, struct Node* head2) {\n    // A dummy first node to store the result list\n    struct Node dummy;\n    dummy.data = -1;\n    dummy.bottom = NULL;\n    // Tail points to the last result node to add new nodes\n    // to the result\n    struct Node* tail = &dummy;\n    // Iterate till either head1 or head2 does not reach\n    // NULL\n    while (head1 && head2) {\n        if (head1->data <= head2->data) {\n            // append head1 to the result\n            tail->bottom = head1;\n            head1 = head1->bottom;\n        }\n        else {\n            // append head2 to the result\n            tail->bottom = head2;\n            head2 = head2->bottom;\n        }\n        // Move tail pointer to the next node\n        tail = tail->bottom;\n    }\n\t// Append the remaining nodes of non-null linked list\n    if (!head1)\n        tail->bottom = head2;\n    else\n        tail->bottom = head1;\n    return dummy.bottom;\n}\n// Function to flatten the linked list\nstruct Node* flatten(struct Node* root) {\n    // Base Cases\n    if (root == NULL || root->next == NULL)\n        return root;\n    // Recur for next list\n    root->next = flatten(root->next);\n    // Now merge the current and next list\n    root = merge(root, root->next);\n    // Return the root\n    return root;\n}\nvoid printList(struct Node* head) {\n    struct Node* temp = head;\n    while (temp != NULL) {\n        printf(\"%d\", temp->data);\n        if(temp->bottom)\n        printf(\" -> \");\n        temp = temp->bottom;\n    }\n    printf(\"\\n\");\n}\n// Function to create a new node\nstruct Node* createNode(int newdata) {\n    struct Node* newnode\n        = (struct Node*)malloc(sizeof(struct Node));\n    newnode->data = newdata;\n    newnode->next = NULL;\n  \tnewnode->bottom = NULL;\n    return newnode;\n}\nint main() {\n    /* Create a hard-coded linked list:\n        5 -> 10 -> 19 -> 28\n        |    |     |\n        V    V     V\n        7    20    22\n        |          |\n        V          V\n        8          50\n        |\n        V\n        30\n    */\n    struct Node* head = createNode(5);\n    head->bottom = createNode(7);\n    head->bottom->bottom = createNode(8);\n    head->bottom->bottom->bottom = createNode(30);\n    head->next = createNode(10);\n    head->next->bottom = createNode(20);\n    head->next->next = createNode(19);\n    head->next->next->bottom = createNode(22);\n    head->next->next->bottom->bottom = createNode(50);\n    head->next->next->next = createNode(28);\n    head = flatten(head);\n    printList(head);\n    return 0;\n}",
    "code_without_comments": "\n#include <stdio.h>\nstruct Node {\n    int data;\n    struct Node *next, *bottom;\n};\n\n\nstruct Node* merge(struct Node* head1, struct Node* head2) {\n\n    struct Node dummy;\n    dummy.data = -1;\n    dummy.bottom = NULL;\n\n\n    struct Node* tail = &dummy;\n\n\n    while (head1 && head2) {\n        if (head1->data <= head2->data) {\n\n            tail->bottom = head1;\n            head1 = head1->bottom;\n        }\n        else {\n\n            tail->bottom = head2;\n            head2 = head2->bottom;\n        }\n\n        tail = tail->bottom;\n    }\n\n    if (!head1)\n        tail->bottom = head2;\n    else\n        tail->bottom = head1;\n    return dummy.bottom;\n}\n\nstruct Node* flatten(struct Node* root) {\n\n    if (root == NULL || root->next == NULL)\n        return root;\n\n    root->next = flatten(root->next);\n\n    root = merge(root, root->next);\n\n    return root;\n}\nvoid printList(struct Node* head) {\n    struct Node* temp = head;\n    while (temp != NULL) {\n        printf(\"%d\", temp->data);\n        if(temp->bottom)\n        printf(\" -> \");\n        temp = temp->bottom;\n    }\n    printf(\"\\n\");\n}\n\nstruct Node* createNode(int newdata) {\n    struct Node* newnode\n        = (struct Node*)malloc(sizeof(struct Node));\n    newnode->data = newdata;\n    newnode->next = NULL;\n  \tnewnode->bottom = NULL;\n    return newnode;\n}\nint main() {\n\n    struct Node* head = createNode(5);\n    head->bottom = createNode(7);\n    head->bottom->bottom = createNode(8);\n    head->bottom->bottom->bottom = createNode(30);\n    head->next = createNode(10);\n    head->next->bottom = createNode(20);\n    head->next->next = createNode(19);\n    head->next->next->bottom = createNode(22);\n    head->next->next->bottom->bottom = createNode(50);\n    head->next->next->next = createNode(28);\n    head = flatten(head);\n    printList(head);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/flattening-a-linked-list/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "// Java program for flattening a Linked List\nclass Node {\n    int data;\n    Node next, bottom;\n    Node(int newData) {\n        data = newData;\n        next = bottom = null;\n    }\n}\nclass GfG {\n    // Utility function to merge two sorted linked lists\n    // using their bottom pointers\n    static Node merge(Node head1, Node head2) {\n        // A dummy first node to store the result list\n        Node dummy = new Node(-1);\n        // Tail points to the last result node to add new\n        // nodes to the result\n        Node tail = dummy;\n        // Iterate till either head1 or head2 does not reach\n        // null\n        while (head1 != null && head2 != null) {\n            if (head1.data <= head2.data) {\n                // Append head1 to the result\n                tail.bottom = head1;\n                head1 = head1.bottom;\n            }\n            else {\n                // Append head2 to the result\n                tail.bottom = head2;\n                head2 = head2.bottom;\n            }\n            // Move tail pointer to the next node\n            tail = tail.bottom;\n        }\n        // Append the remaining nodes of the non-null list\n        if (head1 != null)\n            tail.bottom = head1;\n        else\n            tail.bottom = head2;\n        return dummy.bottom;\n    }\n    // Function to flatten the linked list\n    static Node flatten(Node root) {\n        // Base Cases\n        if (root == null || root.next == null)\n            return root;\n        // Recur for next list\n        root.next = flatten(root.next);\n        // Now merge the current and next list\n        root = merge(root, root.next);\n        // Return the root\n        return root;\n    }\n    static void printList(Node head) {\n        Node temp = head;\n        while (temp != null) {\n            System.out.print(temp.data);\n            if(temp.bottom!=null)\n            {\n                System.out.print(\" -> \");\n            }\n            temp = temp.bottom;\n        }\n        System.out.println();\n    }\n    public static void main(String[] args) {\n        /* Create a hard-coded linked list:\n            5 -> 10 -> 19 -> 28\n            |    |     |\n            V    V     V\n            7    20    22\n            |          |\n            V          V\n            8          50\n            |\n            V\n            30\n        */\n        Node head = new Node(5);\n        head.bottom = new Node(7);\n        head.bottom.bottom = new Node(8);\n        head.bottom.bottom.bottom = new Node(30);\n        head.next = new Node(10);\n        head.next.bottom = new Node(20);\n        head.next.next = new Node(19);\n        head.next.next.bottom = new Node(22);\n        head.next.next.bottom.bottom = new Node(50);\n        head.next.next.next = new Node(28);\n        head = flatten(head);\n        printList(head);\n    }\n}",
    "code_without_comments": "// Java program for flattening a Linked List\nclass Node {\n    int data;\n    Node next, bottom;\n    Node(int newData) {\n        data = newData;\n        next = bottom = null;\n    }\n}\nclass GfG {\n    // Utility function to merge two sorted linked lists\n    // using their bottom pointers\n    static Node merge(Node head1, Node head2) {\n        // A dummy first node to store the result list\n        Node dummy = new Node(-1);\n        // Tail points to the last result node to add new\n        // nodes to the result\n        Node tail = dummy;\n        // Iterate till either head1 or head2 does not reach\n        // null\n        while (head1 != null && head2 != null) {\n            if (head1.data <= head2.data) {\n                // Append head1 to the result\n                tail.bottom = head1;\n                head1 = head1.bottom;\n            }\n            else {\n                // Append head2 to the result\n                tail.bottom = head2;\n                head2 = head2.bottom;\n            }\n            // Move tail pointer to the next node\n            tail = tail.bottom;\n        }\n        // Append the remaining nodes of the non-null list\n        if (head1 != null)\n            tail.bottom = head1;\n        else\n            tail.bottom = head2;\n        return dummy.bottom;\n    }\n    // Function to flatten the linked list\n    static Node flatten(Node root) {\n        // Base Cases\n        if (root == null || root.next == null)\n            return root;\n        // Recur for next list\n        root.next = flatten(root.next);\n        // Now merge the current and next list\n        root = merge(root, root.next);\n        // Return the root\n        return root;\n    }\n    static void printList(Node head) {\n        Node temp = head;\n        while (temp != null) {\n            System.out.print(temp.data);\n            if(temp.bottom!=null)\n            {\n                System.out.print(\" -> \");\n            }\n            temp = temp.bottom;\n        }\n        System.out.println();\n    }\n    public static void main(String[] args) {\n        /* Create a hard-coded linked list:\n            5 -> 10 -> 19 -> 28\n            |    |     |\n            V    V     V\n            7    20    22\n            |          |\n            V          V\n            8          50\n            |\n            V\n            30\n        */\n        Node head = new Node(5);\n        head.bottom = new Node(7);\n        head.bottom.bottom = new Node(8);\n        head.bottom.bottom.bottom = new Node(30);\n        head.next = new Node(10);\n        head.next.bottom = new Node(20);\n        head.next.next = new Node(19);\n        head.next.next.bottom = new Node(22);\n        head.next.next.bottom.bottom = new Node(50);\n        head.next.next.next = new Node(28);\n        head = flatten(head);\n        printList(head);\n    }\n}",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/flattening-a-linked-list/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "# Python3 program for flattening a Linked List\nclass Node:\n    def __init__(self, new_data):\n        self.data = new_data\n        self.next = None\n        self.bottom = None\n# Utility function to merge two sorted linked lists\n# using their bottom pointers\ndef merge(head1, head2):\n    # A dummy first node to store the result list\n    dummy = Node(-1)\n    tail = dummy\n    # Iterate till either head1 or head2 does not reach None\n    while head1 and head2:\n        if head1.data <= head2.data:\n            # Append head1 to the result\n            tail.bottom = head1\n            head1 = head1.bottom\n        else:\n            # Append head2 to the result\n            tail.bottom = head2\n            head2 = head2.bottom\n        # Move tail pointer to the next node\n        tail = tail.bottom\n    # Append the remaining nodes of the non-null linked list\n    if head1:\n        tail.bottom = head1\n    else:\n        tail.bottom = head2\n    return dummy.bottom\n# Function to flatten the linked list\ndef flatten(root):\n    # Base Cases\n    if root is None or root.next is None:\n        return root\n    # Recur for next list\n    root.next = flatten(root.next)\n    # Now merge the current and next list\n    root = merge(root, root.next)\n    # Return the root\n    return root\ndef printList(node):\n    while node is not None:\n        print(f\"{node.data}\", end=\"\")\n        if node.bottom is not None:\n            print(\" -> \", end=\"\")\n        node = node.bottom\n    print()\nif __name__ == \"__main__\":\n    # Create a hard-coded linked list:\n    #     5 -> 10 -> 19 -> 28\n    #     |    |     |\n    #     V    V     V\n    #     7    20    22\n    #     |          |\n    #     V          V\n    #     8          50\n    #     |\n    #     V\n    #     30\n    head = Node(5)\n    head.bottom = Node(7)\n    head.bottom.bottom = Node(8)\n    head.bottom.bottom.bottom = Node(30)\n    head.next = Node(10)\n    head.next.bottom = Node(20)\n    head.next.next = Node(19)\n    head.next.next.bottom = Node(22)\n    head.next.next.bottom.bottom = Node(50)\n    head.next.next.next = Node(28)\n    head = flatten(head)\n    printList(head)",
    "code_without_comments": "\nclass Node:\n    def __init__(self, new_data):\n        self.data = new_data\n        self.next = None\n        self.bottom = None\n\n\ndef merge(head1, head2):\n\n    dummy = Node(-1)\n    tail = dummy\n\n    while head1 and head2:\n        if head1.data <= head2.data:\n\n            tail.bottom = head1\n            head1 = head1.bottom\n        else:\n\n            tail.bottom = head2\n            head2 = head2.bottom\n\n        tail = tail.bottom\n\n    if head1:\n        tail.bottom = head1\n    else:\n        tail.bottom = head2\n    return dummy.bottom\n\ndef flatten(root):\n\n    if root is None or root.next is None:\n        return root\n\n    root.next = flatten(root.next)\n\n    root = merge(root, root.next)\n\n    return root\ndef printList(node):\n    while node is not None:\n        print(f\"{node.data}\", end=\"\")\n        if node.bottom is not None:\n            print(\" -> \", end=\"\")\n        node = node.bottom\n    print()\nif __name__ == \"__main__\":\n\n\n\n\n\n\n\n\n\n\n\n    head = Node(5)\n    head.bottom = Node(7)\n    head.bottom.bottom = Node(8)\n    head.bottom.bottom.bottom = Node(30)\n    head.next = Node(10)\n    head.next.bottom = Node(20)\n    head.next.next = Node(19)\n    head.next.next.bottom = Node(22)\n    head.next.next.bottom.bottom = Node(50)\n    head.next.next.next = Node(28)\n    head = flatten(head)\n    printList(head)",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/flattening-a-linked-list/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <bits/stdc++.h>\nusing namespace std;\nclass Node {\npublic:\n    int data;\n    Node *next, *bottom;\n    Node(int newdata) {\n        data = newdata;\n        next = bottom = nullptr;\n    }\n};\n// comparator function for priority queue\nstruct mycomp {\n    bool operator()(Node* a, Node* b) {\n        return a->data > b->data;\n    }\n};\n// function to flatten the given linked list\nNode* flatten(Node* root) {\n    priority_queue<Node*, vector<Node*>, mycomp> pq;\n    Node* head = nullptr;\n    Node* tail = nullptr;\n    // pushing main link nodes into priority_queue\n    while (root != nullptr) {\n        pq.push(root);\n        root = root->next;\n    }\n    // Extracting the minimum node\n    // while priority queue is not empty\n    while (!pq.empty()) {\n        // extracting min\n        auto minNode = pq.top();\n        pq.pop();\n        if (head == nullptr) {\n            head = minNode;\n            tail = minNode;\n        }\n        else {\n            tail->bottom = minNode;\n            tail = tail->bottom;\n        }\n        // If we have another node at the bottom of the\n        // popped node, push that node into the priority\n        // queue\n        if (minNode->bottom) {\n            pq.push(minNode->bottom);\n            minNode->bottom = nullptr;\n        }\n    }\n  \treturn head;\n}\nvoid printList(Node* head) {\n    Node* temp = head;\n    while (temp != nullptr) {\n        cout << temp->data ;\n        if(temp->bottom)\n        cout<<\" -> \";\n        temp = temp->bottom;\n    }\n    cout << endl;\n}\nint main() {\n    /* Create a hard-coded linked list:\n        5 -> 10 -> 19 -> 28\n        |    |     |\n        V    V     V\n        7    20    22\n        |          |\n        V          V\n        8          50\n        |\n        V\n        30\n    */\n    Node* head = new Node(5);\n    head->bottom = new Node(7);\n    head->bottom->bottom = new Node(8);\n    head->bottom->bottom->bottom = new Node(30);\n    head->next = new Node(10);\n    head->next->bottom = new Node(20);\n    head->next->next = new Node(19);\n    head->next->next->bottom = new Node(22);\n    head->next->next->bottom->bottom = new Node(50);\n    head->next->next->next = new Node(28);\n    head = flatten(head);\n    printList(head);\n    return 0;\n}",
    "code_without_comments": "#include <bits/stdc++.h>\nusing namespace std;\nclass Node {\npublic:\n    int data;\n    Node *next, *bottom;\n    Node(int newdata) {\n        data = newdata;\n        next = bottom = nullptr;\n    }\n};\n\nstruct mycomp {\n    bool operator()(Node* a, Node* b) {\n        return a->data > b->data;\n    }\n};\n\nNode* flatten(Node* root) {\n    priority_queue<Node*, vector<Node*>, mycomp> pq;\n    Node* head = nullptr;\n    Node* tail = nullptr;\n\n    while (root != nullptr) {\n        pq.push(root);\n        root = root->next;\n    }\n\n\n    while (!pq.empty()) {\n\n        auto minNode = pq.top();\n        pq.pop();\n        if (head == nullptr) {\n            head = minNode;\n            tail = minNode;\n        }\n        else {\n            tail->bottom = minNode;\n            tail = tail->bottom;\n        }\n\n\n\n        if (minNode->bottom) {\n            pq.push(minNode->bottom);\n            minNode->bottom = nullptr;\n        }\n    }\n  \treturn head;\n}\nvoid printList(Node* head) {\n    Node* temp = head;\n    while (temp != nullptr) {\n        cout << temp->data ;\n        if(temp->bottom)\n        cout<<\" -> \";\n        temp = temp->bottom;\n    }\n    cout << endl;\n}\nint main() {\n\n    Node* head = new Node(5);\n    head->bottom = new Node(7);\n    head->bottom->bottom = new Node(8);\n    head->bottom->bottom->bottom = new Node(30);\n    head->next = new Node(10);\n    head->next->bottom = new Node(20);\n    head->next->next = new Node(19);\n    head->next->next->bottom = new Node(22);\n    head->next->next->bottom->bottom = new Node(50);\n    head->next->next->next = new Node(28);\n    head = flatten(head);\n    printList(head);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/flattening-a-linked-list/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "// Java program for flattening a Linked List\nimport java.util.PriorityQueue;\nclass Node {\n    int data;\n    Node next, bottom;\n    Node(int newData) {\n        data = newData;\n        next = bottom = null;\n    }\n}\n// Comparator class for the priority queue\nclass NodeComparator implements java.util.Comparator<Node> {\n    @Override\n    public int compare(Node a, Node b) {\n        return Integer.compare(a.data, b.data);\n    }\n}\n// Function to flatten the linked list\nclass GfG {\n    static Node flatten(Node root) {\n        // Create a priority queue with custom comparator\n        PriorityQueue<Node> pq = new PriorityQueue<>(new NodeComparator());\n        Node head = null;\n        Node tail = null;\n        // Pushing main link nodes into the priority_queue.\n        while (root != null) {\n            pq.add(root);\n            root = root.next;\n        }\n        // Extracting the minimum node while the priority\n      \t// queue is not empty\n        while (!pq.isEmpty()) {\n            // Extracting min\n            Node minNode = pq.poll();\n            if (head == null) {\n                head = minNode;\n                tail = minNode;\n            } else {\n                tail.bottom = minNode;\n                tail = tail.bottom;\n            }\n            // If we have another node at the bottom of the\n            // popped node, push that node into the priority queue\n            if (minNode.bottom != null) {\n                pq.add(minNode.bottom);\n                minNode.bottom = null;\n            }\n        }\n        return head;\n    }\n    // Function to print the linked list\n    static void printList(Node head) {\n        Node temp = head;\n        while (temp != null) {\n            System.out.print(temp.data);\n            if(temp.bottom!=null)\n            {\n                System.out.print(\" -> \");\n            }\n            temp = temp.bottom;\n        }\n        System.out.println();\n    }\n    public static void main(String[] args) {\n        /* Create a hard-coded linked list:\n            5 -> 10 -> 19 -> 28\n            |    |     |\n            V    V     V\n            7    20    22\n            |          |\n            V          V\n            8          50\n            |\n            V\n            30\n        */\n        Node head = new Node(5);\n        head.bottom = new Node(7);\n        head.bottom.bottom = new Node(8);\n        head.bottom.bottom.bottom = new Node(30);\n        head.next = new Node(10);\n        head.next.bottom = new Node(20);\n        head.next.next = new Node(19);\n        head.next.next.bottom = new Node(22);\n        head.next.next.bottom.bottom = new Node(50);\n        head.next.next.next = new Node(28);\n        head = flatten(head);\n        printList(head);\n    }\n}",
    "code_without_comments": "// Java program for flattening a Linked List\nimport java.util.PriorityQueue;\nclass Node {\n    int data;\n    Node next, bottom;\n    Node(int newData) {\n        data = newData;\n        next = bottom = null;\n    }\n}\n// Comparator class for the priority queue\nclass NodeComparator implements java.util.Comparator<Node> {\n    @Override\n    public int compare(Node a, Node b) {\n        return Integer.compare(a.data, b.data);\n    }\n}\n// Function to flatten the linked list\nclass GfG {\n    static Node flatten(Node root) {\n        // Create a priority queue with custom comparator\n        PriorityQueue<Node> pq = new PriorityQueue<>(new NodeComparator());\n        Node head = null;\n        Node tail = null;\n        // Pushing main link nodes into the priority_queue.\n        while (root != null) {\n            pq.add(root);\n            root = root.next;\n        }\n        // Extracting the minimum node while the priority\n      \t// queue is not empty\n        while (!pq.isEmpty()) {\n            // Extracting min\n            Node minNode = pq.poll();\n            if (head == null) {\n                head = minNode;\n                tail = minNode;\n            } else {\n                tail.bottom = minNode;\n                tail = tail.bottom;\n            }\n            // If we have another node at the bottom of the\n            // popped node, push that node into the priority queue\n            if (minNode.bottom != null) {\n                pq.add(minNode.bottom);\n                minNode.bottom = null;\n            }\n        }\n        return head;\n    }\n    // Function to print the linked list\n    static void printList(Node head) {\n        Node temp = head;\n        while (temp != null) {\n            System.out.print(temp.data);\n            if(temp.bottom!=null)\n            {\n                System.out.print(\" -> \");\n            }\n            temp = temp.bottom;\n        }\n        System.out.println();\n    }\n    public static void main(String[] args) {\n        /* Create a hard-coded linked list:\n            5 -> 10 -> 19 -> 28\n            |    |     |\n            V    V     V\n            7    20    22\n            |          |\n            V          V\n            8          50\n            |\n            V\n            30\n        */\n        Node head = new Node(5);\n        head.bottom = new Node(7);\n        head.bottom.bottom = new Node(8);\n        head.bottom.bottom.bottom = new Node(30);\n        head.next = new Node(10);\n        head.next.bottom = new Node(20);\n        head.next.next = new Node(19);\n        head.next.next.bottom = new Node(22);\n        head.next.next.bottom.bottom = new Node(50);\n        head.next.next.next = new Node(28);\n        head = flatten(head);\n        printList(head);\n    }\n}",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/flattening-a-linked-list/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "# Python program for flattening a Linked List\nfrom heapq import heappush, heappop\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = self.bottom = None\n# Utility function to insert a node at beginning\n# of the linked list\ndef push(head, data):\n    # 1 & 2: Allocate the Node & Put in the data\n    newNode = Node(data)\n    # Make next of newNode as head\n    newNode.bottom = head\n    # Move the head to point to newNode\n    head = newNode\n    # Return to link it back\n    return head\ndef printList(node):\n    while node is not None:\n        print(f\"{node.data}\", end=\"\")\n        if node.bottom is not None:\n            print(\" -> \", end=\"\")\n        node = node.bottom\n    print()\n# Class to compare two node objects\nclass Cmp:\n    def __init__(self, node):\n        self.node = node\n    def __lt__(self, other):\n        return self.node.data < other.node.data\ndef flatten(root):\n    pq = []\n    head = None\n    tail = None\n    # Pushing main link nodes into priority_queue\n    while root:\n        heappush(pq, Cmp(root))\n        root = root.next\n    # Extracting the minimum node while the priority\n    # queue is not empty\n    while pq:\n        minNode = heappop(pq).node\n        if head is None:\n            head = minNode\n            tail = minNode\n        else:\n            tail.bottom = minNode\n            tail = tail.bottom\n        # If we have another node at the bottom of the popped\n        # node, push that node into the priority queue\n        if minNode.bottom:\n            heappush(pq, Cmp(minNode.bottom))\n            minNode.bottom = None\n    return head\nif __name__ == '__main__':\n    head = Node(5)\n    head.bottom = Node(7)\n    head.bottom.bottom = Node(8)\n    head.bottom.bottom.bottom = Node(30)\n    head.next = Node(10)\n    head.next.bottom = Node(20)\n    head.next.next = Node(19)\n    head.next.next.bottom = Node(22)\n    head.next.next.bottom.bottom = Node(50)\n    head.next.next.next = Node(28)\n    head = flatten(head)\n    printList(head)",
    "code_without_comments": "\nfrom heapq import heappush, heappop\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = self.bottom = None\n\n\ndef push(head, data):\n\n    newNode = Node(data)\n\n    newNode.bottom = head\n\n    head = newNode\n\n    return head\ndef printList(node):\n    while node is not None:\n        print(f\"{node.data}\", end=\"\")\n        if node.bottom is not None:\n            print(\" -> \", end=\"\")\n        node = node.bottom\n    print()\n\nclass Cmp:\n    def __init__(self, node):\n        self.node = node\n    def __lt__(self, other):\n        return self.node.data < other.node.data\ndef flatten(root):\n    pq = []\n    head = None\n    tail = None\n\n    while root:\n        heappush(pq, Cmp(root))\n        root = root.next\n\n\n    while pq:\n        minNode = heappop(pq).node\n        if head is None:\n            head = minNode\n            tail = minNode\n        else:\n            tail.bottom = minNode\n            tail = tail.bottom\n\n\n        if minNode.bottom:\n            heappush(pq, Cmp(minNode.bottom))\n            minNode.bottom = None\n    return head\nif __name__ == '__main__':\n    head = Node(5)\n    head.bottom = Node(7)\n    head.bottom.bottom = Node(8)\n    head.bottom.bottom.bottom = Node(30)\n    head.next = Node(10)\n    head.next.bottom = Node(20)\n    head.next.next = Node(19)\n    head.next.next.bottom = Node(22)\n    head.next.next.bottom.bottom = Node(50)\n    head.next.next.next = Node(28)\n    head = flatten(head)\n    printList(head)",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/flattening-a-linked-list/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\nusing namespace std;\nclass Node {\n  public:\n    int data;\n    Node *next;\n    Node(int val) {\n        data = val;\n        next = nullptr;\n    }\n};\n// Function to reverse the linked list\nNode *reverse(Node *head) {\n    Node *prev = nullptr, *curr = head, *next;\n    while (curr != nullptr) {\n        next = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = next;\n    }\n    return prev;\n}\n// Function to trim leading zeros in linked list\nNode *trimLeadingZeros(Node* head) {\n\twhile(head->next != nullptr && head->data == 0)\n    \thead = head->next;\n\treturn head;\n}\n// Function to add two numbers represented by linked list\nNode *addTwoLists(Node *num1, Node *num2) {\n    Node *res = nullptr, *curr = nullptr;\n    int carry = 0;\n\tnum1 = trimLeadingZeros(num1);\n\tnum2 = trimLeadingZeros(num2);\n    num1 = reverse(num1);\n    num2 = reverse(num2);\n    // Iterate till either num1 is not empty or num2 is\n    // not empty or carry is greater than 0\n    while (num1 != nullptr || num2 != nullptr || carry != 0) {\n        int sum = carry;\n        if (num1 != nullptr) {\n            sum += num1->data;\n            num1 = num1->next;\n        }\n        if (num2 != nullptr) {\n            sum += num2->data;\n            num2 = num2->next;\n        }\n        Node* newNode = new Node(sum % 10);\n        carry = sum / 10;\n      \t// If this is the first node, then make this node\n      \t// as the head of the resultant linked list\n      \tif(res == nullptr) {\n        \tres = newNode;\n          \tcurr = newNode;\n        }\n      \telse {\n          \t// Append new node to resultant linked list\n          \t// and move to the next node\n        \tcurr->next = newNode;\n        \tcurr = curr->next;\n        }\n    }\n    return reverse(res);\n}\nvoid printList(Node *head) {\n    Node *curr = head;\n    while (curr != nullptr) {\n        cout << curr->data;\n        if(curr->next != NULL){\n            cout << \" -> \";\n        }\n        curr = curr->next;\n    }\n    cout << \"\\n\";\n}\nint main() {\n    Node *num1 = new Node(1);\n    num1->next = new Node(2);\n    num1->next->next = new Node(3);\n    Node *num2 = new Node(9);\n    num2->next = new Node(9);\n    num2->next->next = new Node(9);\n    Node *sum = addTwoLists(num1, num2);\n    printList(sum);\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\nusing namespace std;\nclass Node {\n  public:\n    int data;\n    Node *next;\n    Node(int val) {\n        data = val;\n        next = nullptr;\n    }\n};\n\nNode *reverse(Node *head) {\n    Node *prev = nullptr, *curr = head, *next;\n    while (curr != nullptr) {\n        next = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = next;\n    }\n    return prev;\n}\n\nNode *trimLeadingZeros(Node* head) {\n\twhile(head->next != nullptr && head->data == 0)\n    \thead = head->next;\n\treturn head;\n}\n\nNode *addTwoLists(Node *num1, Node *num2) {\n    Node *res = nullptr, *curr = nullptr;\n    int carry = 0;\n\tnum1 = trimLeadingZeros(num1);\n\tnum2 = trimLeadingZeros(num2);\n    num1 = reverse(num1);\n    num2 = reverse(num2);\n\n\n    while (num1 != nullptr || num2 != nullptr || carry != 0) {\n        int sum = carry;\n        if (num1 != nullptr) {\n            sum += num1->data;\n            num1 = num1->next;\n        }\n        if (num2 != nullptr) {\n            sum += num2->data;\n            num2 = num2->next;\n        }\n        Node* newNode = new Node(sum % 10);\n        carry = sum / 10;\n\n\n      \tif(res == nullptr) {\n        \tres = newNode;\n          \tcurr = newNode;\n        }\n      \telse {\n\n\n        \tcurr->next = newNode;\n        \tcurr = curr->next;\n        }\n    }\n    return reverse(res);\n}\nvoid printList(Node *head) {\n    Node *curr = head;\n    while (curr != nullptr) {\n        cout << curr->data;\n        if(curr->next != NULL){\n            cout << \" -> \";\n        }\n        curr = curr->next;\n    }\n    cout << \"\\n\";\n}\nint main() {\n    Node *num1 = new Node(1);\n    num1->next = new Node(2);\n    num1->next->next = new Node(3);\n    Node *num2 = new Node(9);\n    num2->next = new Node(9);\n    num2->next->next = new Node(9);\n    Node *sum = addTwoLists(num1, num2);\n    printList(sum);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/add-two-numbers-represented-by-linked-lists/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <stdio.h>\nstruct Node {\n    int data;\n    struct Node *next;\n};\nstruct Node *createNode(int val);\n// Function to reverse the linked list\nstruct Node *reverse(struct Node *head) {\n    struct Node *prev = NULL, *curr = head, *next;\n    while (curr != NULL) {\n        next = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = next;\n    }\n    return prev;\n}\n// Function to trim leading zeros in linked list\nstruct Node* trimLeadingZeros(struct Node* head) {\n    while (head->next != NULL && head->data == 0)\n        head = head->next;\n    return head;\n}\n// Function to add two numbers represented by linked list\nstruct Node *addTwoLists(struct Node *num1, struct Node *num2) {\n    struct Node *res = NULL, *curr = NULL;\n    int carry = 0;\n\tnum1 = trimLeadingZeros(num1);\n\tnum2 = trimLeadingZeros(num2);\n    num1 = reverse(num1);\n    num2 = reverse(num2);\n    // Iterate till either num1 is not empty or num2 is\n    // not empty or carry is greater than 0\n    while (num1 != NULL || num2 != NULL || carry != 0) {\n        int sum = carry;\n        if (num1 != NULL) {\n            sum += num1->data;\n            num1 = num1->next;\n        }\n        if (num2 != NULL) {\n            sum += num2->data;\n            num2 = num2->next;\n        }\n        struct Node* newNode = createNode(sum % 10);\n        carry = sum / 10;\n        // If this is the first node, then make this node\n        // as the head of the resultant linked list\n        if (res == NULL) {\n            res = newNode;\n            curr = newNode;\n        }\n      \telse {\n          \t// Append new node to resultant linked list\n            // and move to the next node\n            curr->next = newNode;\n            curr = curr->next;\n        }\n    }\n    return reverse(res);\n}\nvoid printList(struct Node *head) {\n    struct Node *curr = head;\n    while (curr != NULL) {\n        printf(\"%d\", curr->data);\n        if(curr->next != NULL){\n            printf(\" -> \");\n        }\n        curr = curr->next;\n    }\n    printf(\"\\n\");\n}\nstruct Node *createNode(int val) {\n    struct Node *node =\n      \t\t(struct Node *)malloc(sizeof(struct Node));\n    node->data = val;\n    node->next = NULL;\n    return node;\n}\nint main() {\n    struct Node *num1 = createNode(1);\n    num1->next = createNode(2);\n    num1->next->next = createNode(3);\n    struct Node *num2 = createNode(9);\n    num2->next = createNode(9);\n    num2->next->next = createNode(9);\n    struct Node *sum = addTwoLists(num1, num2);\n    printList(sum);\n    return 0;\n}",
    "code_without_comments": "#include <stdio.h>\nstruct Node {\n    int data;\n    struct Node *next;\n};\nstruct Node *createNode(int val);\n\nstruct Node *reverse(struct Node *head) {\n    struct Node *prev = NULL, *curr = head, *next;\n    while (curr != NULL) {\n        next = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = next;\n    }\n    return prev;\n}\n\nstruct Node* trimLeadingZeros(struct Node* head) {\n    while (head->next != NULL && head->data == 0)\n        head = head->next;\n    return head;\n}\n\nstruct Node *addTwoLists(struct Node *num1, struct Node *num2) {\n    struct Node *res = NULL, *curr = NULL;\n    int carry = 0;\n\tnum1 = trimLeadingZeros(num1);\n\tnum2 = trimLeadingZeros(num2);\n    num1 = reverse(num1);\n    num2 = reverse(num2);\n\n\n    while (num1 != NULL || num2 != NULL || carry != 0) {\n        int sum = carry;\n        if (num1 != NULL) {\n            sum += num1->data;\n            num1 = num1->next;\n        }\n        if (num2 != NULL) {\n            sum += num2->data;\n            num2 = num2->next;\n        }\n        struct Node* newNode = createNode(sum % 10);\n        carry = sum / 10;\n\n\n        if (res == NULL) {\n            res = newNode;\n            curr = newNode;\n        }\n      \telse {\n\n\n            curr->next = newNode;\n            curr = curr->next;\n        }\n    }\n    return reverse(res);\n}\nvoid printList(struct Node *head) {\n    struct Node *curr = head;\n    while (curr != NULL) {\n        printf(\"%d\", curr->data);\n        if(curr->next != NULL){\n            printf(\" -> \");\n        }\n        curr = curr->next;\n    }\n    printf(\"\\n\");\n}\nstruct Node *createNode(int val) {\n    struct Node *node =\n      \t\t(struct Node *)malloc(sizeof(struct Node));\n    node->data = val;\n    node->next = NULL;\n    return node;\n}\nint main() {\n    struct Node *num1 = createNode(1);\n    num1->next = createNode(2);\n    num1->next->next = createNode(3);\n    struct Node *num2 = createNode(9);\n    num2->next = createNode(9);\n    num2->next->next = createNode(9);\n    struct Node *sum = addTwoLists(num1, num2);\n    printList(sum);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/add-two-numbers-represented-by-linked-lists/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "class Node:\n    def __init__(self, val):\n        self.data = val\n        self.next = None\n# function to reverse the linked list\ndef reverse(head):\n    prev = None\n    curr = head\n    while curr is not None:\n        nextNode = curr.next\n        curr.next = prev\n        prev = curr\n        curr = nextNode\n    return prev\n# function to trim leading zeros in linked list\ndef trimLeadingZeros(head):\n    while head and head.data == 0:\n        head = head.next\n    return head\n# Function to add two numbers represented by linked list\ndef addTwoLists(num1, num2):\n    res = None\n    curr = None\n    carry = 0\n    num1 = trimLeadingZeros(num1)\n    num2 = trimLeadingZeros(num2)\n    num1 = reverse(num1)\n    num2 = reverse(num2)\n    # Iterate till either num1 is not empty or num2 is\n    # not empty or carry is greater than 0\n    while num1 is not None or num2 is not None or carry != 0:\n        sumValue = carry\n        if num1 is not None:\n            sumValue += num1.data\n            num1 = num1.next\n        if num2 is not None:\n            sumValue += num2.data\n            num2 = num2.next\n        newNode = Node(sumValue % 10)\n        carry = sumValue // 10\n        # If this is the first node, then make this node\n        # as the head of the resultant linked list\n        if res is None:\n            res = newNode\n            curr = newNode\n        else:\n            # Append new node to resultant linked list\n            # and move to the next node\n            curr.next = newNode\n            curr = curr.next\n    return reverse(res)\ndef printList(head):\n    curr = head\n    while curr is not None:\n        print(curr.data, end=\"\")\n        if curr.next != None:\n            print(\" -> \", end=\"\")\n        curr = curr.next\n    print()\nif __name__ == \"__main__\":\n    num1 = Node(1)\n    num1.next = Node(2)\n    num1.next.next = Node(3)\n    num2 = Node(9)\n    num2.next = Node(9)\n    num2.next.next = Node(9)\n    sumList = addTwoLists(num1, num2)\n    printList(sumList)",
    "code_without_comments": "class Node:\n    def __init__(self, val):\n        self.data = val\n        self.next = None\n\ndef reverse(head):\n    prev = None\n    curr = head\n    while curr is not None:\n        nextNode = curr.next\n        curr.next = prev\n        prev = curr\n        curr = nextNode\n    return prev\n\ndef trimLeadingZeros(head):\n    while head and head.data == 0:\n        head = head.next\n    return head\n\ndef addTwoLists(num1, num2):\n    res = None\n    curr = None\n    carry = 0\n    num1 = trimLeadingZeros(num1)\n    num2 = trimLeadingZeros(num2)\n    num1 = reverse(num1)\n    num2 = reverse(num2)\n\n\n    while num1 is not None or num2 is not None or carry != 0:\n        sumValue = carry\n        if num1 is not None:\n            sumValue += num1.data\n            num1 = num1.next\n        if num2 is not None:\n            sumValue += num2.data\n            num2 = num2.next\n        newNode = Node(sumValue % 10)\n        carry = sumValue // 10\n\n\n        if res is None:\n            res = newNode\n            curr = newNode\n        else:\n\n\n            curr.next = newNode\n            curr = curr.next\n    return reverse(res)\ndef printList(head):\n    curr = head\n    while curr is not None:\n        print(curr.data, end=\"\")\n        if curr.next != None:\n            print(\" -> \", end=\"\")\n        curr = curr.next\n    print()\nif __name__ == \"__main__\":\n    num1 = Node(1)\n    num1.next = Node(2)\n    num1.next.next = Node(3)\n    num2 = Node(9)\n    num2.next = Node(9)\n    num2.next.next = Node(9)\n    sumList = addTwoLists(num1, num2)\n    printList(sumList)",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/add-two-numbers-represented-by-linked-lists/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\nusing namespace std;\nclass Node {\n  public:\n    int data;\n    Node *next;\n    Node(int val) {\n        data = val;\n        next = nullptr;\n    }\n};\n// Function to reverse a linked list\nNode* reverse(Node* head) {\n    Node *prev = nullptr, *curr = head, *next;\n    while (curr != nullptr) {\n        next = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = next;\n    }\n    return prev;\n}\nNode* addTwoLists(Node* head1, Node* head2) {\n    // Reverse both lists to start from least significant digit\n    head1 = reverse(head1);\n    head2 = reverse(head2);\n    Node* sum = NULL;\n    int carry = 0;\n    // Traverse both lists until all digits and carry are processed\n    while (head1 != NULL || head2 != NULL || carry != 0) {\n        int newVal = carry;\n        if (head1) {\n            newVal += head1->data;\n            head1 = head1->next;\n        }\n        if (head2) {\n            newVal += head2->data;\n            head2 = head2->next;\n        }\n        carry = newVal / 10;\n        newVal %= 10;\n        // Insert the new digit at the front of the result list\n        Node* newNode = new Node(newVal);\n        newNode->next = sum;\n        sum = newNode;\n    }\n    // Remove leading zeros, if any\n    while (sum != NULL && sum->data == 0) {\n        Node* temp = sum;\n        sum = sum->next;\n        delete temp;\n    }\n    // If result is empty, return single node with 0\n    if (sum == NULL) {\n        return new Node(0);\n    }\n    return sum;\n}\nvoid printList(Node *head) {\n    Node *curr = head;\n    while (curr != nullptr) {\n        cout << curr->data;\n        if(curr->next != NULL){\n            cout << \" -> \";\n        }\n        curr = curr->next;\n    }\n    cout << \"\\n\";\n}\nint main() {\n    Node *num1 = new Node(1);\n    num1->next = new Node(2);\n    num1->next->next = new Node(3);\n    Node *num2 = new Node(9);\n    num2->next = new Node(9);\n    num2->next->next = new Node(9);\n    Node *sum = addTwoLists(num1, num2);\n    printList(sum);\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\nusing namespace std;\nclass Node {\n  public:\n    int data;\n    Node *next;\n    Node(int val) {\n        data = val;\n        next = nullptr;\n    }\n};\n\nNode* reverse(Node* head) {\n    Node *prev = nullptr, *curr = head, *next;\n    while (curr != nullptr) {\n        next = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = next;\n    }\n    return prev;\n}\nNode* addTwoLists(Node* head1, Node* head2) {\n\n    head1 = reverse(head1);\n    head2 = reverse(head2);\n    Node* sum = NULL;\n    int carry = 0;\n\n    while (head1 != NULL || head2 != NULL || carry != 0) {\n        int newVal = carry;\n        if (head1) {\n            newVal += head1->data;\n            head1 = head1->next;\n        }\n        if (head2) {\n            newVal += head2->data;\n            head2 = head2->next;\n        }\n        carry = newVal / 10;\n        newVal %= 10;\n\n        Node* newNode = new Node(newVal);\n        newNode->next = sum;\n        sum = newNode;\n    }\n\n    while (sum != NULL && sum->data == 0) {\n        Node* temp = sum;\n        sum = sum->next;\n        delete temp;\n    }\n\n    if (sum == NULL) {\n        return new Node(0);\n    }\n    return sum;\n}\nvoid printList(Node *head) {\n    Node *curr = head;\n    while (curr != nullptr) {\n        cout << curr->data;\n        if(curr->next != NULL){\n            cout << \" -> \";\n        }\n        curr = curr->next;\n    }\n    cout << \"\\n\";\n}\nint main() {\n    Node *num1 = new Node(1);\n    num1->next = new Node(2);\n    num1->next->next = new Node(3);\n    Node *num2 = new Node(9);\n    num2->next = new Node(9);\n    num2->next->next = new Node(9);\n    Node *sum = addTwoLists(num1, num2);\n    printList(sum);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/add-two-numbers-represented-by-linked-lists/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <stdio.h>\nstruct Node {\n    int data;\n    struct Node *next;\n};\nstruct Node *createNode(int val);\n// Function to create a new node\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->next = NULL;\n    return node;\n}\n// Function to reverse a linked list\nstruct Node* reverse(struct Node* head) {\n    struct Node *prev = NULL, *curr = head, *next;\n    while (curr != NULL) {\n        next = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = next;\n    }\n    return prev;\n}\n// Function to add two linked lists\nstruct Node* addTwoLists(struct Node* head1, struct Node* head2) {\n    // Reverse both lists to start\n    // from least significant digit\n    head1 = reverse(head1);\n    head2 = reverse(head2);\n    struct Node* sum = NULL;\n    int carry = 0;\n    // Traverse both lists until all\n    // digits and carry are processed\n    while (head1 != NULL || head2 != NULL || carry != 0) {\n        int newVal = carry;\n        if (head1) {\n            newVal += head1->data;\n            head1 = head1->next;\n        }\n        if (head2) {\n            newVal += head2->data;\n            head2 = head2->next;\n        }\n        carry = newVal / 10;\n        newVal %= 10;\n        // Insert the new digit at the front of the result list\n        struct Node* node = newNode(newVal);\n        node->next = sum;\n        sum = node;\n    }\n    // Remove leading zeros, if any\n    while (sum != NULL && sum->data == 0) {\n        struct Node* temp = sum;\n        sum = sum->next;\n        free(temp);\n    }\n    // If result is empty, return single node with 0\n    if (sum == NULL) {\n        return newNode(0);\n    }\n    return sum;\n}\nvoid printList(struct Node *head) {\n    struct Node *curr = head;\n    while (curr != NULL) {\n        printf(\"%d\", curr->data);\n        if(curr->next != NULL)\n            printf(\" -> \");\n        curr = curr->next;\n    }\n    printf(\"\\n\");\n}\nstruct Node *createNode(int val) {\n    struct Node *node =\n      \t\t(struct Node *)malloc(sizeof(struct Node));\n    node->data = val;\n    node->next = NULL;\n    return node;\n}\nint main() {\n    struct Node *num1 = createNode(1);\n    num1->next = createNode(2);\n    num1->next->next = createNode(3);\n    struct Node *num2 = createNode(9);\n    num2->next = createNode(9);\n    num2->next->next = createNode(9);\n    struct Node *sum = addTwoLists(num1, num2);\n    printList(sum);\n    return 0;\n}",
    "code_without_comments": "#include <stdio.h>\nstruct Node {\n    int data;\n    struct Node *next;\n};\nstruct Node *createNode(int val);\n\nstruct Node* newNode(int data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->next = NULL;\n    return node;\n}\n\nstruct Node* reverse(struct Node* head) {\n    struct Node *prev = NULL, *curr = head, *next;\n    while (curr != NULL) {\n        next = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = next;\n    }\n    return prev;\n}\n\nstruct Node* addTwoLists(struct Node* head1, struct Node* head2) {\n\n\n    head1 = reverse(head1);\n    head2 = reverse(head2);\n    struct Node* sum = NULL;\n    int carry = 0;\n\n\n    while (head1 != NULL || head2 != NULL || carry != 0) {\n        int newVal = carry;\n        if (head1) {\n            newVal += head1->data;\n            head1 = head1->next;\n        }\n        if (head2) {\n            newVal += head2->data;\n            head2 = head2->next;\n        }\n        carry = newVal / 10;\n        newVal %= 10;\n\n        struct Node* node = newNode(newVal);\n        node->next = sum;\n        sum = node;\n    }\n\n    while (sum != NULL && sum->data == 0) {\n        struct Node* temp = sum;\n        sum = sum->next;\n        free(temp);\n    }\n\n    if (sum == NULL) {\n        return newNode(0);\n    }\n    return sum;\n}\nvoid printList(struct Node *head) {\n    struct Node *curr = head;\n    while (curr != NULL) {\n        printf(\"%d\", curr->data);\n        if(curr->next != NULL)\n            printf(\" -> \");\n        curr = curr->next;\n    }\n    printf(\"\\n\");\n}\nstruct Node *createNode(int val) {\n    struct Node *node =\n      \t\t(struct Node *)malloc(sizeof(struct Node));\n    node->data = val;\n    node->next = NULL;\n    return node;\n}\nint main() {\n    struct Node *num1 = createNode(1);\n    num1->next = createNode(2);\n    num1->next->next = createNode(3);\n    struct Node *num2 = createNode(9);\n    num2->next = createNode(9);\n    num2->next->next = createNode(9);\n    struct Node *sum = addTwoLists(num1, num2);\n    printList(sum);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/add-two-numbers-represented-by-linked-lists/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "class Node:\n    def __init__(self, val):\n        self.data = val\n        self.next = None\n# Function to reverse the linked list\ndef reverse(head):\n    prev = None\n    current = head\n    while current is not None:\n        next = current.next\n        current.next = prev\n        prev = current\n        current = next\n    return prev\ndef addTwoLists(head1, head2):\n    # Reverse both lists to simplify addition\n    head1 = reverse(head1)\n    head2 = reverse(head2)\n    sumList = None\n    carry = 0\n    # Loop until both lists and carry are exhausted\n    while head1 is not None or head2 is not None or carry > 0:\n        newVal = carry\n        if head1 is not None:\n            newVal += head1.data\n            head1 = head1.next\n        if head2 is not None:\n            newVal += head2.data\n            head2 = head2.next\n        carry = newVal // 10\n        newVal = newVal % 10\n        # Create a new node and link it at the front\n        newNode = Node(newVal)\n        newNode.next = sumList\n        sumList = newNode\n    # Return the final sum list\n    return sumList\ndef printList(head):\n    curr = head\n    while curr is not None:\n        print(curr.data, end=\"\")\n        if curr.next is not None:\n            print(\" -> \", end=\"\")\n        curr = curr.next\n    print()\nif __name__ == \"__main__\":\n    num1 = Node(1)\n    num1.next = Node(2)\n    num1.next.next = Node(3)\n    num2 = Node(9)\n    num2.next = Node(9)\n    num2.next.next = Node(9)\n    sumList = addTwoLists(num1, num2)\n    printList(sumList)",
    "code_without_comments": "class Node:\n    def __init__(self, val):\n        self.data = val\n        self.next = None\n\ndef reverse(head):\n    prev = None\n    current = head\n    while current is not None:\n        next = current.next\n        current.next = prev\n        prev = current\n        current = next\n    return prev\ndef addTwoLists(head1, head2):\n\n    head1 = reverse(head1)\n    head2 = reverse(head2)\n    sumList = None\n    carry = 0\n\n    while head1 is not None or head2 is not None or carry > 0:\n        newVal = carry\n        if head1 is not None:\n            newVal += head1.data\n            head1 = head1.next\n        if head2 is not None:\n            newVal += head2.data\n            head2 = head2.next\n        carry = newVal // 10\n        newVal = newVal % 10\n\n        newNode = Node(newVal)\n        newNode.next = sumList\n        sumList = newNode\n\n    return sumList\ndef printList(head):\n    curr = head\n    while curr is not None:\n        print(curr.data, end=\"\")\n        if curr.next is not None:\n            print(\" -> \", end=\"\")\n        curr = curr.next\n    print()\nif __name__ == \"__main__\":\n    num1 = Node(1)\n    num1.next = Node(2)\n    num1.next.next = Node(3)\n    num2 = Node(9)\n    num2.next = Node(9)\n    num2.next.next = Node(9)\n    sumList = addTwoLists(num1, num2)\n    printList(sumList)",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/add-two-numbers-represented-by-linked-lists/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "// C++ program to delete nth node from last\n#include <iostream>\nusing namespace std;\nclass Node {\npublic:\n    int data;\n    Node* next;\n    Node(int new_data) {\n        data = new_data;\n        next = nullptr;\n    }\n};\n// Function to remove the Nth node from the end\nNode* removeNthFromEnd(Node* head, int N) {\n    // Calculate the length of the linked list\n    int length = 0;\n    Node* curr = head;\n    while (curr != nullptr) {\n        length++;\n        curr = curr->next;\n    }\n    // Calculate the position to remove from front\n    int target = length - N + 1;\n    // If target is 1, remove the head node\n    if (target == 1) {\n        Node* newHead = head->next;\n        // Free memory of the removed node\n        delete head;\n        return newHead;\n    }\n    // Traverse to the node just before the target\n    curr = head;\n    for (int i = 1; i < target - 1; i++) {\n        curr = curr->next;\n    }\n    // Remove the target node\n    Node* nodeToDelete = curr->next;\n    curr->next = curr->next->next;\n    delete nodeToDelete;\n    return head;\n}\nvoid printList(Node* node) {\n    Node* curr = node;\n    while (curr != nullptr) {\n        cout << \" \" << curr->data;\n        curr = curr->next;\n    }\n}\nint main() {\n    // Create a hard-coded linked list:\n    // 1 -> 2 -> 3 -> 4 -> 5\n    Node* head = new Node(1);\n    head->next = new Node(2);\n    head->next->next = new Node(3);\n    head->next->next->next = new Node(4);\n    head->next->next->next->next = new Node(5);\n    int N = 2;\n    head = removeNthFromEnd(head, N);\n    printList(head);\n    return 0;\n}",
    "code_without_comments": "\n#include <iostream>\nusing namespace std;\nclass Node {\npublic:\n    int data;\n    Node* next;\n    Node(int new_data) {\n        data = new_data;\n        next = nullptr;\n    }\n};\n\nNode* removeNthFromEnd(Node* head, int N) {\n\n    int length = 0;\n    Node* curr = head;\n    while (curr != nullptr) {\n        length++;\n        curr = curr->next;\n    }\n\n    int target = length - N + 1;\n\n    if (target == 1) {\n        Node* newHead = head->next;\n\n        delete head;\n        return newHead;\n    }\n\n    curr = head;\n    for (int i = 1; i < target - 1; i++) {\n        curr = curr->next;\n    }\n\n    Node* nodeToDelete = curr->next;\n    curr->next = curr->next->next;\n    delete nodeToDelete;\n    return head;\n}\nvoid printList(Node* node) {\n    Node* curr = node;\n    while (curr != nullptr) {\n        cout << \" \" << curr->data;\n        curr = curr->next;\n    }\n}\nint main() {\n\n\n    Node* head = new Node(1);\n    head->next = new Node(2);\n    head->next->next = new Node(3);\n    head->next->next->next = new Node(4);\n    head->next->next->next->next = new Node(5);\n    int N = 2;\n    head = removeNthFromEnd(head, N);\n    printList(head);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/remove-nth-node-from-end-of-the-linked-list/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "// C program to delete nth node from last\n#include <stdio.h>\n#include <stdlib.h>\nstruct Node {\n    int data;\n    struct Node* next;\n};\n// Function to remove the Nth node from the end\nstruct Node* removeNthFromEnd(struct Node* head, int N) {\n    // Calculate the length of the linked list\n    int length = 0;\n    struct Node* curr = head;\n    while (curr != NULL) {\n        length++;\n        curr = curr->next;\n    }\n    // Calculate the position to remove from front\n    int target = length - N + 1;\n    // If target is 1, remove the head node\n    if (target == 1) {\n        struct Node* newHead = head->next;\n        // Free memory of the removed node\n        free(head);\n        return newHead;\n    }\n    // Traverse to the node just before the target\n    curr = head;\n    for (int i = 1; i < target - 1; i++) {\n        curr = curr->next;\n    }\n    // Remove the target node\n    struct Node* nodeToDelete = curr->next;\n    curr->next = curr->next->next;\n    // Free memory of the removed node\n    free(nodeToDelete);\n    return head;\n}\nvoid printList(struct Node* node) {\n    struct Node* curr = node;\n    while (curr != NULL) {\n        printf(\" %d\", curr->data);\n        curr = curr->next;\n    }\n}\nstruct Node* createNode(int new_data) {\n    struct Node* new_node\n        = (struct Node*)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->next = NULL;\n    return new_node;\n}\nint main() {\n    // Create a hard-coded linked list:\n    // 1 -> 2 -> 3 -> 4 -> 5\n    struct Node* head = createNode(1);\n    head->next = createNode(2);\n    head->next->next = createNode(3);\n    head->next->next->next = createNode(4);\n    head->next->next->next->next = createNode(5);\n    int N = 2;\n    head = removeNthFromEnd(head, N);\n    printList(head);\n    return 0;\n}",
    "code_without_comments": "\n#include <stdio.h>\n#include <stdlib.h>\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Node* removeNthFromEnd(struct Node* head, int N) {\n\n    int length = 0;\n    struct Node* curr = head;\n    while (curr != NULL) {\n        length++;\n        curr = curr->next;\n    }\n\n    int target = length - N + 1;\n\n    if (target == 1) {\n        struct Node* newHead = head->next;\n\n        free(head);\n        return newHead;\n    }\n\n    curr = head;\n    for (int i = 1; i < target - 1; i++) {\n        curr = curr->next;\n    }\n\n    struct Node* nodeToDelete = curr->next;\n    curr->next = curr->next->next;\n\n    free(nodeToDelete);\n    return head;\n}\nvoid printList(struct Node* node) {\n    struct Node* curr = node;\n    while (curr != NULL) {\n        printf(\" %d\", curr->data);\n        curr = curr->next;\n    }\n}\nstruct Node* createNode(int new_data) {\n    struct Node* new_node\n        = (struct Node*)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->next = NULL;\n    return new_node;\n}\nint main() {\n\n\n    struct Node* head = createNode(1);\n    head->next = createNode(2);\n    head->next->next = createNode(3);\n    head->next->next->next = createNode(4);\n    head->next->next->next->next = createNode(5);\n    int N = 2;\n    head = removeNthFromEnd(head, N);\n    printList(head);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/remove-nth-node-from-end-of-the-linked-list/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "# Python3 program to delete nth node from last\nclass Node:\n    def __init__(self, new_data):\n        self.data = new_data\n        self.next = None\n# Given the head of a list, remove the Nth node from the end\ndef remove_nth_from_end(head, N):\n    # Calculate the length of the linked list\n    length = 0\n    curr = head\n    while curr is not None:\n        length += 1\n        curr = curr.next\n    # Calculate the position to remove from the front\n    target = length - N + 1\n    # If target is 1, remove the head node\n    if target == 1:\n        return head.next\n    # Traverse to the node just before the target node\n    curr = head\n    for _ in range(target - 2):\n        curr = curr.next\n    # Remove the target node\n    curr.next = curr.next.next\n    return head\ndef print_list(node):\n    curr = node;\n    while curr is not None:\n        print(f\" {curr.data}\", end=\"\")\n        curr = curr.next\n    print()\nif __name__ == \"__main__\":\n    # Create a hard-coded linked list:\n    # 1 -> 2 -> 3 -> 4 -> 5\n    head = Node(1)\n    head.next = Node(2)\n    head.next.next = Node(3)\n    head.next.next.next = Node(4)\n    head.next.next.next.next = Node(5)\n    N = 2\n    head = remove_nth_from_end(head, N)\n    print_list(head)",
    "code_without_comments": "\nclass Node:\n    def __init__(self, new_data):\n        self.data = new_data\n        self.next = None\n\ndef remove_nth_from_end(head, N):\n\n    length = 0\n    curr = head\n    while curr is not None:\n        length += 1\n        curr = curr.next\n\n    target = length - N + 1\n\n    if target == 1:\n        return head.next\n\n    curr = head\n    for _ in range(target - 2):\n        curr = curr.next\n\n    curr.next = curr.next.next\n    return head\ndef print_list(node):\n    curr = node;\n    while curr is not None:\n        print(f\" {curr.data}\", end=\"\")\n        curr = curr.next\n    print()\nif __name__ == \"__main__\":\n\n\n    head = Node(1)\n    head.next = Node(2)\n    head.next.next = Node(3)\n    head.next.next.next = Node(4)\n    head.next.next.next.next = Node(5)\n    N = 2\n    head = remove_nth_from_end(head, N)\n    print_list(head)",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/remove-nth-node-from-end-of-the-linked-list/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "// C++ program to delete nth node from last\n#include <iostream>\nusing namespace std;\nclass Node {\npublic:\n    int data;\n    Node* next;\n    Node(int new_data) {\n        data = new_data;\n        next = nullptr;\n    }\n};\n// Function to remove the Nth node from the end\nNode* removeNthFromEnd(Node* head, int N) {\n    // Initialize two pointers, fast and slow\n    Node* fast = head;\n    Node* slow = head;\n    // Move fast pointer N steps ahead\n    for (int i = 0; i < N; i++) {\n        if (fast == nullptr) return head;\n        fast = fast->next;\n    }\n    // If fast is null, remove the head node\n    if (fast == nullptr) {\n        Node* newHead = head->next;\n        delete head;\n        return newHead;\n    }\n    // Move both pointers until fast reaches the end\n    while (fast->next != nullptr) {\n        fast = fast->next;\n        slow = slow->next;\n    }\n    // Remove the Nth node from the end\n    Node* nodeToDelete = slow->next;\n    slow->next = slow->next->next;\n    delete nodeToDelete;\n    return head;\n}\nvoid printList(Node* node) {\n    Node* curr = node;\n    while (curr != nullptr) {\n        cout << \" \" << curr->data;\n        curr = curr->next;\n    }\n}\nint main() {\n    // Create a hard-coded linked list:\n    // 1 -> 2 -> 3 -> 4 -> 5\n    Node* head = new Node(1);\n    head->next = new Node(2);\n    head->next->next = new Node(3);\n    head->next->next->next = new Node(4);\n    head->next->next->next->next = new Node(5);\n    int N = 2;\n    head = removeNthFromEnd(head, N);\n    printList(head);\n    return 0;\n}",
    "code_without_comments": "\n#include <iostream>\nusing namespace std;\nclass Node {\npublic:\n    int data;\n    Node* next;\n    Node(int new_data) {\n        data = new_data;\n        next = nullptr;\n    }\n};\n\nNode* removeNthFromEnd(Node* head, int N) {\n\n    Node* fast = head;\n    Node* slow = head;\n\n    for (int i = 0; i < N; i++) {\n        if (fast == nullptr) return head;\n        fast = fast->next;\n    }\n\n    if (fast == nullptr) {\n        Node* newHead = head->next;\n        delete head;\n        return newHead;\n    }\n\n    while (fast->next != nullptr) {\n        fast = fast->next;\n        slow = slow->next;\n    }\n\n    Node* nodeToDelete = slow->next;\n    slow->next = slow->next->next;\n    delete nodeToDelete;\n    return head;\n}\nvoid printList(Node* node) {\n    Node* curr = node;\n    while (curr != nullptr) {\n        cout << \" \" << curr->data;\n        curr = curr->next;\n    }\n}\nint main() {\n\n\n    Node* head = new Node(1);\n    head->next = new Node(2);\n    head->next->next = new Node(3);\n    head->next->next->next = new Node(4);\n    head->next->next->next->next = new Node(5);\n    int N = 2;\n    head = removeNthFromEnd(head, N);\n    printList(head);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/remove-nth-node-from-end-of-the-linked-list/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "// C program to delete nth node from last\n#include <stdio.h>\n#include <stdlib.h>\nstruct Node {\n    int data;\n    struct Node* next;\n};\n// Function to remove the Nth node from the end\nstruct Node* removeNthFromEnd(struct Node* head, int N) {\n    // Initialize two pointers, fast and slow\n    struct Node* fast = head;\n    struct Node* slow = head;\n    // Move fast pointer N steps ahead\n    for (int i = 0; i < N; i++) {\n        if (fast == NULL) return head;\n        fast = fast->next;\n    }\n    // If fast is NULL, remove the head node\n    if (fast == NULL) {\n        struct Node* newHead = head->next;\n        free(head);\n        return newHead;\n    }\n    // Move both pointers until fast reaches the end\n    while (fast->next != NULL) {\n        fast = fast->next;\n        slow = slow->next;\n    }\n    // Remove the Nth node from the end\n    struct Node* nodeToDelete = slow->next;\n    slow->next = slow->next->next;\n    free(nodeToDelete);\n    return head;\n}\nvoid printList(struct Node* node) {\n    struct Node* curr = node;\n    while (curr != NULL) {\n        printf(\" %d\", curr->data);\n        curr = curr->next;\n    }\n}\nstruct Node* createNode(int new_data) {\n    struct Node* new_node\n        = (struct Node*)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->next = NULL;\n    return new_node;\n}\nint main() {\n    // Create a hard-coded linked list:\n    // 1 -> 2 -> 3 -> 4 -> 5\n    struct Node* head = createNode(1);\n    head->next = createNode(2);\n    head->next->next = createNode(3);\n    head->next->next->next = createNode(4);\n    head->next->next->next->next = createNode(5);\n    int N = 2;\n    head = removeNthFromEnd(head, N);\n    printList(head);\n    return 0;\n}",
    "code_without_comments": "\n#include <stdio.h>\n#include <stdlib.h>\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Node* removeNthFromEnd(struct Node* head, int N) {\n\n    struct Node* fast = head;\n    struct Node* slow = head;\n\n    for (int i = 0; i < N; i++) {\n        if (fast == NULL) return head;\n        fast = fast->next;\n    }\n\n    if (fast == NULL) {\n        struct Node* newHead = head->next;\n        free(head);\n        return newHead;\n    }\n\n    while (fast->next != NULL) {\n        fast = fast->next;\n        slow = slow->next;\n    }\n\n    struct Node* nodeToDelete = slow->next;\n    slow->next = slow->next->next;\n    free(nodeToDelete);\n    return head;\n}\nvoid printList(struct Node* node) {\n    struct Node* curr = node;\n    while (curr != NULL) {\n        printf(\" %d\", curr->data);\n        curr = curr->next;\n    }\n}\nstruct Node* createNode(int new_data) {\n    struct Node* new_node\n        = (struct Node*)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->next = NULL;\n    return new_node;\n}\nint main() {\n\n\n    struct Node* head = createNode(1);\n    head->next = createNode(2);\n    head->next->next = createNode(3);\n    head->next->next->next = createNode(4);\n    head->next->next->next->next = createNode(5);\n    int N = 2;\n    head = removeNthFromEnd(head, N);\n    printList(head);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/remove-nth-node-from-end-of-the-linked-list/",
    "complexity_weight": 1.0
  }
]