[
  {
    "code_with_comments": "# Python3 program to delete nth node from last\nclass Node:\n    def __init__(self, new_data):\n        self.data = new_data\n        self.next = None\n# Given the head of a list, remove the Nth node from the end\ndef remove_nth_from_end(head, N):\n    # Initialize two pointers, fast and slow\n    fast = head\n    slow = head\n    # Move fast pointer N steps ahead\n    for _ in range(N):\n        if fast is None:\n            return head\n        fast = fast.next\n    # If fast is None, remove the head node\n    if fast is None:\n        return head.next\n    # Move both pointers until fast reaches the end\n    while fast.next is not None:\n        fast = fast.next\n        slow = slow.next\n    # Remove the Nth node from the end\n    slow.next = slow.next.next\n    return head\ndef print_list(node):\n    curr = node;\n    while curr is not None:\n        print(f\" {curr.data}\", end=\"\")\n        curr = curr.next\n    print()\nif __name__ == \"__main__\":\n    # Create a hard-coded linked list:\n    # 1 -> 2 -> 3 -> 4 -> 5\n    head = Node(1)\n    head.next = Node(2)\n    head.next.next = Node(3)\n    head.next.next.next = Node(4)\n    head.next.next.next.next = Node(5)\n    N = 2\n    head = remove_nth_from_end(head, N)\n    print_list(head)",
    "code_without_comments": "\nclass Node:\n    def __init__(self, new_data):\n        self.data = new_data\n        self.next = None\n\ndef remove_nth_from_end(head, N):\n\n    fast = head\n    slow = head\n\n    for _ in range(N):\n        if fast is None:\n            return head\n        fast = fast.next\n\n    if fast is None:\n        return head.next\n\n    while fast.next is not None:\n        fast = fast.next\n        slow = slow.next\n\n    slow.next = slow.next.next\n    return head\ndef print_list(node):\n    curr = node;\n    while curr is not None:\n        print(f\" {curr.data}\", end=\"\")\n        curr = curr.next\n    print()\nif __name__ == \"__main__\":\n\n\n    head = Node(1)\n    head.next = Node(2)\n    head.next.next = Node(3)\n    head.next.next.next = Node(4)\n    head.next.next.next.next = Node(5)\n    N = 2\n    head = remove_nth_from_end(head, N)\n    print_list(head)",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/remove-nth-node-from-end-of-the-linked-list/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "// C++ code to Clone a linked list with next and random\n// pointer by Inserting Nodes In-place\n#include <bits/stdc++.h>\nusing namespace std;\nstruct Node {\n    int data;\n    Node *next, *random;\n    Node(int x) {\n        data = x;\n        next = random = NULL;\n    }\n};\nNode* cloneLinkedList(Node* head) {\n    if (head == NULL) {\n        return NULL;\n    }\n    // Create new nodes and insert them next to\n      // the original nodes\n    Node* curr = head;\n    while (curr != NULL) {\n        Node* newNode = new Node(curr->data);\n        newNode->next = curr->next;\n        curr->next = newNode;\n        curr = newNode->next;\n    }\n    // Set the random pointers of the new nodes\n    curr = head;\n    while (curr != NULL) {\n        if (curr->random != NULL)\n            curr->next->random = curr->random->next;\n        curr = curr->next->next;\n    }\n    // Separate the new nodes from the original nodes\n    curr = head;\n    Node* clonedHead = head->next;\n    Node* clone = clonedHead;\n    while (clone->next != NULL) {\n          // Update the next nodes of original node\n          // and cloned node\n        curr->next = curr->next->next;\n        clone->next = clone->next->next;\n          // Move pointers of original as well as\n          // cloned linked list to their next nodes\n        curr = curr->next;\n        clone = clone->next;\n    }\n    curr->next = NULL;\n    clone->next = NULL;\n    return clonedHead;\n}\n// Function to print the linked list\nvoid printList(Node* head) {\n    while (head != NULL) {\n        cout << head->data << \"(\";\n          if(head->random)\n              cout << head->random->data << \")\";\n          else\n              cout << \"null\" << \")\";\n          if(head->next != NULL)\n              cout << \" -> \";\n        head = head->next;\n    }\n    cout << endl;\n}\nint main() {\n    // Creating a linked list with random pointer\n    Node* head = new Node(1);\n    head->next = new Node(2);\n    head->next->next = new Node(3);\n    head->next->next->next = new Node(4);\n    head->next->next->next->next = new Node(5);\n    head->random = head->next->next;\n    head->next->random = head;\n    head->next->next->random = head->next->next->next->next;\n    head->next->next->next->random = head->next->next;\n    head->next->next->next->next->random = head->next;\n    // Print the original list\n    cout << \"Original linked list:\\n\";\n    printList(head);\n    // Function call\n    Node* clonedList = cloneLinkedList(head);\n    cout << \"Cloned linked list:\\n\";\n    printList(clonedList);\n    return 0;\n}",
    "code_without_comments": "\n\n#include <bits/stdc++.h>\nusing namespace std;\nstruct Node {\n    int data;\n    Node *next, *random;\n    Node(int x) {\n        data = x;\n        next = random = NULL;\n    }\n};\nNode* cloneLinkedList(Node* head) {\n    if (head == NULL) {\n        return NULL;\n    }\n\n\n    Node* curr = head;\n    while (curr != NULL) {\n        Node* newNode = new Node(curr->data);\n        newNode->next = curr->next;\n        curr->next = newNode;\n        curr = newNode->next;\n    }\n\n    curr = head;\n    while (curr != NULL) {\n        if (curr->random != NULL)\n            curr->next->random = curr->random->next;\n        curr = curr->next->next;\n    }\n\n    curr = head;\n    Node* clonedHead = head->next;\n    Node* clone = clonedHead;\n    while (clone->next != NULL) {\n\n\n        curr->next = curr->next->next;\n        clone->next = clone->next->next;\n\n\n        curr = curr->next;\n        clone = clone->next;\n    }\n    curr->next = NULL;\n    clone->next = NULL;\n    return clonedHead;\n}\n\nvoid printList(Node* head) {\n    while (head != NULL) {\n        cout << head->data << \"(\";\n          if(head->random)\n              cout << head->random->data << \")\";\n          else\n              cout << \"null\" << \")\";\n          if(head->next != NULL)\n              cout << \" -> \";\n        head = head->next;\n    }\n    cout << endl;\n}\nint main() {\n\n    Node* head = new Node(1);\n    head->next = new Node(2);\n    head->next->next = new Node(3);\n    head->next->next->next = new Node(4);\n    head->next->next->next->next = new Node(5);\n    head->random = head->next->next;\n    head->next->random = head;\n    head->next->next->random = head->next->next->next->next;\n    head->next->next->next->random = head->next->next;\n    head->next->next->next->next->random = head->next;\n\n    cout << \"Original linked list:\\n\";\n    printList(head);\n\n    Node* clonedList = cloneLinkedList(head);\n    cout << \"Cloned linked list:\\n\";\n    printList(clonedList);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/clone-linked-list-next-random-pointer-o1-space/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "# Python code to Clone a linked list with next and random\n# pointer by Inserting Nodes In-place\nclass Node:\n    def __init__(self, x):\n        self.data = x\n        self.next = None\n        self.random = None\n# Function to clone the linked list\ndef clone_linked_list(head):\n    if head is None:\n        return None\n    # Create new nodes and insert them next to\n    # the original nodes\n    curr = head\n    while curr is not None:\n        new_node = Node(curr.data)\n        new_node.next = curr.next\n        curr.next = new_node\n        curr = new_node.next\n    # Set the random pointers of the new nodes\n    curr = head\n    while curr is not None:\n        if curr.random is not None:\n            curr.next.random = curr.random.next\n        curr = curr.next.next\n    # Separate the new nodes from the original nodes\n    curr = head\n    cloned_head = head.next\n    clone = cloned_head\n    while clone.next is not None:\n        # Update the next nodes of original node\n        # and cloned node\n        curr.next = curr.next.next\n        clone.next = clone.next.next\n        # Move pointers of original as well as\n        # cloned linked list to their next nodes\n        curr = curr.next\n        clone = clone.next\n    curr.next = None\n    clone.next = None\n    return cloned_head\n# Function to print the linked list\ndef print_list(head):\n    while head is not None:\n        print(f\"{head.data}(\", end=\"\")\n        if head.random:\n            print(f\"{head.random.data})\", end=\"\")\n        else:\n            print(\"null)\", end=\"\")\n        if head.next is not None:\n            print(\" -> \", end=\"\")\n        head = head.next\n    print()\nif __name__ == \"__main__\":\n    # Creating a linked list with random pointer\n    head = Node(1)\n    head.next = Node(2)\n    head.next.next = Node(3)\n    head.next.next.next = Node(4)\n    head.next.next.next.next = Node(5)\n    head.random = head.next.next\n    head.next.random = head\n    head.next.next.random = head.next.next.next.next\n    head.next.next.next.random = head.next.next\n    head.next.next.next.next.random = head.next\n    # Print the original list\n    print(\"Original linked list:\")\n    print_list(head)\n    # Function call\n    cloned_list = clone_linked_list(head)\n    print(\"Cloned linked list:\")\n    print_list(cloned_list)",
    "code_without_comments": "\n\nclass Node:\n    def __init__(self, x):\n        self.data = x\n        self.next = None\n        self.random = None\n\ndef clone_linked_list(head):\n    if head is None:\n        return None\n\n\n    curr = head\n    while curr is not None:\n        new_node = Node(curr.data)\n        new_node.next = curr.next\n        curr.next = new_node\n        curr = new_node.next\n\n    curr = head\n    while curr is not None:\n        if curr.random is not None:\n            curr.next.random = curr.random.next\n        curr = curr.next.next\n\n    curr = head\n    cloned_head = head.next\n    clone = cloned_head\n    while clone.next is not None:\n\n\n        curr.next = curr.next.next\n        clone.next = clone.next.next\n\n\n        curr = curr.next\n        clone = clone.next\n    curr.next = None\n    clone.next = None\n    return cloned_head\n\ndef print_list(head):\n    while head is not None:\n        print(f\"{head.data}(\", end=\"\")\n        if head.random:\n            print(f\"{head.random.data})\", end=\"\")\n        else:\n            print(\"null)\", end=\"\")\n        if head.next is not None:\n            print(\" -> \", end=\"\")\n        head = head.next\n    print()\nif __name__ == \"__main__\":\n\n    head = Node(1)\n    head.next = Node(2)\n    head.next.next = Node(3)\n    head.next.next.next = Node(4)\n    head.next.next.next.next = Node(5)\n    head.random = head.next.next\n    head.next.random = head\n    head.next.next.random = head.next.next.next.next\n    head.next.next.next.random = head.next.next\n    head.next.next.next.next.random = head.next\n\n    print(\"Original linked list:\")\n    print_list(head)\n\n    cloned_list = clone_linked_list(head)\n    print(\"Cloned linked list:\")\n    print_list(cloned_list)",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/clone-linked-list-next-random-pointer-o1-space/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\n// Function to check if it is safe to place\nint isSafe(vector<vector<int>>& mat,\n                    int row, int col) {\n    int n = mat.size();\n    int i, j;\n    // Check this col on upper side\n    for (i = 0; i < row; i++)\n        if (mat[i][col])\n            return 0;\n    // Check upper diagonal on left side\n    for (i = row-1, j = col-1; i >= 0 && j >= 0; i--, j--)\n        if (mat[i][j])\n            return 0;\n    // Check upper diagonal on right side\n    for (i = row-1, j = col+1; j < n && i >= 0; i--, j++)\n        if (mat[i][j])\n            return 0;\n    return 1;\n}\n// Recursive function to place queens\nvoid placeQueens(int row, vector<vector<int>>& mat, vector<vector<int>>&result) {\n    int n = mat.size();\n    // base case: If all queens are placed\n    if(row == n) {\n        // store current solution\n        vector<int> ans;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                if(mat[i][j]){\n                    ans.push_back(j + 1);\n                }\n            }\n        }\n        result.push_back(ans);\n        return;\n    }\n    // Consider the row and try placing\n    // queen in all columns one by one\n    for(int i = 0; i < n; i++){\n        // Check if the queen can be placed\n        if(isSafe(mat, row, i)){\n            mat[row][i] = 1;\n            placeQueens(row + 1, mat, result);\n            // backtrack\n            mat[row][i] = 0;\n        }\n    }\n}\n// Function to find all solutions\nvector<vector<int>> nQueen(int n) {\n    // Initialize the board\n    vector<vector<int>> mat(n, vector<int>(n, 0));\n    vector<vector<int>> result;\n    // Place queens\n    placeQueens(0, mat, result);\n    return result;\n}\nint main() {\n    int n = 4;\n    vector<vector<int>> result = nQueen(n);\n    for(auto &ans : result){\n        for(auto i: ans){\n            cout << i << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint isSafe(vector<vector<int>>& mat,\n                    int row, int col) {\n    int n = mat.size();\n    int i, j;\n\n    for (i = 0; i < row; i++)\n        if (mat[i][col])\n            return 0;\n\n    for (i = row-1, j = col-1; i >= 0 && j >= 0; i--, j--)\n        if (mat[i][j])\n            return 0;\n\n    for (i = row-1, j = col+1; j < n && i >= 0; i--, j++)\n        if (mat[i][j])\n            return 0;\n    return 1;\n}\n\nvoid placeQueens(int row, vector<vector<int>>& mat, vector<vector<int>>&result) {\n    int n = mat.size();\n\n    if(row == n) {\n\n        vector<int> ans;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                if(mat[i][j]){\n                    ans.push_back(j + 1);\n                }\n            }\n        }\n        result.push_back(ans);\n        return;\n    }\n\n\n    for(int i = 0; i < n; i++){\n\n        if(isSafe(mat, row, i)){\n            mat[row][i] = 1;\n            placeQueens(row + 1, mat, result);\n\n            mat[row][i] = 0;\n        }\n    }\n}\n\nvector<vector<int>> nQueen(int n) {\n\n    vector<vector<int>> mat(n, vector<int>(n, 0));\n    vector<vector<int>> result;\n\n    placeQueens(0, mat, result);\n    return result;\n}\nint main() {\n    int n = 4;\n    vector<vector<int>> result = nQueen(n);\n    for(auto &ans : result){\n        for(auto i: ans){\n            cout << i << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/n-queen-problem-backtracking-3/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "def isSafe(mat, row, col):\n    n = len(mat)\n    # Check this col on upper side\n    for i in range(row):\n        if mat[i][col]:\n            return 0\n    # Check upper diagonal on left side\n    i, j = row - 1, col - 1\n    while i >= 0 and j >= 0:\n        if mat[i][j]:\n            return 0\n        i -= 1\n        j -= 1\n    # Check upper diagonal on right side\n    i, j = row - 1, col + 1\n    while i >= 0 and j < n:\n        if mat[i][j]:\n            return 0\n        i -= 1\n        j += 1\n    return 1\n# Recursive function to place queens\ndef placeQueens(row, mat, result):\n    n = len(mat)\n    # base case: If all queens are placed\n    if row == n:\n        # store current solution\n        ans = []\n        for i in range(n):\n            for j in range(n):\n                if mat[i][j]:\n                    ans.append(j + 1)\n        result.append(ans)\n        return\n    # Consider the row and try placing\n    # queen in all columns one by one\n    for i in range(n):\n        # Check if the queen can be placed\n        if isSafe(mat, row, i):\n            mat[row][i] = 1\n            placeQueens(row + 1, mat, result)\n            # backtrack\n            mat[row][i] = 0\n# Function to find all solutions\ndef nQueen(n):\n    # Initialize the board\n    mat = [[0] * n for _ in range(n)]\n    result = []\n    # Place queens\n    placeQueens(0, mat, result)\n    return result\nif __name__ == \"__main__\":\n    n = 4\n    result = nQueen(n)\n    for ans in result:\n        print(\" \".join(map(str, ans)))",
    "code_without_comments": "def isSafe(mat, row, col):\n    n = len(mat)\n\n    for i in range(row):\n        if mat[i][col]:\n            return 0\n\n    i, j = row - 1, col - 1\n    while i >= 0 and j >= 0:\n        if mat[i][j]:\n            return 0\n        i -= 1\n        j -= 1\n\n    i, j = row - 1, col + 1\n    while i >= 0 and j < n:\n        if mat[i][j]:\n            return 0\n        i -= 1\n        j += 1\n    return 1\n\ndef placeQueens(row, mat, result):\n    n = len(mat)\n\n    if row == n:\n\n        ans = []\n        for i in range(n):\n            for j in range(n):\n                if mat[i][j]:\n                    ans.append(j + 1)\n        result.append(ans)\n        return\n\n\n    for i in range(n):\n\n        if isSafe(mat, row, i):\n            mat[row][i] = 1\n            placeQueens(row + 1, mat, result)\n\n            mat[row][i] = 0\n\ndef nQueen(n):\n\n    mat = [[0] * n for _ in range(n)]\n    result = []\n\n    placeQueens(0, mat, result)\n    return result\nif __name__ == \"__main__\":\n    n = 4\n    result = nQueen(n)\n    for ans in result:\n        print(\" \".join(map(str, ans)))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/n-queen-problem-backtracking-3/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "using System;\nusing System.Collections.Generic;\nclass GFG {\n    // Function to check if it is safe to place\n    static int isSafe(int[,] mat, int row, int col) {\n        int n = mat.GetLength(0);\n        int i, j;\n        // Check this col on upper side\n        for (i = 0; i < row; i++)\n            if (mat[i, col] == 1)\n                return 0;\n        // Check upper diagonal on left side\n        for (i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--)\n            if (mat[i, j] == 1)\n                return 0;\n        // Check upper diagonal on right side\n        for (i = row - 1, j = col + 1; j < n && i >= 0; i--, j++)\n            if (mat[i, j] == 1)\n                return 0;\n        return 1;\n    }\n    // Recursive function to place queens\n    static void placeQueens(int row, int[,] mat, List<List<int>> result) {\n        int n = mat.GetLength(0);\n        // base case: If all queens are placed\n        if (row == n)\n        {\n            // store current solution\n            List<int> ans = new List<int>();\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    if (mat[i, j] == 1)\n                    {\n                        ans.Add(j + 1);\n                    }\n                }\n            }\n            result.Add(ans);\n            return;\n        }\n        // Consider the row and try placing\n        // queen in all columns one by one\n        for (int i = 0; i < n; i++)\n        {\n            // Check if the queen can be placed\n            if (isSafe(mat, row, i) == 1)\n            {\n                mat[row, i] = 1;\n                placeQueens(row + 1, mat, result);\n                // backtrack\n                mat[row, i] = 0;\n            }\n        }\n    }\n    // Function to find all solutions\n    static List<List<int>> nQueen(int n) {\n        // Initialize the board\n        int[,] mat = new int[n, n];\n        List<List<int>> result = new List<List<int>>();\n        // Place queens\n        placeQueens(0, mat, result);\n        return result;\n    }\n    public static void Main()\n    {\n        int n = 4;\n        List<List<int>> result = nQueen(n);\n        foreach (var ans in result)\n        {\n            foreach (var i in ans)\n            {\n                Console.Write(i + \" \");\n            }\n            Console.WriteLine();\n        }\n    }\n}",
    "code_without_comments": "using System;\nusing System.Collections.Generic;\nclass GFG {\n\n    static int isSafe(int[,] mat, int row, int col) {\n        int n = mat.GetLength(0);\n        int i, j;\n\n        for (i = 0; i < row; i++)\n            if (mat[i, col] == 1)\n                return 0;\n\n        for (i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--)\n            if (mat[i, j] == 1)\n                return 0;\n\n        for (i = row - 1, j = col + 1; j < n && i >= 0; i--, j++)\n            if (mat[i, j] == 1)\n                return 0;\n        return 1;\n    }\n\n    static void placeQueens(int row, int[,] mat, List<List<int>> result) {\n        int n = mat.GetLength(0);\n\n        if (row == n)\n        {\n\n            List<int> ans = new List<int>();\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    if (mat[i, j] == 1)\n                    {\n                        ans.Add(j + 1);\n                    }\n                }\n            }\n            result.Add(ans);\n            return;\n        }\n\n\n        for (int i = 0; i < n; i++)\n        {\n\n            if (isSafe(mat, row, i) == 1)\n            {\n                mat[row, i] = 1;\n                placeQueens(row + 1, mat, result);\n\n                mat[row, i] = 0;\n            }\n        }\n    }\n\n    static List<List<int>> nQueen(int n) {\n\n        int[,] mat = new int[n, n];\n        List<List<int>> result = new List<List<int>>();\n\n        placeQueens(0, mat, result);\n        return result;\n    }\n    public static void Main()\n    {\n        int n = 4;\n        List<List<int>> result = nQueen(n);\n        foreach (var ans in result)\n        {\n            foreach (var i in ans)\n            {\n                Console.Write(i + \" \");\n            }\n            Console.WriteLine();\n        }\n    }\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/n-queen-problem-backtracking-3/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "// Function to check if it is safe to place\nfunction isSafe(mat, row, col) {\n    let n = mat.length;\n    let i, j;\n    // Check this col on upper side\n    for (i = 0; i < row; i++)\n        if (mat[i][col])\n            return 0;\n    // Check upper diagonal on left side\n    for (i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--)\n        if (mat[i][j])\n            return 0;\n    // Check upper diagonal on right side\n    for (i = row - 1, j = col + 1; j < n && i >= 0; i--, j++)\n        if (mat[i][j])\n            return 0;\n    return 1;\n}\n// Recursive function to place queens\nfunction placeQueens(row, mat, result) {\n    let n = mat.length;\n    // base case: If all queens are placed\n    if (row === n) {\n        // store current solution\n        let ans = [];\n        for (let i = 0; i < n; i++) {\n            for (let j = 0; j < n; j++) {\n                if (mat[i][j]) {\n                    ans.push(j + 1);\n                }\n            }\n        }\n        result.push(ans);\n        return;\n    }\n    // Consider the row and try placing\n    // queen in all columns one by one\n    for (let i = 0; i < n; i++) {\n        // Check if the queen can be placed\n        if (isSafe(mat, row, i)) {\n            mat[row][i] = 1;\n            placeQueens(row + 1, mat, result);\n            // backtrack\n            mat[row][i] = 0;\n        }\n    }\n}\n// Function to find all solutions\nfunction nQueen(n) {\n    // Initialize the board\n    let mat = Array.from({ length: n }, () => Array(n).fill(0));\n    let result = [];\n    // Place queens\n    placeQueens(0, mat, result);\n    return result;\n}\n// Driver code\nlet n = 4;\nlet result = nQueen(n);\nfor (let ans of result) {\n    console.log(ans.join(' '));\n}",
    "code_without_comments": "\nfunction isSafe(mat, row, col) {\n    let n = mat.length;\n    let i, j;\n\n    for (i = 0; i < row; i++)\n        if (mat[i][col])\n            return 0;\n\n    for (i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--)\n        if (mat[i][j])\n            return 0;\n\n    for (i = row - 1, j = col + 1; j < n && i >= 0; i--, j++)\n        if (mat[i][j])\n            return 0;\n    return 1;\n}\n\nfunction placeQueens(row, mat, result) {\n    let n = mat.length;\n\n    if (row === n) {\n\n        let ans = [];\n        for (let i = 0; i < n; i++) {\n            for (let j = 0; j < n; j++) {\n                if (mat[i][j]) {\n                    ans.push(j + 1);\n                }\n            }\n        }\n        result.push(ans);\n        return;\n    }\n\n\n    for (let i = 0; i < n; i++) {\n\n        if (isSafe(mat, row, i)) {\n            mat[row][i] = 1;\n            placeQueens(row + 1, mat, result);\n\n            mat[row][i] = 0;\n        }\n    }\n}\n\nfunction nQueen(n) {\n\n    let mat = Array.from({ length: n }, () => Array(n).fill(0));\n    let result = [];\n\n    placeQueens(0, mat, result);\n    return result;\n}\n\nlet n = 4;\nlet result = nQueen(n);\nfor (let ans of result) {\n    console.log(ans.join(' '));\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/n-queen-problem-backtracking-3/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include<vector>\nusing namespace std;\n// Recursive function to place queens\nvoid placeQueens(int i, vector<int> &cols, vector<int> &leftDiagonal,\n                     vector<int> &rightDiagonal, vector<int> &cur,\n                     vector<vector<int>> &result) {\n    int n = cols.size();\n    // base case: If all queens are placed\n    if(i == n) {\n        result.push_back(cur);\n        return;\n    }\n    // Consider the row and try placing\n    // queen in all columns one by one\n    for(int j = 0; j < n; j++){\n        // Check if the queen can be placed\n        if(cols[j] || rightDiagonal[i + j] ||\n                        leftDiagonal[i - j + n - 1])\n            continue;\n        // mark the cell occupied\n        cols[j] = 1;\n        rightDiagonal[i+j] = 1;\n        leftDiagonal[i - j + n - 1] = 1;\n        cur.push_back(j+1);\n        placeQueens(i + 1, cols, leftDiagonal, rightDiagonal, cur, result);\n        // remove the queen from current cell\n        cur.pop_back();\n        cols[j] = 0;\n        rightDiagonal[i+j] = 0;\n        leftDiagonal[i - j + n - 1] = 0;\n    }\n}\n// Function to find the solution\n// to the N-Queens problem\nvector<vector<int>> nQueen(int n) {\n    // array to mark the occupied cells\n    vector<int> cols(n, 0);\n    vector<int> leftDiagonal(n*2, 0);\n    vector<int> rightDiagonal(n*2, 0);\n    vector<int> cur;\n    vector<vector<int>> result;\n    // Place queens\n    placeQueens(0, cols, leftDiagonal, rightDiagonal, cur, result);\n    return result;\n}\nint main() {\n    int n = 4;\n    vector<vector<int>> ans = nQueen(n);\n    for(auto &a: ans){\n        for(auto i: a){\n            cout << i << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include<vector>\nusing namespace std;\n\nvoid placeQueens(int i, vector<int> &cols, vector<int> &leftDiagonal,\n                     vector<int> &rightDiagonal, vector<int> &cur,\n                     vector<vector<int>> &result) {\n    int n = cols.size();\n\n    if(i == n) {\n        result.push_back(cur);\n        return;\n    }\n\n\n    for(int j = 0; j < n; j++){\n\n        if(cols[j] || rightDiagonal[i + j] ||\n                        leftDiagonal[i - j + n - 1])\n            continue;\n\n        cols[j] = 1;\n        rightDiagonal[i+j] = 1;\n        leftDiagonal[i - j + n - 1] = 1;\n        cur.push_back(j+1);\n        placeQueens(i + 1, cols, leftDiagonal, rightDiagonal, cur, result);\n\n        cur.pop_back();\n        cols[j] = 0;\n        rightDiagonal[i+j] = 0;\n        leftDiagonal[i - j + n - 1] = 0;\n    }\n}\n\n\nvector<vector<int>> nQueen(int n) {\n\n    vector<int> cols(n, 0);\n    vector<int> leftDiagonal(n*2, 0);\n    vector<int> rightDiagonal(n*2, 0);\n    vector<int> cur;\n    vector<vector<int>> result;\n\n    placeQueens(0, cols, leftDiagonal, rightDiagonal, cur, result);\n    return result;\n}\nint main() {\n    int n = 4;\n    vector<vector<int>> ans = nQueen(n);\n    for(auto &a: ans){\n        for(auto i: a){\n            cout << i << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/n-queen-problem-backtracking-3/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "# Recursive function to place queens\ndef placeQueens(i, cols, leftDiagonal, rightDiagonal, cur, result):\n    n = len(cols)\n    # base case: If all queens are placed\n    if i == n:\n        result.append(cur[:])\n        return\n    # Consider the row and try placing\n    # queen in all columns one by one\n    for j in range(n):\n        # Check if the queen can be placed\n        if cols[j] or rightDiagonal[i + j] or leftDiagonal[i - j + n - 1]:\n            continue\n        # mark the cell occupied\n        cols[j] = 1\n        rightDiagonal[i + j] = 1\n        leftDiagonal[i - j + n - 1] = 1\n        cur.append(j + 1)\n        placeQueens(i + 1, cols, leftDiagonal, rightDiagonal, cur, result)\n        # remove the queen from current cell\n        cur.pop()\n        cols[j] = 0\n        rightDiagonal[i + j] = 0\n        leftDiagonal[i - j + n - 1] = 0\n# Function to find the solution\n# to the N-Queens problem\ndef nQueen(n):\n    # array to mark the occupied cells\n    cols = [0] * n\n    leftDiagonal = [0] * (2 * n)\n    rightDiagonal = [0] * (2 * n)\n    cur = []\n    result = []\n    # Place queens\n    placeQueens(0, cols, leftDiagonal, rightDiagonal, cur, result)\n    return result\nif __name__ == \"__main__\":\n    n = 4\n    ans = nQueen(n)\n    for a in ans:\n        print(\" \".join(map(str, a)))",
    "code_without_comments": "\ndef placeQueens(i, cols, leftDiagonal, rightDiagonal, cur, result):\n    n = len(cols)\n\n    if i == n:\n        result.append(cur[:])\n        return\n\n\n    for j in range(n):\n\n        if cols[j] or rightDiagonal[i + j] or leftDiagonal[i - j + n - 1]:\n            continue\n\n        cols[j] = 1\n        rightDiagonal[i + j] = 1\n        leftDiagonal[i - j + n - 1] = 1\n        cur.append(j + 1)\n        placeQueens(i + 1, cols, leftDiagonal, rightDiagonal, cur, result)\n\n        cur.pop()\n        cols[j] = 0\n        rightDiagonal[i + j] = 0\n        leftDiagonal[i - j + n - 1] = 0\n\n\ndef nQueen(n):\n\n    cols = [0] * n\n    leftDiagonal = [0] * (2 * n)\n    rightDiagonal = [0] * (2 * n)\n    cur = []\n    result = []\n\n    placeQueens(0, cols, leftDiagonal, rightDiagonal, cur, result)\n    return result\nif __name__ == \"__main__\":\n    n = 4\n    ans = nQueen(n)\n    for a in ans:\n        print(\" \".join(map(str, a)))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/n-queen-problem-backtracking-3/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "using System;\nusing System.Collections.Generic;\nclass GFG {\n    // Recursive function to place queens\n    static void placeQueens(int i, int[] cols, int[] leftDiagonal, int[] rightDiagonal,\n                            List<int> cur, List<List<int>> result) {\n        int n = cols.Length;\n        // base case: If all queens are placed\n        if (i == n) {\n            result.Add(new List<int>(cur));\n            return;\n        }\n        // Consider the row and try placing\n        // queen in all columns one by one\n        for (int j = 0; j < n; j++) {\n            // Check if the queen can be placed\n            if (cols[j] == 1 || rightDiagonal[i + j] == 1 ||\n                leftDiagonal[i - j + n - 1] == 1)\n                continue;\n            // mark the cell occupied\n            cols[j] = 1;\n            rightDiagonal[i + j] = 1;\n            leftDiagonal[i - j + n - 1] = 1;\n            cur.Add(j + 1);\n            placeQueens(i + 1, cols, leftDiagonal, rightDiagonal, cur, result);\n            // remove the queen from current cell\n            cur.RemoveAt(cur.Count - 1);\n            cols[j] = 0;\n            rightDiagonal[i + j] = 0;\n            leftDiagonal[i - j + n - 1] = 0;\n        }\n    }\n    // Function to find the solution\n    // to the N-Queens problem\n    static List<List<int>> nQueen(int n) {\n        // array to mark the occupied cells\n        int[] cols = new int[n];\n        int[] leftDiagonal = new int[2 * n];\n        int[] rightDiagonal = new int[2 * n];\n        List<int> cur = new List<int>();\n        List<List<int>> result = new List<List<int>>();\n        // Place queens\n        placeQueens(0, cols, leftDiagonal, rightDiagonal, cur, result);\n        return result;\n    }\n    static void Main() {\n        int n = 4;\n        List<List<int>> ans = nQueen(n);\n        foreach (var a in ans) {\n            Console.WriteLine(string.Join(\" \", a));\n        }\n    }\n}",
    "code_without_comments": "using System;\nusing System.Collections.Generic;\nclass GFG {\n\n    static void placeQueens(int i, int[] cols, int[] leftDiagonal, int[] rightDiagonal,\n                            List<int> cur, List<List<int>> result) {\n        int n = cols.Length;\n\n        if (i == n) {\n            result.Add(new List<int>(cur));\n            return;\n        }\n\n\n        for (int j = 0; j < n; j++) {\n\n            if (cols[j] == 1 || rightDiagonal[i + j] == 1 ||\n                leftDiagonal[i - j + n - 1] == 1)\n                continue;\n\n            cols[j] = 1;\n            rightDiagonal[i + j] = 1;\n            leftDiagonal[i - j + n - 1] = 1;\n            cur.Add(j + 1);\n            placeQueens(i + 1, cols, leftDiagonal, rightDiagonal, cur, result);\n\n            cur.RemoveAt(cur.Count - 1);\n            cols[j] = 0;\n            rightDiagonal[i + j] = 0;\n            leftDiagonal[i - j + n - 1] = 0;\n        }\n    }\n\n\n    static List<List<int>> nQueen(int n) {\n\n        int[] cols = new int[n];\n        int[] leftDiagonal = new int[2 * n];\n        int[] rightDiagonal = new int[2 * n];\n        List<int> cur = new List<int>();\n        List<List<int>> result = new List<List<int>>();\n\n        placeQueens(0, cols, leftDiagonal, rightDiagonal, cur, result);\n        return result;\n    }\n    static void Main() {\n        int n = 4;\n        List<List<int>> ans = nQueen(n);\n        foreach (var a in ans) {\n            Console.WriteLine(string.Join(\" \", a));\n        }\n    }\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/n-queen-problem-backtracking-3/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "// Recursive function to place queens\nfunction placeQueens(i, cols, leftDiagonal, rightDiagonal, cur, result) {\n    const n = cols.length;\n    // base case: If all queens are placed\n    if (i === n) {\n        result.push([...cur]);\n        return;\n    }\n    // Consider the row and try placing\n    // queen in all columns one by one\n    for (let j = 0; j < n; j++) {\n        // Check if the queen can be placed\n        if (cols[j] || rightDiagonal[i + j] || leftDiagonal[i - j + n - 1]) {\n            continue;\n        }\n        // mark the cell occupied\n        cols[j] = 1;\n        rightDiagonal[i + j] = 1;\n        leftDiagonal[i - j + n - 1] = 1;\n        cur.push(j + 1);\n        placeQueens(i + 1, cols, leftDiagonal, rightDiagonal, cur, result);\n        // remove the queen from current cell\n        cur.pop();\n        cols[j] = 0;\n        rightDiagonal[i + j] = 0;\n        leftDiagonal[i - j + n - 1] = 0;\n    }\n}\n// Function to find the solution\n// to the N-Queens problem\nfunction nQueen(n) {\n    // array to mark the occupied cells\n    const cols = new Array(n).fill(0);\n    const leftDiagonal = new Array(2 * n).fill(0);\n    const rightDiagonal = new Array(2 * n).fill(0);\n    const cur = [];\n    const result = [];\n    // Place queens\n    placeQueens(0, cols, leftDiagonal, rightDiagonal, cur, result);\n    return result;\n}\n// Driven Code\nconst n = 4;\nconst ans = nQueen(n);\nans.forEach(a => {\n    console.log(a.join(\" \"));\n});",
    "code_without_comments": "\nfunction placeQueens(i, cols, leftDiagonal, rightDiagonal, cur, result) {\n    const n = cols.length;\n\n    if (i === n) {\n        result.push([...cur]);\n        return;\n    }\n\n\n    for (let j = 0; j < n; j++) {\n\n        if (cols[j] || rightDiagonal[i + j] || leftDiagonal[i - j + n - 1]) {\n            continue;\n        }\n\n        cols[j] = 1;\n        rightDiagonal[i + j] = 1;\n        leftDiagonal[i - j + n - 1] = 1;\n        cur.push(j + 1);\n        placeQueens(i + 1, cols, leftDiagonal, rightDiagonal, cur, result);\n\n        cur.pop();\n        cols[j] = 0;\n        rightDiagonal[i + j] = 0;\n        leftDiagonal[i - j + n - 1] = 0;\n    }\n}\n\n\nfunction nQueen(n) {\n\n    const cols = new Array(n).fill(0);\n    const leftDiagonal = new Array(2 * n).fill(0);\n    const rightDiagonal = new Array(2 * n).fill(0);\n    const cur = [];\n    const result = [];\n\n    placeQueens(0, cols, leftDiagonal, rightDiagonal, cur, result);\n    return result;\n}\n\nconst n = 4;\nconst ans = nQueen(n);\nans.forEach(a => {\n    console.log(a.join(\" \"));\n});",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/n-queen-problem-backtracking-3/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "// C++ implementation of the above approach\n#include <bits/stdc++.h>\n#define MAX 5\nusing namespace std;\n    void getallpath(int matrix[MAX][MAX], int n,int row,int col,vector<string> &ans,string cur)\n    {\n        if(row>=n or col>=n or row<0 or col<0 or matrix[row][col] == 0)\n        return ;\n        if(row == n-1 and col == n-1)\n        {\n            ans.push_back(cur);\n            return ;\n        }\n        //now if its one we have 4 calls\n        matrix[row][col] = 0;\n        getallpath(matrix,n,row-1,col,ans,cur+\"U\");\n        getallpath(matrix,n,row,col+1,ans,cur+\"R\");\n        getallpath(matrix,n,row,col-1,ans,cur+\"L\");\n        getallpath(matrix,n,row+1,col,ans,cur+\"D\");\n        matrix[row][col] = 1;\n        return ;\n    }\nvector<string> findPath(int matrix[MAX][MAX], int n) {\n        // Your code goes here\n        vector<string> ans;\n        getallpath(matrix,n,0,0,ans,\"\");\n        return ans;\n    }\nint main()\n{\n    int m[MAX][MAX] = { { 1, 0, 0, 0, 0 },\n                        { 1, 1, 1, 1, 1 },\n                        { 1, 1, 1, 0, 1 },\n                        { 0, 0, 0, 0, 1 },\n                        { 0, 0, 0, 0, 1 } };\n    int n = sizeof(m) / sizeof(m[0]);\n    vector<string> ans = findPath(m, n);\n    for(auto i : ans)\n    cout<<i<<\" \";\n    return 0;\n}",
    "code_without_comments": "\n#include <bits/stdc++.h>\n#define MAX 5\nusing namespace std;\n    void getallpath(int matrix[MAX][MAX], int n,int row,int col,vector<string> &ans,string cur)\n    {\n        if(row>=n or col>=n or row<0 or col<0 or matrix[row][col] == 0)\n        return ;\n        if(row == n-1 and col == n-1)\n        {\n            ans.push_back(cur);\n            return ;\n        }\n\n        matrix[row][col] = 0;\n        getallpath(matrix,n,row-1,col,ans,cur+\"U\");\n        getallpath(matrix,n,row,col+1,ans,cur+\"R\");\n        getallpath(matrix,n,row,col-1,ans,cur+\"L\");\n        getallpath(matrix,n,row+1,col,ans,cur+\"D\");\n        matrix[row][col] = 1;\n        return ;\n    }\nvector<string> findPath(int matrix[MAX][MAX], int n) {\n\n        vector<string> ans;\n        getallpath(matrix,n,0,0,ans,\"\");\n        return ans;\n    }\nint main()\n{\n    int m[MAX][MAX] = { { 1, 0, 0, 0, 0 },\n                        { 1, 1, 1, 1, 1 },\n                        { 1, 1, 1, 0, 1 },\n                        { 0, 0, 0, 0, 1 },\n                        { 0, 0, 0, 0, 1 } };\n    int n = sizeof(m) / sizeof(m[0]);\n    vector<string> ans = findPath(m, n);\n    for(auto i : ans)\n    cout<<i<<\" \";\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/rat-in-a-maze-problem-when-movement-in-all-possible-directions-is-allowed/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "# Python3 implementation of the above approach\ndef getallpath(mat, n, ans, curpath, r, c):\n        if(r>=n or c>=n or r<0 or c<0 or mat[r][c] == 0):\n            return;\n        if(r == n-1 and c == n-1):\n            ans.append(curpath)\n            return\n        mat[r][c] = 0\n        # calls\n        getallpath(mat,n,ans,curpath+\"U\",r-1,c)\n        getallpath(mat,n,ans,curpath+\"D\",r+1,c)\n        getallpath(mat,n,ans,curpath+\"L\",r,c-1)\n        getallpath(mat,n,ans,curpath+\"R\",r,c+1)\n        mat[r][c] = 1;\n# Function to store and print\n# all the valid paths\ndef findpath(mat ,n):\n    # vector to store all the possible paths\n    possiblePaths = []\n    getallpath(mat,n,possiblePaths,\"\",0,0)\n    # Print all possible paths\n    for i in range(len(possiblePaths)):\n        print(possiblePaths[i], end = \" \")\n# Driver code\nif __name__ == \"__main__\":\n    mat = [ [ 1, 0, 0, 0, 0 ],\n          [ 1, 1, 1, 1, 1 ],\n          [ 1, 1, 1, 0, 1 ],\n          [ 0, 0, 0, 0, 1 ],\n          [ 0, 0, 0, 0, 1 ] ]\n    n = len(mat)\n    findpath(mat, n)\n# This code is contributed by Arpit Jain",
    "code_without_comments": "\ndef getallpath(mat, n, ans, curpath, r, c):\n        if(r>=n or c>=n or r<0 or c<0 or mat[r][c] == 0):\n            return;\n        if(r == n-1 and c == n-1):\n            ans.append(curpath)\n            return\n        mat[r][c] = 0\n\n        getallpath(mat,n,ans,curpath+\"U\",r-1,c)\n        getallpath(mat,n,ans,curpath+\"D\",r+1,c)\n        getallpath(mat,n,ans,curpath+\"L\",r,c-1)\n        getallpath(mat,n,ans,curpath+\"R\",r,c+1)\n        mat[r][c] = 1;\n\n\ndef findpath(mat ,n):\n\n    possiblePaths = []\n    getallpath(mat,n,possiblePaths,\"\",0,0)\n\n    for i in range(len(possiblePaths)):\n        print(possiblePaths[i], end = \" \")\n\nif __name__ == \"__main__\":\n    mat = [ [ 1, 0, 0, 0, 0 ],\n          [ 1, 1, 1, 1, 1 ],\n          [ 1, 1, 1, 0, 1 ],\n          [ 0, 0, 0, 0, 1 ],\n          [ 0, 0, 0, 0, 1 ] ]\n    n = len(mat)\n    findpath(mat, n)\n",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/rat-in-a-maze-problem-when-movement-in-all-possible-directions-is-allowed/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\n// Function to check if it is safe to place num at mat[row][col]\nbool isSafe(vector<vector<int>> &mat, int row, int col, int num) {\n    // Check if num exist in the row\n    for (int x = 0; x <= 8; x++)\n        if (mat[row][x] == num)\n            return false;\n    // Check if num exist in the col\n    for (int x = 0; x <= 8; x++)\n        if (mat[x][col] == num)\n            return false;\n    // Check if num exist in the 3x3 sub-matrix\n    int startRow = row - (row % 3), startCol = col - (col % 3);\n    for (int i = 0; i < 3; i++)\n        for (int j = 0; j < 3; j++)\n            if (mat[i + startRow][j + startCol] == num)\n                return false;\n    return true;\n}\n// Function to solve the Sudoku problem\nbool solveSudokuRec(vector<vector<int>> &mat, int row, int col) {\n    int n = mat.size();\n    // base case: Reached nth column of last row\n    if (row == n - 1 && col == n)\n        return true;\n    // If last column of the row go to next row\n    if (col == n) {\n        row++;\n        col = 0;\n    }\n    // If cell is already occupied then move forward\n    if (mat[row][col] != 0)\n        return solveSudokuRec(mat, row, col + 1);\n    for (int num = 1; num <= n; num++) {\n        // If it is safe to place num at current position\n        if (isSafe(mat, row, col, num)) {\n            mat[row][col] = num;\n            if (solveSudokuRec(mat, row, col + 1))\n                return true;\n            mat[row][col] = 0;\n        }\n    }\n  \treturn false;\n}\nvoid solveSudoku(vector<vector<int>> &mat) {\n  \tsolveSudokuRec(mat, 0, 0);\n}\nint main() {\n    vector<vector<int>> mat = {\n        {3, 0, 6, 5, 0, 8, 4, 0, 0},\n      \t{5, 2, 0, 0, 0, 0, 0, 0, 0},\n      \t{0, 8, 7, 0, 0, 0, 0, 3, 1},\n        {0, 0, 3, 0, 1, 0, 0, 8, 0},\n      \t{9, 0, 0, 8, 6, 3, 0, 0, 5},\n      \t{0, 5, 0, 0, 9, 0, 6, 0, 0},\n        {1, 3, 0, 0, 0, 0, 2, 5, 0},\n      \t{0, 0, 0, 0, 0, 0, 0, 7, 4},\n      \t{0, 0, 5, 2, 0, 6, 3, 0, 0}};\n\tsolveSudoku(mat);\n  \tfor (int i = 0; i < mat.size(); i++) {\n        for (int j = 0; j < mat.size(); j++)\n            cout << mat[i][j] << \" \";\n        cout << endl;\n    }\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool isSafe(vector<vector<int>> &mat, int row, int col, int num) {\n\n    for (int x = 0; x <= 8; x++)\n        if (mat[row][x] == num)\n            return false;\n\n    for (int x = 0; x <= 8; x++)\n        if (mat[x][col] == num)\n            return false;\n\n    int startRow = row - (row % 3), startCol = col - (col % 3);\n    for (int i = 0; i < 3; i++)\n        for (int j = 0; j < 3; j++)\n            if (mat[i + startRow][j + startCol] == num)\n                return false;\n    return true;\n}\n\nbool solveSudokuRec(vector<vector<int>> &mat, int row, int col) {\n    int n = mat.size();\n\n    if (row == n - 1 && col == n)\n        return true;\n\n    if (col == n) {\n        row++;\n        col = 0;\n    }\n\n    if (mat[row][col] != 0)\n        return solveSudokuRec(mat, row, col + 1);\n    for (int num = 1; num <= n; num++) {\n\n        if (isSafe(mat, row, col, num)) {\n            mat[row][col] = num;\n            if (solveSudokuRec(mat, row, col + 1))\n                return true;\n            mat[row][col] = 0;\n        }\n    }\n  \treturn false;\n}\nvoid solveSudoku(vector<vector<int>> &mat) {\n  \tsolveSudokuRec(mat, 0, 0);\n}\nint main() {\n    vector<vector<int>> mat = {\n        {3, 0, 6, 5, 0, 8, 4, 0, 0},\n      \t{5, 2, 0, 0, 0, 0, 0, 0, 0},\n      \t{0, 8, 7, 0, 0, 0, 0, 3, 1},\n        {0, 0, 3, 0, 1, 0, 0, 8, 0},\n      \t{9, 0, 0, 8, 6, 3, 0, 0, 5},\n      \t{0, 5, 0, 0, 9, 0, 6, 0, 0},\n        {1, 3, 0, 0, 0, 0, 2, 5, 0},\n      \t{0, 0, 0, 0, 0, 0, 0, 7, 4},\n      \t{0, 0, 5, 2, 0, 6, 3, 0, 0}};\n\tsolveSudoku(mat);\n  \tfor (int i = 0; i < mat.size(); i++) {\n        for (int j = 0; j < mat.size(); j++)\n            cout << mat[i][j] << \" \";\n        cout << endl;\n    }\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/sudoku-backtracking-7/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "# Function to check if it is safe to place num at mat[row][col]\ndef isSafe(mat, row, col, num):\n    # Check if num exists in the row\n    for x in range(9):\n        if mat[row][x] == num:\n            return False\n    # Check if num exists in the col\n    for x in range(9):\n        if mat[x][col] == num:\n            return False\n    # Check if num exists in the 3x3 sub-matrix\n    startRow = row - (row % 3)\n    startCol = col - (col % 3)\n    for i in range(3):\n        for j in range(3):\n            if mat[i + startRow][j + startCol] == num:\n                return False\n    return True\n# Function to solve the Sudoku problem\ndef solveSudokuRec(mat, row, col):\n    # base case: Reached nth column of the last row\n    if row == 8 and col == 9:\n        return True\n    # If last column of the row go to the next row\n    if col == 9:\n        row += 1\n        col = 0\n    # If cell is already occupied then move forward\n    if mat[row][col] != 0:\n        return solveSudokuRec(mat, row, col + 1)\n    for num in range(1, 10):\n        # If it is safe to place num at current position\n        if isSafe(mat, row, col, num):\n            mat[row][col] = num\n            if solveSudokuRec(mat, row, col + 1):\n                return True\n            mat[row][col] = 0\n    return False\ndef solveSudoku(mat):\n    solveSudokuRec(mat, 0, 0)\nif __name__ == \"__main__\":\n    mat = [\n        [3, 0, 6, 5, 0, 8, 4, 0, 0],\n        [5, 2, 0, 0, 0, 0, 0, 0, 0],\n        [0, 8, 7, 0, 0, 0, 0, 3, 1],\n        [0, 0, 3, 0, 1, 0, 0, 8, 0],\n        [9, 0, 0, 8, 6, 3, 0, 0, 5],\n        [0, 5, 0, 0, 9, 0, 6, 0, 0],\n        [1, 3, 0, 0, 0, 0, 2, 5, 0],\n        [0, 0, 0, 0, 0, 0, 0, 7, 4],\n        [0, 0, 5, 2, 0, 6, 3, 0, 0]\n    ]\n    solveSudoku(mat)\n    for row in mat:\n        print(\" \".join(map(str, row)))",
    "code_without_comments": "\ndef isSafe(mat, row, col, num):\n\n    for x in range(9):\n        if mat[row][x] == num:\n            return False\n\n    for x in range(9):\n        if mat[x][col] == num:\n            return False\n\n    startRow = row - (row % 3)\n    startCol = col - (col % 3)\n    for i in range(3):\n        for j in range(3):\n            if mat[i + startRow][j + startCol] == num:\n                return False\n    return True\n\ndef solveSudokuRec(mat, row, col):\n\n    if row == 8 and col == 9:\n        return True\n\n    if col == 9:\n        row += 1\n        col = 0\n\n    if mat[row][col] != 0:\n        return solveSudokuRec(mat, row, col + 1)\n    for num in range(1, 10):\n\n        if isSafe(mat, row, col, num):\n            mat[row][col] = num\n            if solveSudokuRec(mat, row, col + 1):\n                return True\n            mat[row][col] = 0\n    return False\ndef solveSudoku(mat):\n    solveSudokuRec(mat, 0, 0)\nif __name__ == \"__main__\":\n    mat = [\n        [3, 0, 6, 5, 0, 8, 4, 0, 0],\n        [5, 2, 0, 0, 0, 0, 0, 0, 0],\n        [0, 8, 7, 0, 0, 0, 0, 3, 1],\n        [0, 0, 3, 0, 1, 0, 0, 8, 0],\n        [9, 0, 0, 8, 6, 3, 0, 0, 5],\n        [0, 5, 0, 0, 9, 0, 6, 0, 0],\n        [1, 3, 0, 0, 0, 0, 2, 5, 0],\n        [0, 0, 0, 0, 0, 0, 0, 7, 4],\n        [0, 0, 5, 2, 0, 6, 3, 0, 0]\n    ]\n    solveSudoku(mat)\n    for row in mat:\n        print(\" \".join(map(str, row)))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/sudoku-backtracking-7/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\n// Function to heck if it is safe to place num at mat[row][col]\nbool isSafe(vector<vector<int>> &mat, int i, int j, int num,\n        vector<int> &row, vector<int> &col, vector<int> &box) {\n    if( (row[i] & (1 << num)) || (col[j] & (1 << num)) ||\n       \t\t\t\t\t(box[i / 3 * 3 + j / 3] & (1 << num)) )\n        return false;\n    return true;\n}\nbool sudokuSolverRec(vector<vector<int>> &mat, int i, int j,\n    \t\tvector<int> &row, vector<int> &col, vector<int> &box) {\n    int n = mat.size();\n\t// base case: Reached nth column of last row\n    if (i == n - 1 && j == n)\n        return true;\n    // If reached last column of the row go to next row\n    if (j == n) {\n        i++;\n        j = 0;\n    }\n    // If cell is already occupied then move forward\n    if (mat[i][j] != 0)\n        return sudokuSolverRec(mat, i, j + 1, row, col, box);\n    for (int num = 1; num <= n; num++) {\n        // If it is safe to place num at current position\n        if (isSafe(mat, i, j, num, row, col, box)) {\n            mat[i][j] = num;\n          \t// Update masks for the corresponding row, column and box\n            row[i] |= (1 << num);\n            col[j] |= (1 << num);\n            box[i / 3 * 3 + j / 3] |= (1 << num);\n            if (sudokuSolverRec(mat, i, j + 1, row, col, box))\n                return true;\n          \t// Unmask the number num in the corresponding row, column and box masks\n            mat[i][j] = 0;\n            row[i] &= ~(1 << num);\n            col[j] &= ~(1 << num);\n            box[i / 3 * 3 + j / 3] &= ~(1 << num);\n        }\n    }\n    return false;\n}\nvoid solveSudoku(vector<vector<int>> &mat) {\n  \tint n = mat.size();\n    vector<int> row(n, 0), col(n, 0), box(n, 0);\n    // Set the bits in bitmasks for values that are initital present\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (mat[i][j] != 0) {\n                row[i] |= (1 << mat[i][j]);\n                col[j] |= (1 << mat[i][j]);\n                box[ (i / 3) * 3 + j / 3] |= (1 << mat[i][j]);\n            }\n        }\n    }\n    sudokuSolverRec(mat, 0, 0, row, col, box);\n}\nint main() {\n    vector<vector<int>> mat = {\n        {3, 0, 6, 5, 0, 8, 4, 0, 0},\n      \t{5, 2, 0, 0, 0, 0, 0, 0, 0},\n      \t{0, 8, 7, 0, 0, 0, 0, 3, 1},\n        {0, 0, 3, 0, 1, 0, 0, 8, 0},\n      \t{9, 0, 0, 8, 6, 3, 0, 0, 5},\n      \t{0, 5, 0, 0, 9, 0, 6, 0, 0},\n        {1, 3, 0, 0, 0, 0, 2, 5, 0},\n      \t{0, 0, 0, 0, 0, 0, 0, 7, 4},\n      \t{0, 0, 5, 2, 0, 6, 3, 0, 0}};\n\tsolveSudoku(mat);\n  \tfor (int i = 0; i < mat.size(); i++) {\n        for (int j = 0; j < mat.size(); j++)\n            cout << mat[i][j] << \" \";\n        cout << endl;\n    }\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool isSafe(vector<vector<int>> &mat, int i, int j, int num,\n        vector<int> &row, vector<int> &col, vector<int> &box) {\n    if( (row[i] & (1 << num)) || (col[j] & (1 << num)) ||\n       \t\t\t\t\t(box[i / 3 * 3 + j / 3] & (1 << num)) )\n        return false;\n    return true;\n}\nbool sudokuSolverRec(vector<vector<int>> &mat, int i, int j,\n    \t\tvector<int> &row, vector<int> &col, vector<int> &box) {\n    int n = mat.size();\n\n    if (i == n - 1 && j == n)\n        return true;\n\n    if (j == n) {\n        i++;\n        j = 0;\n    }\n\n    if (mat[i][j] != 0)\n        return sudokuSolverRec(mat, i, j + 1, row, col, box);\n    for (int num = 1; num <= n; num++) {\n\n        if (isSafe(mat, i, j, num, row, col, box)) {\n            mat[i][j] = num;\n\n            row[i] |= (1 << num);\n            col[j] |= (1 << num);\n            box[i / 3 * 3 + j / 3] |= (1 << num);\n            if (sudokuSolverRec(mat, i, j + 1, row, col, box))\n                return true;\n\n            mat[i][j] = 0;\n            row[i] &= ~(1 << num);\n            col[j] &= ~(1 << num);\n            box[i / 3 * 3 + j / 3] &= ~(1 << num);\n        }\n    }\n    return false;\n}\nvoid solveSudoku(vector<vector<int>> &mat) {\n  \tint n = mat.size();\n    vector<int> row(n, 0), col(n, 0), box(n, 0);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (mat[i][j] != 0) {\n                row[i] |= (1 << mat[i][j]);\n                col[j] |= (1 << mat[i][j]);\n                box[ (i / 3) * 3 + j / 3] |= (1 << mat[i][j]);\n            }\n        }\n    }\n    sudokuSolverRec(mat, 0, 0, row, col, box);\n}\nint main() {\n    vector<vector<int>> mat = {\n        {3, 0, 6, 5, 0, 8, 4, 0, 0},\n      \t{5, 2, 0, 0, 0, 0, 0, 0, 0},\n      \t{0, 8, 7, 0, 0, 0, 0, 3, 1},\n        {0, 0, 3, 0, 1, 0, 0, 8, 0},\n      \t{9, 0, 0, 8, 6, 3, 0, 0, 5},\n      \t{0, 5, 0, 0, 9, 0, 6, 0, 0},\n        {1, 3, 0, 0, 0, 0, 2, 5, 0},\n      \t{0, 0, 0, 0, 0, 0, 0, 7, 4},\n      \t{0, 0, 5, 2, 0, 6, 3, 0, 0}};\n\tsolveSudoku(mat);\n  \tfor (int i = 0; i < mat.size(); i++) {\n        for (int j = 0; j < mat.size(); j++)\n            cout << mat[i][j] << \" \";\n        cout << endl;\n    }\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/sudoku-backtracking-7/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "def isSafe(mat, i, j, num, row, col, box):\n    if (row[i] & (1 << num)) or(col[j] & (1 << num)) or (box[i // 3 * 3 + j // 3] & (1 << num)):\n        return False\n    return True\ndef sudokuSolverRec(mat, i, j, row, col, box):\n    n = len(mat)\n    # base case: Reached nth column of last row\n    if i == n - 1 and j == n:\n        return True\n    # If reached last column of the row go to next row\n    if j == n:\n        i += 1\n        j = 0\n    # If cell is already occupied then move forward\n    if mat[i][j] != 0:\n        return sudokuSolverRec(mat, i, j + 1, row, col, box)\n    for num in range(1, n + 1):\n        # If it is safe to place num at current position\n        if isSafe(mat, i, j, num, row, col, box):\n            mat[i][j] = num\n            # Update masks for the corresponding row, column and box\n            row[i] |= (1 << num)\n            col[j] |= (1 << num)\n            box[i // 3 * 3 + j // 3] |= (1 << num)\n            if sudokuSolverRec(mat, i, j + 1, row, col, box):\n                return True\n            # Unmask the number num in the corresponding row, column and box masks\n            mat[i][j] = 0\n            row[i] &= ~(1 << num)\n            col[j] &= ~(1 << num)\n            box[i // 3 * 3 + j // 3] &= ~(1 << num)\n    return False\ndef solveSudoku(mat):\n    n = len(mat)\n    row = [0] * n\n    col = [0] * n\n    box = [0] * n\n    # Set the bits in bitmasks for values that are initially present\n    for i in range(n):\n        for j in range(n):\n            if mat[i][j] != 0:\n                row[i] |= (1 << mat[i][j])\n                col[j] |= (1 << mat[i][j])\n                box[(i // 3) * 3 + j // 3] |= (1 << mat[i][j])\n    sudokuSolverRec(mat, 0, 0, row, col, box)\nif __name__ == \"__main__\":\n    mat = [\n        [3, 0, 6, 5, 0, 8, 4, 0, 0],\n        [5, 2, 0, 0, 0, 0, 0, 0, 0],\n        [0, 8, 7, 0, 0, 0, 0, 3, 1],\n        [0, 0, 3, 0, 1, 0, 0, 8, 0],\n        [9, 0, 0, 8, 6, 3, 0, 0, 5],\n        [0, 5, 0, 0, 9, 0, 6, 0, 0],\n        [1, 3, 0, 0, 0, 0, 2, 5, 0],\n        [0, 0, 0, 0, 0, 0, 0, 7, 4],\n        [0, 0, 5, 2, 0, 6, 3, 0, 0]\n    ]\n    solveSudoku(mat)\n    for row in mat:\n        print(\" \".join(map(str, row)))",
    "code_without_comments": "def isSafe(mat, i, j, num, row, col, box):\n    if (row[i] & (1 << num)) or(col[j] & (1 << num)) or (box[i // 3 * 3 + j // 3] & (1 << num)):\n        return False\n    return True\ndef sudokuSolverRec(mat, i, j, row, col, box):\n    n = len(mat)\n\n    if i == n - 1 and j == n:\n        return True\n\n    if j == n:\n        i += 1\n        j = 0\n\n    if mat[i][j] != 0:\n        return sudokuSolverRec(mat, i, j + 1, row, col, box)\n    for num in range(1, n + 1):\n\n        if isSafe(mat, i, j, num, row, col, box):\n            mat[i][j] = num\n\n            row[i] |= (1 << num)\n            col[j] |= (1 << num)\n            box[i // 3 * 3 + j // 3] |= (1 << num)\n            if sudokuSolverRec(mat, i, j + 1, row, col, box):\n                return True\n\n            mat[i][j] = 0\n            row[i] &= ~(1 << num)\n            col[j] &= ~(1 << num)\n            box[i // 3 * 3 + j // 3] &= ~(1 << num)\n    return False\ndef solveSudoku(mat):\n    n = len(mat)\n    row = [0] * n\n    col = [0] * n\n    box = [0] * n\n\n    for i in range(n):\n        for j in range(n):\n            if mat[i][j] != 0:\n                row[i] |= (1 << mat[i][j])\n                col[j] |= (1 << mat[i][j])\n                box[(i // 3) * 3 + j // 3] |= (1 << mat[i][j])\n    sudokuSolverRec(mat, 0, 0, row, col, box)\nif __name__ == \"__main__\":\n    mat = [\n        [3, 0, 6, 5, 0, 8, 4, 0, 0],\n        [5, 2, 0, 0, 0, 0, 0, 0, 0],\n        [0, 8, 7, 0, 0, 0, 0, 3, 1],\n        [0, 0, 3, 0, 1, 0, 0, 8, 0],\n        [9, 0, 0, 8, 6, 3, 0, 0, 5],\n        [0, 5, 0, 0, 9, 0, 6, 0, 0],\n        [1, 3, 0, 0, 0, 0, 2, 5, 0],\n        [0, 0, 0, 0, 0, 0, 0, 7, 4],\n        [0, 0, 5, 2, 0, 6, 3, 0, 0]\n    ]\n    solveSudoku(mat)\n    for row in mat:\n        print(\" \".join(map(str, row)))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/sudoku-backtracking-7/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\n// 8 directions of knight moves\nint dx[8] = {2, 1, -1, -2, -2, -1, 1, 2};\nint dy[8] = {1, 2, 2, 1, -1, -2, -2, -1};\n// Utility function to check if the\n// move is valid\nbool isSafe(int x, int y, int n, vector<vector<int>> &board) {\n    return (x >= 0 && y >= 0 && x < n &&\n            y < n && board[x][y] == -1);\n}\n// Recursive function to solve Knight's Tour\nbool knightTourUtil(int x, int y, int step, int n, vector<vector<int>> &board) {\n    // If all squares are visited\n    if (step == n * n) {\n        return true;\n    }\n    // Try all 8 possible knight moves\n    for (int i = 0; i < 8; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (isSafe(nx, ny, n, board)) {\n            board[nx][ny] = step;\n            if (knightTourUtil(nx, ny, step + 1, n, board)) {\n                return true;\n            }\n            // Backtrack\n            board[nx][ny] = -1;\n        }\n    }\n    return false;\n}\n// Function to start Knight's Tour\nvector<vector<int>> knightTour(int n) {\n    vector<vector<int>> board(n, vector<int>(n, -1));\n    // Start from top-left corner\n    board[0][0] = 0;\n    if (knightTourUtil(0, 0, 1, n, board)) {\n        return board;\n    }\n    return {{-1}};\n}\nint main() {\n    int n = 5;\n    vector<vector<int>> res = knightTour(n);\n    for (auto &row : res) {\n        for (int val : row) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dx[8] = {2, 1, -1, -2, -2, -1, 1, 2};\nint dy[8] = {1, 2, 2, 1, -1, -2, -2, -1};\n\n\nbool isSafe(int x, int y, int n, vector<vector<int>> &board) {\n    return (x >= 0 && y >= 0 && x < n &&\n            y < n && board[x][y] == -1);\n}\n\nbool knightTourUtil(int x, int y, int step, int n, vector<vector<int>> &board) {\n\n    if (step == n * n) {\n        return true;\n    }\n\n    for (int i = 0; i < 8; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (isSafe(nx, ny, n, board)) {\n            board[nx][ny] = step;\n            if (knightTourUtil(nx, ny, step + 1, n, board)) {\n                return true;\n            }\n\n            board[nx][ny] = -1;\n        }\n    }\n    return false;\n}\n\nvector<vector<int>> knightTour(int n) {\n    vector<vector<int>> board(n, vector<int>(n, -1));\n\n    board[0][0] = 0;\n    if (knightTourUtil(0, 0, 1, n, board)) {\n        return board;\n    }\n    return {{-1}};\n}\nint main() {\n    int n = 5;\n    vector<vector<int>> res = knightTour(n);\n    for (auto &row : res) {\n        for (int val : row) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/the-knights-tour-problem/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "dx = [2, 1, -1, -2, -2, -1, 1, 2]\ndy = [1, 2, 2, 1, -1, -2, -2, -1]\ndef isSafe(x, y, n, board):\n    return x >= 0 and y >= 0 and x < n and y < n and board[x][y] == -1\ndef knightTourUtil(x, y, step, n, board):\n    # If all squares are visited\n    if step == n * n:\n        return True\n    # Try all 8 possible knight moves\n    for i in range(8):\n        nx = x + dx[i]\n        ny = y + dy[i]\n        if isSafe(nx, ny, n, board):\n            board[nx][ny] = step\n            if knightTourUtil(nx, ny, step + 1, n, board):\n                return True\n            # Backtrack\n            board[nx][ny] = -1\n    return False\ndef knightTour(n):\n    board = [[-1 for _ in range(n)] for _ in range(n)]\n    # Start from top-left corner\n    board[0][0] = 0\n    if knightTourUtil(0, 0, 1, n, board):\n        return board\n    return [[-1]]\nif __name__==\"__main__\":\n    n = 5\n    res = knightTour(n)\n    for row in res:\n        for val in row:\n            print(val, end=\" \")\n        print()",
    "code_without_comments": "dx = [2, 1, -1, -2, -2, -1, 1, 2]\ndy = [1, 2, 2, 1, -1, -2, -2, -1]\ndef isSafe(x, y, n, board):\n    return x >= 0 and y >= 0 and x < n and y < n and board[x][y] == -1\ndef knightTourUtil(x, y, step, n, board):\n\n    if step == n * n:\n        return True\n\n    for i in range(8):\n        nx = x + dx[i]\n        ny = y + dy[i]\n        if isSafe(nx, ny, n, board):\n            board[nx][ny] = step\n            if knightTourUtil(nx, ny, step + 1, n, board):\n                return True\n\n            board[nx][ny] = -1\n    return False\ndef knightTour(n):\n    board = [[-1 for _ in range(n)] for _ in range(n)]\n\n    board[0][0] = 0\n    if knightTourUtil(0, 0, 1, n, board):\n        return board\n    return [[-1]]\nif __name__==\"__main__\":\n    n = 5\n    res = knightTour(n)\n    for row in res:\n        for val in row:\n            print(val, end=\" \")\n        print()",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/the-knights-tour-problem/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n// Define 8 knight moves globally\nint dir[8][2] = {\n    {2, 1}, {1, 2}, {-1, 2}, {-2, 1},\n    {-2, -1}, {-1, -2}, {1, -2}, {2, -1}\n};\n// Count the number of onward moves from position (x, y)\nint countOptions(vector<vector<int>>& board, int x, int y) {\n    int count = 0;\n    int n = board.size();\n    for (int i = 0; i < 8; i++) {\n        int nx = x + dir[i][0];\n        int ny = y + dir[i][1];\n        if (nx >= 0 && ny >= 0 && nx < n && ny < n && board[nx][ny] == -1) {\n            count++;\n        }\n    }\n    return count;\n}\n// Generate valid knight moves from (x, y), sorted by fewest onward moves\nvector<vector<int>> getSortedMoves(vector<vector<int>>& board, int x, int y) {\n    vector<vector<int>> moveList;\n    for (int i = 0; i < 8; i++) {\n        int nx = x + dir[i][0];\n        int ny = y + dir[i][1];\n        if (nx >= 0 && ny >= 0 && nx < board.size() && ny < board.size() &&\n            board[nx][ny] == -1) {\n            int options = countOptions(board, nx, ny);\n            moveList.push_back({options, i});\n        }\n    }\n    // Sort using default vector<int> lexicographic comparison\n    sort(moveList.begin(), moveList.end());\n    return moveList;\n}\n// Recursive function to solve the Knight's Tour\nbool knightTourUtil(int x, int y, int step, int n, vector<vector<int>>& board) {\n    if (step == n * n) return true;\n    vector<vector<int>> moves = getSortedMoves(board, x, y);\n    for (vector<int> move : moves) {\n        int dirIdx = move[1];\n        int nx = x + dir[dirIdx][0];\n        int ny = y + dir[dirIdx][1];\n        board[nx][ny] = step;\n        if (knightTourUtil(nx, ny, step + 1, n, board))\n            return true;\n        // Backtrack\n        board[nx][ny] = -1;\n    }\n    return false;\n}\n// Function to start Knight's Tour\nvector<vector<int>> knightTour(int n) {\n    vector<vector<int>> board(n, vector<int>(n, -1));\n    // Start from top-left corner\n    board[0][0] = 0;\n    if (knightTourUtil(0, 0, 1, n, board)) {\n        return board;\n    }\n    return {{-1}};\n}\nint main() {\n    int n = 5;\n    vector<vector<int>> result = knightTour(n);\n    for (vector<int> row : result) {\n        for (int val : row) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint dir[8][2] = {\n    {2, 1}, {1, 2}, {-1, 2}, {-2, 1},\n    {-2, -1}, {-1, -2}, {1, -2}, {2, -1}\n};\n\nint countOptions(vector<vector<int>>& board, int x, int y) {\n    int count = 0;\n    int n = board.size();\n    for (int i = 0; i < 8; i++) {\n        int nx = x + dir[i][0];\n        int ny = y + dir[i][1];\n        if (nx >= 0 && ny >= 0 && nx < n && ny < n && board[nx][ny] == -1) {\n            count++;\n        }\n    }\n    return count;\n}\n\nvector<vector<int>> getSortedMoves(vector<vector<int>>& board, int x, int y) {\n    vector<vector<int>> moveList;\n    for (int i = 0; i < 8; i++) {\n        int nx = x + dir[i][0];\n        int ny = y + dir[i][1];\n        if (nx >= 0 && ny >= 0 && nx < board.size() && ny < board.size() &&\n            board[nx][ny] == -1) {\n            int options = countOptions(board, nx, ny);\n            moveList.push_back({options, i});\n        }\n    }\n\n    sort(moveList.begin(), moveList.end());\n    return moveList;\n}\n\nbool knightTourUtil(int x, int y, int step, int n, vector<vector<int>>& board) {\n    if (step == n * n) return true;\n    vector<vector<int>> moves = getSortedMoves(board, x, y);\n    for (vector<int> move : moves) {\n        int dirIdx = move[1];\n        int nx = x + dir[dirIdx][0];\n        int ny = y + dir[dirIdx][1];\n        board[nx][ny] = step;\n        if (knightTourUtil(nx, ny, step + 1, n, board))\n            return true;\n\n        board[nx][ny] = -1;\n    }\n    return false;\n}\n\nvector<vector<int>> knightTour(int n) {\n    vector<vector<int>> board(n, vector<int>(n, -1));\n\n    board[0][0] = 0;\n    if (knightTourUtil(0, 0, 1, n, board)) {\n        return board;\n    }\n    return {{-1}};\n}\nint main() {\n    int n = 5;\n    vector<vector<int>> result = knightTour(n);\n    for (vector<int> row : result) {\n        for (int val : row) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/the-knights-tour-problem/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "# Define 8 knight moves globally\ndir = [\n    [2, 1], [1, 2], [-1, 2], [-2, 1],\n    [-2, -1], [-1, -2], [1, -2], [2, -1]\n]\n# Count the number of onward moves from position (x, y)\ndef countOptions(board, x, y):\n    count, n = 0, len(board)\n    for dx, dy in dir:\n        nx, ny = x + dx, y + dy\n        if 0 <= nx < n and 0 <= ny < n and board[nx][ny] == -1:\n            count += 1\n    return count\n# Generate valid knight moves from (x, y), sorted by fewest onward moves\ndef getSortedMoves(board, x, y):\n    moveList, n = [], len(board)\n    for i in range(8):\n        nx, ny = x + dir[i][0], y + dir[i][1]\n        if 0 <= nx < n and 0 <= ny < n and board[nx][ny] == -1:\n            options = countOptions(board, nx, ny)\n            moveList.append([options, i])\n    moveList.sort()\n    return moveList\n# Recursive function to solve the Knight's Tour\ndef knightTourUtil(x, y, step, n, board):\n    if step == n * n:\n        return True\n    moves = getSortedMoves(board, x, y)\n    for move in moves:\n        dirIdx = move[1]\n        nx, ny = x + dir[dirIdx][0], y + dir[dirIdx][1]\n        board[nx][ny] = step\n        if knightTourUtil(nx, ny, step + 1, n, board):\n            return True\n        # Backtrack\n        board[nx][ny] = -1\n    return False\n# Function to start Knight's Tour\ndef knightTour(n):\n    board = [[-1]*n for _ in range(n)]\n    board[0][0] = 0\n    if knightTourUtil(0, 0, 1, n, board):\n        return board\n    return [[-1]]\nif __name__ == '__main__':\n    n = 5\n    result = knightTour(n)\n    for row in result:\n        print(*row)",
    "code_without_comments": "\ndir = [\n    [2, 1], [1, 2], [-1, 2], [-2, 1],\n    [-2, -1], [-1, -2], [1, -2], [2, -1]\n]\n\ndef countOptions(board, x, y):\n    count, n = 0, len(board)\n    for dx, dy in dir:\n        nx, ny = x + dx, y + dy\n        if 0 <= nx < n and 0 <= ny < n and board[nx][ny] == -1:\n            count += 1\n    return count\n\ndef getSortedMoves(board, x, y):\n    moveList, n = [], len(board)\n    for i in range(8):\n        nx, ny = x + dir[i][0], y + dir[i][1]\n        if 0 <= nx < n and 0 <= ny < n and board[nx][ny] == -1:\n            options = countOptions(board, nx, ny)\n            moveList.append([options, i])\n    moveList.sort()\n    return moveList\n# Recursive function to solve the Knight's Tour\ndef knightTourUtil(x, y, step, n, board):\n    if step == n * n:\n        return True\n    moves = getSortedMoves(board, x, y)\n    for move in moves:\n        dirIdx = move[1]\n        nx, ny = x + dir[dirIdx][0], y + dir[dirIdx][1]\n        board[nx][ny] = step\n        if knightTourUtil(nx, ny, step + 1, n, board):\n            return True\n\n        board[nx][ny] = -1\n    return False\n# Function to start Knight's Tour\ndef knightTour(n):\n    board = [[-1]*n for _ in range(n)]\n    board[0][0] = 0\n    if knightTourUtil(0, 0, 1, n, board):\n        return board\n    return [[-1]]\nif __name__ == '__main__':\n    n = 5\n    result = knightTour(n)\n    for row in result:\n        print(*row)",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/the-knights-tour-problem/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <bits/stdc++.h>\nusing namespace std;\nbool goodcolor(vector<int> adj[], vector<int> col){\n    for(int i=0;i<col.size();i++){\n       for(auto it:adj[i]){\n        if(i != it && col[i] == col[it])return false;\n       }\n    }\n    return true;\n}\nbool genratecolor(int i,vector<int> col, int m, vector<int> adj[]){\n    if(i>=col.size()){\n        if(goodcolor(adj, col))return true;\n        return false;\n    }\n    for(int j=0;j<m;j++){\n        col[i] = j;\n        if(genratecolor(i+1,col,m, adj)) return true;\n        col[i] = -1;\n   }\n   return false;\n}\nbool graphColoring(int v, vector<vector<int>> &edges, int m) {\n    vector<int> adj[v];\n    // Build adjacency list from edges\n    for (auto it : edges) {\n        adj[it[0]].push_back(it[1]);\n        adj[it[1]].push_back(it[0]);\n    }\n    vector<int> color(v, -1);\n    return genratecolor(0, color, m, adj);\n}\nint main() {\n    int V = 4;\n    vector<vector<int>> edges = {{0, 1}, {0, 2},{0,3}, {1, 3}, {2, 3}};\n    int m = 3;\n    // Check if the graph can be colored with m colors\n    // such that no adjacent nodes share the same color\n    cout << (graphColoring(V, edges, m) ? \"true\" : \"false\") << endl;\n    return 0;\n}",
    "code_without_comments": "#include <bits/stdc++.h>\nusing namespace std;\nbool goodcolor(vector<int> adj[], vector<int> col){\n    for(int i=0;i<col.size();i++){\n       for(auto it:adj[i]){\n        if(i != it && col[i] == col[it])return false;\n       }\n    }\n    return true;\n}\nbool genratecolor(int i,vector<int> col, int m, vector<int> adj[]){\n    if(i>=col.size()){\n        if(goodcolor(adj, col))return true;\n        return false;\n    }\n    for(int j=0;j<m;j++){\n        col[i] = j;\n        if(genratecolor(i+1,col,m, adj)) return true;\n        col[i] = -1;\n   }\n   return false;\n}\nbool graphColoring(int v, vector<vector<int>> &edges, int m) {\n    vector<int> adj[v];\n\n    for (auto it : edges) {\n        adj[it[0]].push_back(it[1]);\n        adj[it[1]].push_back(it[0]);\n    }\n    vector<int> color(v, -1);\n    return genratecolor(0, color, m, adj);\n}\nint main() {\n    int V = 4;\n    vector<vector<int>> edges = {{0, 1}, {0, 2},{0,3}, {1, 3}, {2, 3}};\n    int m = 3;\n\n\n    cout << (graphColoring(V, edges, m) ? \"true\" : \"false\") << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/m-coloring-problem-backtracking-5/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "def goodcolor(adj, col):\n    # Check if the coloring is valid\n    for i in range(len(col)):\n        for it in adj[i]:\n            if i != it and col[i] == col[it]:\n                return False\n    return True\ndef genratecolor(i, col, m, adj):\n    if i >= len(col):\n        if goodcolor(adj, col):\n            return True\n        return False\n    for j in range(m):\n        col[i] = j\n        if genratecolor(i + 1, col, m, adj):\n            return True\n        col[i] = -1\n    return False\ndef graphColoring(v, edges, m):\n    adj = [[] for _ in range(v)]\n    # Build adjacency list from edges\n    for u, w in edges:\n        adj[u].append(w)\n        adj[w].append(u)\n    color = [-1] * v\n    return genratecolor(0, color, m, adj)\n# Test\nV = 4\nedges = [[0, 1], [0, 2], [0,3], [1, 3], [2, 3]]\nm = 3\n# Check if the graph can be colored with m colors\n# such that no adjacent nodes share the same color\nprint(\"true\" if graphColoring(V, edges, m) else \"false\")",
    "code_without_comments": "def goodcolor(adj, col):\n\n    for i in range(len(col)):\n        for it in adj[i]:\n            if i != it and col[i] == col[it]:\n                return False\n    return True\ndef genratecolor(i, col, m, adj):\n    if i >= len(col):\n        if goodcolor(adj, col):\n            return True\n        return False\n    for j in range(m):\n        col[i] = j\n        if genratecolor(i + 1, col, m, adj):\n            return True\n        col[i] = -1\n    return False\ndef graphColoring(v, edges, m):\n    adj = [[] for _ in range(v)]\n\n    for u, w in edges:\n        adj[u].append(w)\n        adj[w].append(u)\n    color = [-1] * v\n    return genratecolor(0, color, m, adj)\n\nV = 4\nedges = [[0, 1], [0, 2], [0,3], [1, 3], [2, 3]]\nm = 3\n\n\nprint(\"true\" if graphColoring(V, edges, m) else \"false\")",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/m-coloring-problem-backtracking-5/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#include <bits/stdc++.h>\nusing namespace std;\n// Function to check if it's safe to color the current vertex\n// with the given color\nbool issafe(int vertex, int col, vector<int> adj[], vector<int> &color) {\n    for (auto it : adj[vertex]) {\n        // If adjacent vertex has the same color, not safe\n        if (color[it] != -1 && col == color[it])\n            return false;\n    }\n    return true;\n}\n// Recursive function to try all colorings\nbool cancolor(int vertex, int m, vector<int> adj[], vector<int> &color) {\n    // If all vertices are colored successfully\n    if (vertex == color.size())\n        return true;\n    // Try all colors from 0 to m-1\n    for (int i = 0; i < m; i++) {\n        if (issafe(vertex, i, adj, color)) {\n            color[vertex] = i;\n            if (cancolor(vertex + 1, m, adj, color))\n                // If the rest can be colored, return true\n                return true;\n            color[vertex] = -1;\n        }\n    }\n    // No valid coloring found\n    return false;\n}\nbool graphColoring(int v, vector<vector<int>> &edges, int m) {\n    vector<int> adj[v];\n    // Build adjacency list from edges\n    for (auto it : edges) {\n        adj[it[0]].push_back(it[1]);\n        adj[it[1]].push_back(it[0]);\n    }\n    vector<int> color(v, -1);\n    return cancolor(0, m, adj, color);\n}\nint main() {\n    int V = 4;\n    vector<vector<int>> edges = {{0, 1}, {0, 2},{0,3}, {1, 3}, {2, 3}};\n    int m = 3;\n    // Check if the graph can be colored with m colors\n    // such that no adjacent nodes share the same color\n    cout << (graphColoring(V, edges, m) ? \"true\" : \"false\") << endl;\n    return 0;\n}",
    "code_without_comments": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nbool issafe(int vertex, int col, vector<int> adj[], vector<int> &color) {\n    for (auto it : adj[vertex]) {\n\n        if (color[it] != -1 && col == color[it])\n            return false;\n    }\n    return true;\n}\n\nbool cancolor(int vertex, int m, vector<int> adj[], vector<int> &color) {\n\n    if (vertex == color.size())\n        return true;\n\n    for (int i = 0; i < m; i++) {\n        if (issafe(vertex, i, adj, color)) {\n            color[vertex] = i;\n            if (cancolor(vertex + 1, m, adj, color))\n\n                return true;\n            color[vertex] = -1;\n        }\n    }\n\n    return false;\n}\nbool graphColoring(int v, vector<vector<int>> &edges, int m) {\n    vector<int> adj[v];\n\n    for (auto it : edges) {\n        adj[it[0]].push_back(it[1]);\n        adj[it[1]].push_back(it[0]);\n    }\n    vector<int> color(v, -1);\n    return cancolor(0, m, adj, color);\n}\nint main() {\n    int V = 4;\n    vector<vector<int>> edges = {{0, 1}, {0, 2},{0,3}, {1, 3}, {2, 3}};\n    int m = 3;\n\n\n    cout << (graphColoring(V, edges, m) ? \"true\" : \"false\") << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/m-coloring-problem-backtracking-5/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "# Function to check if it's safe to color the current vertex\n# with the given color\ndef issafe(vertex, col, adj, color):\n    for it in adj[vertex]:\n        # If adjacent vertex has the same color, not safe\n        if color[it] != -1 and col == color[it]:\n            return False\n    return True\n# Recursive function to try all colorings\ndef cancolor(vertex, m, adj, color):\n    # If all vertices are colored successfully\n    if vertex == len(color):\n        return True\n    # Try all colors from 0 to m-1\n    for i in range(m):\n        if issafe(vertex, i, adj, color):\n            color[vertex] = i\n            if cancolor(vertex + 1, m, adj, color):\n                # If the rest can be colored, return true\n                return True\n            color[vertex] = -1  # Backtrack\n    # No valid coloring found\n    return False\n# Main function to set up the graph and call coloring logic\ndef graphColoring(v, edges, m):\n    adj = [[] for _ in range(v)]\n    # Build adjacency list from edges\n    for u, w in edges:\n        adj[u].append(w)\n        adj[w].append(u)\n    color = [-1] * v\n    return cancolor(0, m, adj, color)\n# Driver code\nif __name__ == \"__main__\":\n    V = 4\n    edges = [[0, 1], [0, 2], [0,3], [1, 3], [2, 3]]\n    m = 3\n    # Check if the graph can be colored with m colors\n    # such that no adjacent nodes share the same color\n    print(\"true\" if graphColoring(V, edges, m) else \"false\")",
    "code_without_comments": "# Function to check if it's safe to color the current vertex\n\ndef issafe(vertex, col, adj, color):\n    for it in adj[vertex]:\n\n        if color[it] != -1 and col == color[it]:\n            return False\n    return True\n\ndef cancolor(vertex, m, adj, color):\n\n    if vertex == len(color):\n        return True\n\n    for i in range(m):\n        if issafe(vertex, i, adj, color):\n            color[vertex] = i\n            if cancolor(vertex + 1, m, adj, color):\n\n                return True\n            color[vertex] = -1\n\n    return False\n\ndef graphColoring(v, edges, m):\n    adj = [[] for _ in range(v)]\n\n    for u, w in edges:\n        adj[u].append(w)\n        adj[w].append(u)\n    color = [-1] * v\n    return cancolor(0, m, adj, color)\n\nif __name__ == \"__main__\":\n    V = 4\n    edges = [[0, 1], [0, 2], [0,3], [1, 3], [2, 3]]\n    m = 3\n\n\n    print(\"true\" if graphColoring(V, edges, m) else \"false\")",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/m-coloring-problem-backtracking-5/",
    "complexity_weight": 2.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nvector<int> sieve(int n) {\n    // creation of boolean array\n    vector<bool> prime(n + 1, true);\n    for (int p = 2; p * p <= n; p++) {\n        if (prime[p] == true) {\n            // marking as false\n            for (int i = p * p; i <= n; i += p)\n                prime[i] = false;\n        }\n    }\n    vector<int> res;\n    for (int p = 2; p <= n; p++){\n        if (prime[p]){\n            res.push_back(p);\n        }\n    }\n    return res;\n}\nint main(){\n    int n = 35;\n    vector<int> res = sieve(n);\n    for(auto ele : res){\n        cout << ele << ' ';\n    }\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nvector<int> sieve(int n) {\n\n    vector<bool> prime(n + 1, true);\n    for (int p = 2; p * p <= n; p++) {\n        if (prime[p] == true) {\n\n            for (int i = p * p; i <= n; i += p)\n                prime[i] = false;\n        }\n    }\n    vector<int> res;\n    for (int p = 2; p <= n; p++){\n        if (prime[p]){\n            res.push_back(p);\n        }\n    }\n    return res;\n}\nint main(){\n    int n = 35;\n    vector<int> res = sieve(n);\n    for(auto ele : res){\n        cout << ele << ' ';\n    }\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/sieve-of-eratosthenes/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def sieve(n):\n    #Create a boolean list to track prime status of numbers\n    prime = [True] * (n + 1)\n    p = 2\n    # Sieve of Eratosthenes algorithm\n    while p * p <= n:\n        if prime[p]:\n            # Mark all multiples of p as non-prime\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    # Collect all prime numbers\n    res = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            res.append(p)\n    return res\nif __name__ == \"__main__\":\n    n = 35\n    res = sieve(n)\n    for ele in res:\n        print(ele, end=' ')",
    "code_without_comments": "def sieve(n):\n\n    prime = [True] * (n + 1)\n    p = 2\n\n    while p * p <= n:\n        if prime[p]:\n\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n\n    res = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            res.append(p)\n    return res\nif __name__ == \"__main__\":\n    n = 35\n    res = sieve(n)\n    for ele in res:\n        print(ele, end=' ')",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/sieve-of-eratosthenes/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "// C++ program to demonstrate working of\n// extended Euclidean Algorithm\n#include <bits/stdc++.h>\nusing namespace std;\n// Function to return\n// gcd of a and b\nint findGCD(int a, int b) {\n    if (a == 0)\n        return b;\n    return findGCD(b % a, a);\n}\nint main()  {\n    int a = 35, b = 15;\n    int g = findGCD(a, b);\n    cout << g << endl;\n    return 0;\n}",
    "code_without_comments": "\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n\nint findGCD(int a, int b) {\n    if (a == 0)\n        return b;\n    return findGCD(b % a, a);\n}\nint main()  {\n    int a = 35, b = 15;\n    int g = findGCD(a, b);\n    cout << g << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/euclidean-algorithms-basic-and-extended/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "// C program to demonstrate working of\n// extended Euclidean Algorithm\n#include <stdio.h>\n// Function to return\n// gcd of a and b\nint findGCD(int a, int b) {\n    if (a == 0)\n        return b;\n    return findGCD(b % a, a);\n}\nint main() {\n    int a = 35, b = 15;\n    int g = findGCD(a, b);\n    printf(\"%d\\n\", g);\n    return 0;\n}",
    "code_without_comments": "\n\n#include <stdio.h>\n\n\nint findGCD(int a, int b) {\n    if (a == 0)\n        return b;\n    return findGCD(b % a, a);\n}\nint main() {\n    int a = 35, b = 15;\n    int g = findGCD(a, b);\n    printf(\"%d\\n\", g);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/euclidean-algorithms-basic-and-extended/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "# Python program to demonstrate working of\n# extended Euclidean Algorithm\n# Function to return\n# gcd of a and b\ndef findGCD(a, b):\n    if a == 0:\n        return b\n    return findGCD(b % a, a)\n# Main function\ndef main():\n    a, b = 35, 15\n    g = findGCD(a, b)\n    print(g)\nif __name__ == \"__main__\":\n    main()",
    "code_without_comments": "\n\n\n\ndef findGCD(a, b):\n    if a == 0:\n        return b\n    return findGCD(b % a, a)\n\ndef main():\n    a, b = 35, 15\n    g = findGCD(a, b)\n    print(g)\nif __name__ == \"__main__\":\n    main()",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/euclidean-algorithms-basic-and-extended/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "// C++ program to demonstrate working of\n// extended Euclidean Algorithm\n#include <bits/stdc++.h>\nusing namespace std;\n// Function for extended Euclidean Algorithm\nint gcdExtended(int a, int b, int &x, int &y) {\n    // Base Case\n    if (a == 0)  {\n        x = 0;\n        y = 1;\n        return b;\n    }\n    int x1, y1;\n    int gcd = gcdExtended(b%a, a, x1, y1);\n    // Update x and y using results of\n    // recursive call\n    x = y1 - (b/a) * x1;\n    y = x1;\n    return gcd;\n}\nint findGCD(int a, int b) {\n    int x = 1, y = 1;\n    return gcdExtended(a, b, x, y);\n}\nint main()  {\n    int a = 35, b = 15;\n    int g = findGCD(a, b);\n    cout << g << endl;\n    return 0;\n}",
    "code_without_comments": "\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint gcdExtended(int a, int b, int &x, int &y) {\n\n    if (a == 0)  {\n        x = 0;\n        y = 1;\n        return b;\n    }\n    int x1, y1;\n    int gcd = gcdExtended(b%a, a, x1, y1);\n\n\n    x = y1 - (b/a) * x1;\n    y = x1;\n    return gcd;\n}\nint findGCD(int a, int b) {\n    int x = 1, y = 1;\n    return gcdExtended(a, b, x, y);\n}\nint main()  {\n    int a = 35, b = 15;\n    int g = findGCD(a, b);\n    cout << g << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/euclidean-algorithms-basic-and-extended/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "// C program to demonstrate working of\n// extended Euclidean Algorithm\n#include <stdio.h>\n// Function for extended Euclidean Algorithm\nint gcdExtended(int a, int b, int *x, int *y) {\n    // Base Case\n    if (a == 0) {\n        *x = 0;\n        *y = 1;\n        return b;\n    }\n    int x1, y1;\n    int gcd = gcdExtended(b % a, a, &x1, &y1);\n    // Update x and y using results of\n    // recursive call\n    *x = y1 - (b / a) * x1;\n    *y = x1;\n    return gcd;\n}\nint findGCD(int a, int b) {\n    int x = 1, y = 1;\n    return gcdExtended(a, b, &x, &y);\n}\nint main() {\n    int a = 35, b = 15;\n    int g = findGCD(a, b);\n    printf(\"%d\\n\", g);\n    return 0;\n}",
    "code_without_comments": "\n\n#include <stdio.h>\n\nint gcdExtended(int a, int b, int *x, int *y) {\n\n    if (a == 0) {\n        *x = 0;\n        *y = 1;\n        return b;\n    }\n    int x1, y1;\n    int gcd = gcdExtended(b % a, a, &x1, &y1);\n\n\n    *x = y1 - (b / a) * x1;\n    *y = x1;\n    return gcd;\n}\nint findGCD(int a, int b) {\n    int x = 1, y = 1;\n    return gcdExtended(a, b, &x, &y);\n}\nint main() {\n    int a = 35, b = 15;\n    int g = findGCD(a, b);\n    printf(\"%d\\n\", g);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/euclidean-algorithms-basic-and-extended/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "# Python program to demonstrate working of\n# extended Euclidean Algorithm\n# Function for extended Euclidean Algorithm\ndef gcdExtended(a, b, x, y):\n    # Base Case\n    if a == 0:\n        x[0] = 0\n        y[0] = 1\n        return b\n    x1, y1 = [0], [0]\n    gcd = gcdExtended(b % a, a, x1, y1)\n    # Update x and y using results of\n    # recursive call\n    x[0] = y1[0] - (b // a) * x1[0]\n    y[0] = x1[0]\n    return gcd\ndef findGCD(a, b):\n    x, y = [1], [1]\n    return gcdExtended(a, b, x, y)\n# Main function\ndef main():\n    a, b = 35, 15\n    g = findGCD(a, b)\n    print(g)\nif __name__ == \"__main__\":\n    main()",
    "code_without_comments": "\n\n\ndef gcdExtended(a, b, x, y):\n\n    if a == 0:\n        x[0] = 0\n        y[0] = 1\n        return b\n    x1, y1 = [0], [0]\n    gcd = gcdExtended(b % a, a, x1, y1)\n\n\n    x[0] = y1[0] - (b // a) * x1[0]\n    y[0] = x1[0]\n    return gcd\ndef findGCD(a, b):\n    x, y = [1], [1]\n    return gcdExtended(a, b, x, y)\n\ndef main():\n    a, b = 35, 15\n    g = findGCD(a, b)\n    print(g)\nif __name__ == \"__main__\":\n    main()",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/euclidean-algorithms-basic-and-extended/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include<iostream>\nusing namespace std;\nint powMod(int x, int n, int M) {\n    // Initialize result as 1 (since anything power 0 is 1)\n    long res = 1;\n    // n times to multiply x with itself\n    for(int i = 1; i <= n; i++) {\n        // Multiplying res with x\n        // and taking modulo to avoid overflow\n        res = (res * x) % M;\n    }\n    return res;\n}\nint main() {\n    int x = 3, n = 2, M = 4;\n    cout << powMod(x, n, M) << endl;\n    return 0;\n}",
    "code_without_comments": "#include<iostream>\nusing namespace std;\nint powMod(int x, int n, int M) {\n\n    long res = 1;\n\n    for(int i = 1; i <= n; i++) {\n\n\n        res = (res * x) % M;\n    }\n    return res;\n}\nint main() {\n    int x = 3, n = 2, M = 4;\n    cout << powMod(x, n, M) << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/modular-exponentiation-power-in-modular-arithmetic/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def powMod(x, n, M):\n    res = 1\n    # loop from 1 to n\n    for _ in range(n):\n        # Multiplying res with x\n        # and taking modulo to avoid overflow\n        res = (res * x) % M\n    return res\nif __name__ == \"__main__\":\n    x, n, M = 3, 2, 4\n    print(powMod(x, n, M))",
    "code_without_comments": "def powMod(x, n, M):\n    res = 1\n\n    for _ in range(n):\n\n\n        res = (res * x) % M\n    return res\nif __name__ == \"__main__\":\n    x, n, M = 3, 2, 4\n    print(powMod(x, n, M))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/modular-exponentiation-power-in-modular-arithmetic/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include<iostream>\nusing namespace std;\nint powMod(int x, int n, int M) {\n    int res = 1;\n    // Loop until exponent becomes 0\n    while(n >= 1) {\n        // n is odd, multiply result by current x and take modulo\n        if(n & 1) {\n            res = (res * x) % M;\n            // Reduce exponent by 1 to make it even\n            n--;\n        }\n        // n is even, square the base and halve the exponent\n        else {\n            x = (x * x) % M;\n            n /= 2;\n        }\n    }\n    return res;\n}\nint main() {\n    int x = 3, n = 2, M = 4;\n    cout << powMod(x, n, M) << endl;\n}",
    "code_without_comments": "#include<iostream>\nusing namespace std;\nint powMod(int x, int n, int M) {\n    int res = 1;\n\n    while(n >= 1) {\n\n        if(n & 1) {\n            res = (res * x) % M;\n\n            n--;\n        }\n\n        else {\n            x = (x * x) % M;\n            n /= 2;\n        }\n    }\n    return res;\n}\nint main() {\n    int x = 3, n = 2, M = 4;\n    cout << powMod(x, n, M) << endl;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/modular-exponentiation-power-in-modular-arithmetic/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def powMod(x, n, M):\n    res = 1\n    # Loop until exponent becomes 0\n    while n >= 1:\n        # n is odd, multiply result by current x and take modulo\n        if n % 2 == 1:\n            res = (res * x) % M\n            # Make n even\n            n -= 1\n        else:\n            # n is even, square the base and halve the exponent\n            x = (x * x) % M\n            n //= 2\n    return res\nif __name__ == \"__main__\":\n    x, n, M = 3, 2, 4\n    print(powMod(x, n, M))",
    "code_without_comments": "def powMod(x, n, M):\n    res = 1\n\n    while n >= 1:\n\n        if n % 2 == 1:\n            res = (res * x) % M\n\n            n -= 1\n        else:\n\n            x = (x * x) % M\n            n //= 2\n    return res\nif __name__ == \"__main__\":\n    x, n, M = 3, 2, 4\n    print(powMod(x, n, M))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/modular-exponentiation-power-in-modular-arithmetic/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <bits/stdc++.h>\nusing namespace std;\n/* Function to get no of set bits in binary\nrepresentation of positive integer n */\nunsigned int countSetBits(unsigned int n)\n{\n    unsigned int count = 0;\n    while (n) {\n        count += n & 1;\n        n >>= 1;\n    }\n    return count;\n}\nint main()\n{\n    int i = 9;\n    cout << countSetBits(i);\n    return 0;\n}",
    "code_without_comments": "#include <bits/stdc++.h>\nusing namespace std;\n\nunsigned int countSetBits(unsigned int n)\n{\n    unsigned int count = 0;\n    while (n) {\n        count += n & 1;\n        n >>= 1;\n    }\n    return count;\n}\nint main()\n{\n    int i = 9;\n    cout << countSetBits(i);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/count-set-bits-in-an-integer/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <stdio.h>\n/* Function to get no of set bits in binary\n   representation of positive integer n */\nunsigned int countSetBits(unsigned int n)\n{\n    unsigned int count = 0;\n    while (n) {\n        count += n & 1;\n        n >>= 1;\n    }\n    return count;\n}\nint main()\n{\n    int i = 9;\n    printf(\"%d\", countSetBits(i));\n    return 0;\n}",
    "code_without_comments": "#include <stdio.h>\n\nunsigned int countSetBits(unsigned int n)\n{\n    unsigned int count = 0;\n    while (n) {\n        count += n & 1;\n        n >>= 1;\n    }\n    return count;\n}\nint main()\n{\n    int i = 9;\n    printf(\"%d\", countSetBits(i));\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/count-set-bits-in-an-integer/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "import java.io.*;\n class GFG{\n    /* Function to get no of set\n    bits in binary representation\n    of positive integer n */\n    static int countSetBits(int n)\n    {\n        int count = 0;\n        while (n > 0) {\n            count += n & 1;\n            n >>= 1;\n        }\n        return count;\n    }\n    public static void main(String args[])\n    {\n        int i = 9;\n        System.out.println(countSetBits(i));\n    }\n}",
    "code_without_comments": "import java.io.*;\n class GFG{\n    /* Function to get no of set\n    bits in binary representation\n    of positive integer n */\n    static int countSetBits(int n)\n    {\n        int count = 0;\n        while (n > 0) {\n            count += n & 1;\n            n >>= 1;\n        }\n        return count;\n    }\n    public static void main(String args[])\n    {\n        int i = 9;\n        System.out.println(countSetBits(i));\n    }\n}",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/count-set-bits-in-an-integer/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "  # Function to get no of set\n  # bits in binary representation\n  # of positive integer n\ndef countSetBits(n):\n    count = 0\n    while (n):\n        count += n & 1\n        n >>= 1\n    return count\n# Program to test function countSetBits\nif __name__ == \"__main__\":\n    i = 9\n    print(countSetBits(i))",
    "code_without_comments": "\n\n\ndef countSetBits(n):\n    count = 0\n    while (n):\n        count += n & 1\n        n >>= 1\n    return count\n\nif __name__ == \"__main__\":\n    i = 9\n    print(countSetBits(i))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/count-set-bits-in-an-integer/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <bits/stdc++.h>\nusing namespace std;\n// recursive function to count set bits\nint countSetBits(int n)\n{\n    // base case\n    if (n == 0)\n        return 0;\n    else\n        // if last bit set add 1 else add 0\n        return (n & 1) + countSetBits(n >> 1);\n}\n// driver code\nint main()\n{\n    int n = 9;\n    // function calling\n    cout << countSetBits(n);\n    return 0;\n}",
    "code_without_comments": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countSetBits(int n)\n{\n\n    if (n == 0)\n        return 0;\n    else\n\n        return (n & 1) + countSetBits(n >> 1);\n}\n\nint main()\n{\n    int n = 9;\n\n    cout << countSetBits(n);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/count-set-bits-in-an-integer/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <stdio.h>\n// recursive function to count set bits\nint countSetBits(int n)\n{\n    // base case\n    if (n == 0)\n        return 0;\n    else\n        // if last bit set add 1 else add 0\n        return (n & 1) + countSetBits(n >> 1);\n}\n// driver code\nint main()\n{\n    int n = 9;\n    // function calling\n    printf(\"%d\", countSetBits(n));\n    return 0;\n}",
    "code_without_comments": "#include <stdio.h>\n\nint countSetBits(int n)\n{\n\n    if (n == 0)\n        return 0;\n    else\n\n        return (n & 1) + countSetBits(n >> 1);\n}\n\nint main()\n{\n    int n = 9;\n\n    printf(\"%d\", countSetBits(n));\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/count-set-bits-in-an-integer/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def countSetBits( n):\n    # base case\n    if (n == 0):\n        return 0\n    else:\n        # if last bit set add 1 else\n        # add 0\n        return (n & 1) + countSetBits(n >> 1)\n# Get value from user\nn = 9\n# Function calling\nprint( countSetBits(n))",
    "code_without_comments": "def countSetBits( n):\n\n    if (n == 0):\n        return 0\n    else:\n\n\n        return (n & 1) + countSetBits(n >> 1)\n\nn = 9\n\nprint( countSetBits(n))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/count-set-bits-in-an-integer/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\nusing namespace std;\nclass gfg {\n    /* Function to get no of set bits in binary\nrepresentation of passed binary no. */\npublic:\n    unsigned int countSetBits(int n)\n    {\n        unsigned int count = 0;\n        while (n) {\n            n &= (n - 1);\n            count++;\n        }\n        return count;\n    }\n};\n/* Program to test function countSetBits */\nint main()\n{\n    gfg g;\n    int i = 9;\n    cout << g.countSetBits(i);\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\nusing namespace std;\nclass gfg {\n\npublic:\n    unsigned int countSetBits(int n)\n    {\n        unsigned int count = 0;\n        while (n) {\n            n &= (n - 1);\n            count++;\n        }\n        return count;\n    }\n};\n\nint main()\n{\n    gfg g;\n    int i = 9;\n    cout << g.countSetBits(i);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/count-set-bits-in-an-integer/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <stdio.h>\n/* Function to get no of set bits in binary\n   representation of passed binary no. */\nunsigned int countSetBits(int n)\n{\n    unsigned int count = 0;\n    while (n) {\n        n &= (n - 1);\n        count++;\n    }\n    return count;\n}\n/* Program to test function countSetBits */\nint main()\n{\n    int i = 9;\n    printf(\"%d\", countSetBits(i));\n    getchar();\n    return 0;\n}",
    "code_without_comments": "#include <stdio.h>\n\nunsigned int countSetBits(int n)\n{\n    unsigned int count = 0;\n    while (n) {\n        n &= (n - 1);\n        count++;\n    }\n    return count;\n}\n\nint main()\n{\n    int i = 9;\n    printf(\"%d\", countSetBits(i));\n    getchar();\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/count-set-bits-in-an-integer/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "import java.io.*;\nclass GFG {\n    /* Function to get no of set\n    bits in binary representation\n    of passed binary no. */\n    static int countSetBits(int n)\n    {\n        int count = 0;\n        while (n > 0) {\n            n &= (n - 1);\n            count++;\n        }\n        return count;\n    }\n    public static void main(String args[])\n    {\n        int i = 9;\n        System.out.println(countSetBits(i));\n    }\n}\n// This code is contributed by Anshika Goyal.",
    "code_without_comments": "import java.io.*;\nclass GFG {\n    /* Function to get no of set\n    bits in binary representation\n    of passed binary no. */\n    static int countSetBits(int n)\n    {\n        int count = 0;\n        while (n > 0) {\n            n &= (n - 1);\n            count++;\n        }\n        return count;\n    }\n    public static void main(String args[])\n    {\n        int i = 9;\n        System.out.println(countSetBits(i));\n    }\n}\n// This code is contributed by Anshika Goyal.",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/count-set-bits-in-an-integer/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "# Function to get no of set bits in binary\n# representation of passed binary no. */\ndef countSetBits(n):\n    count = 0\n    while (n):\n        n &= (n-1)\n        count+= 1\n    return count\n# Program to test function countSetBits\ni = 9\nprint(countSetBits(i))",
    "code_without_comments": "\n\ndef countSetBits(n):\n    count = 0\n    while (n):\n        n &= (n-1)\n        count+= 1\n    return count\n\ni = 9\nprint(countSetBits(i))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/count-set-bits-in-an-integer/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <bits/stdc++.h>\nusing namespace std;\nint BitsSetTable256[256];\n// Function to initialise the lookup table\nvoid initialize()\n{\n    // To initially generate the\n    // table algorithmically\n    BitsSetTable256[0] = 0;\n    for (int i = 0; i < 256; i++)\n    {\n        BitsSetTable256[i] = (i & 1) +\n        BitsSetTable256[i / 2];\n    }\n}\n// Function to return the count\n// of set bits in n\nint countSetBits(int n)\n{\n    return (BitsSetTable256[n & 0xff] +\n            BitsSetTable256[(n >> 8) & 0xff] +\n            BitsSetTable256[(n >> 16) & 0xff] +\n            BitsSetTable256[n >> 24]);\n}\nint main()\n{\n    // Initialise the lookup table\n    initialize();\n    int n = 9;\n    cout << countSetBits(n);\n}",
    "code_without_comments": "#include <bits/stdc++.h>\nusing namespace std;\nint BitsSetTable256[256];\n\nvoid initialize()\n{\n\n\n    BitsSetTable256[0] = 0;\n    for (int i = 0; i < 256; i++)\n    {\n        BitsSetTable256[i] = (i & 1) +\n        BitsSetTable256[i / 2];\n    }\n}\n\n\nint countSetBits(int n)\n{\n    return (BitsSetTable256[n & 0xff] +\n            BitsSetTable256[(n >> 8) & 0xff] +\n            BitsSetTable256[(n >> 16) & 0xff] +\n            BitsSetTable256[n >> 24]);\n}\nint main()\n{\n\n    initialize();\n    int n = 9;\n    cout << countSetBits(n);\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/count-set-bits-in-an-integer/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "BitsSetTable256 = [0] * 256\n# Function to initialise the lookup table\ndef initialize():\n    # To initially generate the\n    # table algorithmically\n    BitsSetTable256[0] = 0\n    for i in range(256):\n        BitsSetTable256[i] = (i & 1) + BitsSetTable256[i // 2]\n# Function to return the count\n# of set bits in n\ndef countSetBits(n):\n    return (BitsSetTable256[n & 0xff] +\n            BitsSetTable256[(n >> 8) & 0xff] +\n            BitsSetTable256[(n >> 16) & 0xff] +\n            BitsSetTable256[n >> 24])\nif __name__ == \"__main__\":\n    initialize()\n    n = 9\n    print(countSetBits(n))",
    "code_without_comments": "BitsSetTable256 = [0] * 256\n\ndef initialize():\n\n\n    BitsSetTable256[0] = 0\n    for i in range(256):\n        BitsSetTable256[i] = (i & 1) + BitsSetTable256[i // 2]\n\n\ndef countSetBits(n):\n    return (BitsSetTable256[n & 0xff] +\n            BitsSetTable256[(n >> 8) & 0xff] +\n            BitsSetTable256[(n >> 16) & 0xff] +\n            BitsSetTable256[n >> 24])\nif __name__ == \"__main__\":\n    initialize()\n    n = 9\n    print(countSetBits(n))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/count-set-bits-in-an-integer/",
    "complexity_weight": 1.0
  }
]