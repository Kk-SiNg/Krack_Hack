[
  {
    "code_with_comments": "# Python program to solve chocolate distribution\n# problem using Sliding Window\ndef findMinDiff(arr, m):\n    n = len(arr)\n    # Sort the given packets\n    arr.sort()\n    minDiff = float('inf')\n    for i in range(n - m + 1):\n        # calculate difference of current window\n        diff = arr[i + m - 1] - arr[i]\n        # if current difference is smaller\n        # then update the minimum difference\n        if diff < minDiff:\n            minDiff = diff\n    return minDiff\nif __name__ == \"__main__\":\n    arr = [7, 3, 2, 4, 9, 12, 56]\n    m = 3\n    print(findMinDiff(arr, m))",
    "code_without_comments": "\n\ndef findMinDiff(arr, m):\n    n = len(arr)\n\n    arr.sort()\n    minDiff = float('inf')\n    for i in range(n - m + 1):\n\n        diff = arr[i + m - 1] - arr[i]\n\n\n        if diff < minDiff:\n            minDiff = diff\n    return minDiff\nif __name__ == \"__main__\":\n    arr = [7, 3, 2, 4, 9, 12, 56]\n    m = 3\n    print(findMinDiff(arr, m))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/chocolate-distribution-problem/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nint missingNum(vector<int>& arr) {\n    int n = arr.size() + 1;\n    // Iterate from 1 to n and check\n    // if the current number is present\n    for (int i = 1; i <= n; i++) {\n        bool found = false;\n        for (int j = 0; j < n - 1; j++) {\n            if (arr[j] == i) {\n                found = true;\n                break;\n            }\n        }\n        // If the current number is not present\n        if (!found)\n            return i;\n    }\n    return -1;\n}\nint main() {\n    vector<int> arr = {8, 2, 4, 5, 3, 7, 1};\n    cout << missingNum(arr) << endl;\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nint missingNum(vector<int>& arr) {\n    int n = arr.size() + 1;\n\n\n    for (int i = 1; i <= n; i++) {\n        bool found = false;\n        for (int j = 0; j < n - 1; j++) {\n            if (arr[j] == i) {\n                found = true;\n                break;\n            }\n        }\n\n        if (!found)\n            return i;\n    }\n    return -1;\n}\nint main() {\n    vector<int> arr = {8, 2, 4, 5, 3, 7, 1};\n    cout << missingNum(arr) << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/find-the-missing-number/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def missingNum(arr):\n    n = len(arr) + 1\n    # Iterate from 1 to n and check\n    # if the current number is present\n    for i in range(1, n + 1):\n        found = False\n        for j in range(n - 1):\n            if arr[j] == i:\n                found = True\n                break\n        # If the current number is not present\n        if not found:\n            return i\n    return -1\nif __name__ == '__main__':\n    arr = [8, 2, 4, 5, 3, 7, 1]\n    print(missingNum(arr))",
    "code_without_comments": "def missingNum(arr):\n    n = len(arr) + 1\n\n\n    for i in range(1, n + 1):\n        found = False\n        for j in range(n - 1):\n            if arr[j] == i:\n                found = True\n                break\n\n        if not found:\n            return i\n    return -1\nif __name__ == '__main__':\n    arr = [8, 2, 4, 5, 3, 7, 1]\n    print(missingNum(arr))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/find-the-missing-number/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nint missingNum(vector<int> &arr) {\n    int n = arr.size() + 1;\n    // Create hash array of size n+1\n    vector<int> hash(n + 1, 0);\n    // Store frequencies of elements\n    for (int i = 0; i < n - 1; i++) {\n        hash[arr[i]]++;\n    }\n    // Find the missing number\n    for (int i = 1; i <= n; i++) {\n        if (hash[i] == 0) {\n            return i;\n        }\n    }\n    return -1;\n}\nint main() {\n    vector<int> arr = {8, 2, 4, 5, 3, 7, 1};\n    int res = missingNum(arr);\n    cout << res << endl;\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nint missingNum(vector<int> &arr) {\n    int n = arr.size() + 1;\n\n    vector<int> hash(n + 1, 0);\n\n    for (int i = 0; i < n - 1; i++) {\n        hash[arr[i]]++;\n    }\n\n    for (int i = 1; i <= n; i++) {\n        if (hash[i] == 0) {\n            return i;\n        }\n    }\n    return -1;\n}\nint main() {\n    vector<int> arr = {8, 2, 4, 5, 3, 7, 1};\n    int res = missingNum(arr);\n    cout << res << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/find-the-missing-number/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def missingNum(arr):\n    n = len(arr) + 1\n    # Create hash array of size n+1\n    hash = [0] * (n + 1)\n    # Store frequencies of elements\n    for i in range(n - 1):\n        hash[arr[i]] += 1\n    # Find the missing number\n    for i in range(1, n + 1):\n        if hash[i] == 0:\n            return i\n    return -1\nif __name__ == '__main__':\n    arr = [8, 2, 4, 5, 3, 7, 1]\n    res = missingNum(arr)\n    print(res)",
    "code_without_comments": "def missingNum(arr):\n    n = len(arr) + 1\n\n    hash = [0] * (n + 1)\n\n    for i in range(n - 1):\n        hash[arr[i]] += 1\n\n    for i in range(1, n + 1):\n        if hash[i] == 0:\n            return i\n    return -1\nif __name__ == '__main__':\n    arr = [8, 2, 4, 5, 3, 7, 1]\n    res = missingNum(arr)\n    print(res)",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/find-the-missing-number/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nint missingNum(vector<int> &arr) {\n    int n = arr.size() + 1;\n    // Calculate the sum of array elements\n    int sum = 0;\n    for (int i = 0; i < n - 1; i++) {\n        sum += arr[i];\n    }\n    // Calculate the expected sum\n    long long expSum = (n *1LL* (n + 1)) / 2;\n    // Return the missing number\n    return expSum - sum;\n}\nint main() {\n    vector<int> arr = {8, 2, 4, 5, 3, 7, 1};\n    cout << missingNum(arr);\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nint missingNum(vector<int> &arr) {\n    int n = arr.size() + 1;\n\n    int sum = 0;\n    for (int i = 0; i < n - 1; i++) {\n        sum += arr[i];\n    }\n\n    long long expSum = (n *1LL* (n + 1)) / 2;\n\n    return expSum - sum;\n}\nint main() {\n    vector<int> arr = {8, 2, 4, 5, 3, 7, 1};\n    cout << missingNum(arr);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/find-the-missing-number/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def missingNum(arr):\n    n = len(arr) + 1\n    # Calculate the sum of array elements\n    totalSum = sum(arr)\n    # Calculate the expected sum\n    expSum = n * (n + 1) // 2\n    # Return the missing number\n    return expSum - totalSum\nif __name__ == '__main__':\n    arr = [8, 2, 4, 5, 3, 7, 1]\n    print(missingNum(arr))",
    "code_without_comments": "def missingNum(arr):\n    n = len(arr) + 1\n\n    totalSum = sum(arr)\n\n    expSum = n * (n + 1) // 2\n\n    return expSum - totalSum\nif __name__ == '__main__':\n    arr = [8, 2, 4, 5, 3, 7, 1]\n    print(missingNum(arr))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/find-the-missing-number/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nint missingNum(vector<int>& arr) {\n    int n = arr.size() + 1;\n    int xor1 = 0, xor2 = 0;\n    // XOR all array elements\n    for (int i = 0; i < n - 1; i++) {\n        xor2 ^= arr[i];\n    }\n    // XOR all numbers from 1 to n\n    for (int i = 1; i <= n; i++) {\n        xor1 ^= i;\n    }\n    // Missing number is the XOR of xor1 and xor2\n    return xor1 ^ xor2;\n}\nint main() {\n    vector<int> arr = {8, 2, 4, 5, 3, 7, 1};\n    int res = missingNum(arr);\n    cout << res << endl;\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nint missingNum(vector<int>& arr) {\n    int n = arr.size() + 1;\n    int xor1 = 0, xor2 = 0;\n\n    for (int i = 0; i < n - 1; i++) {\n        xor2 ^= arr[i];\n    }\n\n    for (int i = 1; i <= n; i++) {\n        xor1 ^= i;\n    }\n\n    return xor1 ^ xor2;\n}\nint main() {\n    vector<int> arr = {8, 2, 4, 5, 3, 7, 1};\n    int res = missingNum(arr);\n    cout << res << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/find-the-missing-number/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def missingNum(arr):\n    n = len(arr) + 1\n    xor1 = 0\n    xor2 = 0\n    # XOR all array elements\n    for i in range(n - 1):\n        xor2 ^= arr[i]\n    # XOR all numbers from 1 to n\n    for i in range(1, n + 1):\n        xor1 ^= i\n    # Missing number is the XOR of xor1 and xor2\n    return xor1 ^ xor2\nif __name__ == '__main__':\n    arr = [8, 2, 4, 5, 3, 7, 1]\n    res = missingNum(arr)\n    print(res)",
    "code_without_comments": "def missingNum(arr):\n    n = len(arr) + 1\n    xor1 = 0\n    xor2 = 0\n\n    for i in range(n - 1):\n        xor2 ^= arr[i]\n\n    for i in range(1, n + 1):\n        xor1 ^= i\n\n    return xor1 ^ xor2\nif __name__ == '__main__':\n    arr = [8, 2, 4, 5, 3, 7, 1]\n    res = missingNum(arr)\n    print(res)",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/find-the-missing-number/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nvoid mergeArrays(vector<int>& arr1, vector<int>& arr2) {\n    int n = arr1.size();\n    int m = arr2.size();\n    // temporary array to store all elements\n    // from arr1 and arr2\n    vector<int> merged(n + m);\n    // copy elements from arr1 and arr2 into merged array\n    for (int i = 0; i < n; ++i) {\n        merged[i] = arr1[i];\n    }\n    for (int j = 0; j < m; ++j) {\n        merged[n + j] = arr2[j];\n    }\n    // dort the merged array\n    sort(merged.begin(), merged.end());\n    // distribute first n elements to arr1\n    for (int i = 0; i < n; ++i) {\n        arr1[i] = merged[i];\n    }\n    // distribute remaining m elements to arr2\n    for (int j = 0; j < m; ++j) {\n        arr2[j] = merged[n + j];\n    }\n}\nint main() {\n    vector<int> arr1 = {1, 3, 5, 7};\n    vector<int> arr2 = {2, 4, 6, 8};\n    mergeArrays(arr1, arr2);\n    for (int num : arr1) {\n        cout << num << ' ';\n    }\n    cout << endl;\n    for (int num : arr2) {\n        cout << num << ' ';\n    }\n    cout << endl;\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nvoid mergeArrays(vector<int>& arr1, vector<int>& arr2) {\n    int n = arr1.size();\n    int m = arr2.size();\n\n\n    vector<int> merged(n + m);\n\n    for (int i = 0; i < n; ++i) {\n        merged[i] = arr1[i];\n    }\n    for (int j = 0; j < m; ++j) {\n        merged[n + j] = arr2[j];\n    }\n\n    sort(merged.begin(), merged.end());\n\n    for (int i = 0; i < n; ++i) {\n        arr1[i] = merged[i];\n    }\n\n    for (int j = 0; j < m; ++j) {\n        arr2[j] = merged[n + j];\n    }\n}\nint main() {\n    vector<int> arr1 = {1, 3, 5, 7};\n    vector<int> arr2 = {2, 4, 6, 8};\n    mergeArrays(arr1, arr2);\n    for (int num : arr1) {\n        cout << num << ' ';\n    }\n    cout << endl;\n    for (int num : arr2) {\n        cout << num << ' ';\n    }\n    cout << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/merge-two-sorted-arrays/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <stdio.h>\n#include <stdlib.h>\n// function to compare two integers (used in qsort)\nint compare(void* a, void* b) {\n    return (*(int*)a - *(int*)b);\n}\n// function to merge two sorted arrays in-place\nvoid mergeArrays(int arr1[], int arr2[], int n, int m) {\n    // temporary array to store all elements\n    // from arr1 and arr2\n    int* merged = (int*)malloc((n + m) * sizeof(int));\n    // copy elements from arr1 and arr2 into merged array\n    for (int i = 0; i < n; ++i) {\n        merged[i] = arr1[i];\n    }\n    for (int j = 0; j < m; ++j) {\n        merged[n + j] = arr2[j];\n    }\n    // sort the merged array\n    qsort(merged, n + m, sizeof(int), compare);\n    // distribute first n elements to arr1\n    for (int i = 0; i < n; ++i) {\n        arr1[i] = merged[i];\n    }\n    // distribute remaining m elements to arr2\n    for (int j = 0; j < m; ++j) {\n        arr2[j] = merged[n + j];\n    }\n    // free dynamically allocated memory\n    free(merged);\n}\nint main() {\n    int arr1[] = {1, 3, 5, 7};\n    int arr2[] = {2, 4, 6, 8};\n    int n = sizeof(arr1) / sizeof(arr1[0]);\n    int m = sizeof(arr2) / sizeof(arr2[0]);\n    mergeArrays(arr1, arr2, n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d \", arr1[i]);\n    }\n    printf(\"\\n\");\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d \", arr2[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}",
    "code_without_comments": "#include <stdio.h>\n#include <stdlib.h>\n\nint compare(void* a, void* b) {\n    return (*(int*)a - *(int*)b);\n}\n\nvoid mergeArrays(int arr1[], int arr2[], int n, int m) {\n\n\n    int* merged = (int*)malloc((n + m) * sizeof(int));\n\n    for (int i = 0; i < n; ++i) {\n        merged[i] = arr1[i];\n    }\n    for (int j = 0; j < m; ++j) {\n        merged[n + j] = arr2[j];\n    }\n\n    qsort(merged, n + m, sizeof(int), compare);\n\n    for (int i = 0; i < n; ++i) {\n        arr1[i] = merged[i];\n    }\n\n    for (int j = 0; j < m; ++j) {\n        arr2[j] = merged[n + j];\n    }\n\n    free(merged);\n}\nint main() {\n    int arr1[] = {1, 3, 5, 7};\n    int arr2[] = {2, 4, 6, 8};\n    int n = sizeof(arr1) / sizeof(arr1[0]);\n    int m = sizeof(arr2) / sizeof(arr2[0]);\n    mergeArrays(arr1, arr2, n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d \", arr1[i]);\n    }\n    printf(\"\\n\");\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d \", arr2[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/merge-two-sorted-arrays/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def mergeArrays(arr1, arr2):\n    n = len(arr1)\n    m = len(arr2)\n    # temporary array to store all elements\n    # from arr1 and arr2\n    merged = [0] * (n + m)\n    # copy elements from arr1 and arr2\n    # into merged array\n    for i in range(n):\n        merged[i] = arr1[i]\n    for j in range(m):\n        merged[n + j] = arr2[j]\n    # sort the merged array\n    merged.sort()\n    # distribute first n elements to arr1\n    for i in range(n):\n        arr1[i] = merged[i]\n    # distribute remaining m elements to arr2\n    for j in range(m):\n        arr2[j] = merged[n + j]\nif __name__ == \"__main__\":\n    arr1 = [1, 3, 5, 7]\n    arr2 = [2, 4, 6, 8]\n    mergeArrays(arr1, arr2)\n    print(*arr1)\n    print(*arr2)",
    "code_without_comments": "def mergeArrays(arr1, arr2):\n    n = len(arr1)\n    m = len(arr2)\n\n\n    merged = [0] * (n + m)\n\n\n    for i in range(n):\n        merged[i] = arr1[i]\n    for j in range(m):\n        merged[n + j] = arr2[j]\n\n    merged.sort()\n\n    for i in range(n):\n        arr1[i] = merged[i]\n\n    for j in range(m):\n        arr2[j] = merged[n + j]\nif __name__ == \"__main__\":\n    arr1 = [1, 3, 5, 7]\n    arr2 = [2, 4, 6, 8]\n    mergeArrays(arr1, arr2)\n    print(*arr1)\n    print(*arr2)",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/merge-two-sorted-arrays/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nvoid mergeArrays(vector<int>& arr1, vector<int>& arr2) {\n    int n = arr1.size();\n    int m = arr2.size();\n    int i = 0, j = 0;\n    // temporary array to store merged result\n    vector<int> merged;\n    // merge elements in sorted order\n    while (i < n && j < m) {\n        if (arr1[i] <= arr2[j]) {\n            merged.push_back(arr1[i++]);\n        } else {\n            merged.push_back(arr2[j++]);\n        }\n    }\n    // copy remaining elements from arr1\n    while (i < n) merged.push_back(arr1[i++]);\n    // copy remaining elements from arr2\n    while (j < m) merged.push_back(arr2[j++]);\n    // copy first n to arr1\n    for (int k = 0; k < n; ++k) {\n        arr1[k] = merged[k];\n    }\n    // copy remaining m to arr2\n    for (int k = 0; k < m; ++k) {\n        arr2[k] = merged[n + k];\n    }\n}\nint main() {\n    vector<int> arr1 = {1, 3, 5, 7};\n    vector<int> arr2 = {2, 4, 6, 8};\n    mergeArrays(arr1, arr2);\n    for (int num : arr1) cout << num << ' ';\n    cout << endl;\n    for (int num : arr2) cout << num << ' ';\n    cout << endl;\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nvoid mergeArrays(vector<int>& arr1, vector<int>& arr2) {\n    int n = arr1.size();\n    int m = arr2.size();\n    int i = 0, j = 0;\n\n    vector<int> merged;\n\n    while (i < n && j < m) {\n        if (arr1[i] <= arr2[j]) {\n            merged.push_back(arr1[i++]);\n        } else {\n            merged.push_back(arr2[j++]);\n        }\n    }\n\n    while (i < n) merged.push_back(arr1[i++]);\n\n    while (j < m) merged.push_back(arr2[j++]);\n\n    for (int k = 0; k < n; ++k) {\n        arr1[k] = merged[k];\n    }\n\n    for (int k = 0; k < m; ++k) {\n        arr2[k] = merged[n + k];\n    }\n}\nint main() {\n    vector<int> arr1 = {1, 3, 5, 7};\n    vector<int> arr2 = {2, 4, 6, 8};\n    mergeArrays(arr1, arr2);\n    for (int num : arr1) cout << num << ' ';\n    cout << endl;\n    for (int num : arr2) cout << num << ' ';\n    cout << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/merge-two-sorted-arrays/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <stdio.h>\n#include <stdlib.h>\nvoid mergeArrays(int arr1[], int arr2[], int n, int m) {\n    int* merged = (int*)malloc((n + m) * sizeof(int));\n    int i = 0, j = 0, k = 0;\n    // merge elements in sorted order\n    while (i < n && j < m) {\n        if (arr1[i] <= arr2[j]) {\n            merged[k++] = arr1[i++];\n        } else {\n            merged[k++] = arr2[j++];\n        }\n    }\n    // copy remaining elements from arr1\n    while (i < n) merged[k++] = arr1[i++];\n    // copy remaining elements from arr2\n    while (j < m) merged[k++] = arr2[j++];\n    // copy first n to arr1\n    for (i = 0; i < n; ++i)\n            arr1[i] = merged[i];\n    // copy remaining m to arr2\n    for (j = 0; j < m; ++j)\n            arr2[j] = merged[n + j];\n    free(merged);\n}\nint main() {\n    int arr1[] = {1, 3, 5, 7};\n    int arr2[] = {2, 4, 6, 8};\n    int n = sizeof(arr1) / sizeof(arr1[0]);\n    int m = sizeof(arr2) / sizeof(arr2[0]);\n    mergeArrays(arr1, arr2, n, m);\n    for (int i = 0; i < n; ++i) printf(\"%d \", arr1[i]);\n    printf(\"\\n\");\n    for (int i = 0; i < m; ++i) printf(\"%d \", arr2[i]);\n    printf(\"\\n\");\n    return 0;\n}",
    "code_without_comments": "#include <stdio.h>\n#include <stdlib.h>\nvoid mergeArrays(int arr1[], int arr2[], int n, int m) {\n    int* merged = (int*)malloc((n + m) * sizeof(int));\n    int i = 0, j = 0, k = 0;\n\n    while (i < n && j < m) {\n        if (arr1[i] <= arr2[j]) {\n            merged[k++] = arr1[i++];\n        } else {\n            merged[k++] = arr2[j++];\n        }\n    }\n\n    while (i < n) merged[k++] = arr1[i++];\n\n    while (j < m) merged[k++] = arr2[j++];\n\n    for (i = 0; i < n; ++i)\n            arr1[i] = merged[i];\n\n    for (j = 0; j < m; ++j)\n            arr2[j] = merged[n + j];\n    free(merged);\n}\nint main() {\n    int arr1[] = {1, 3, 5, 7};\n    int arr2[] = {2, 4, 6, 8};\n    int n = sizeof(arr1) / sizeof(arr1[0]);\n    int m = sizeof(arr2) / sizeof(arr2[0]);\n    mergeArrays(arr1, arr2, n, m);\n    for (int i = 0; i < n; ++i) printf(\"%d \", arr1[i]);\n    printf(\"\\n\");\n    for (int i = 0; i < m; ++i) printf(\"%d \", arr2[i]);\n    printf(\"\\n\");\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/merge-two-sorted-arrays/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def mergeArrays(arr1, arr2):\n    n = len(arr1)\n    m = len(arr2)\n    i = j = 0\n    # temporary array to store merged result\n    merged = []\n    # merge elements in sorted order\n    while i < n and j < m:\n        if arr1[i] <= arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    # copy remaining elements from arr1\n    while i < n:\n        merged.append(arr1[i])\n        i += 1\n    # copy remaining elements from arr2\n    while j < m:\n        merged.append(arr2[j])\n        j += 1\n    # copy first n to arr1\n    for i in range(n):\n        arr1[i] = merged[i]\n    # copy remaining m to arr2\n    for j in range(m):\n        arr2[j] = merged[n + j]\nif __name__ == \"__main__\":\n    arr1 = [1, 3, 5, 7]\n    arr2 = [2, 4, 6, 8]\n    mergeArrays(arr1, arr2)\n    print(*arr1)\n    print(*arr2)",
    "code_without_comments": "def mergeArrays(arr1, arr2):\n    n = len(arr1)\n    m = len(arr2)\n    i = j = 0\n\n    merged = []\n\n    while i < n and j < m:\n        if arr1[i] <= arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n\n    while i < n:\n        merged.append(arr1[i])\n        i += 1\n\n    while j < m:\n        merged.append(arr2[j])\n        j += 1\n\n    for i in range(n):\n        arr1[i] = merged[i]\n\n    for j in range(m):\n        arr2[j] = merged[n + j]\nif __name__ == \"__main__\":\n    arr1 = [1, 3, 5, 7]\n    arr2 = [2, 4, 6, 8]\n    mergeArrays(arr1, arr2)\n    print(*arr1)\n    print(*arr2)",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/merge-two-sorted-arrays/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\n// Recursive function to find max profit\nint maxProfitRec(vector<int> &price, int start, int end) {\n    int res = 0;\n    // Try every possible pair of buy (i) and sell (j)\n    for (int i = start; i < end; i++) {\n        for (int j = i + 1; j <= end; j++) {\n            // Valid transaction if selling price > buying price\n            if (price[j] > price[i]) {\n                // Current profit + profit from left and right parts\n                int curr = (price[j] - price[i]) +\n                           maxProfitRec(price, start, i - 1) +\n                           maxProfitRec(price, j + 1, end);\n                res = max(res, curr);\n            }\n        }\n    }\n    return res;\n}\nint maxProfit(vector<int> &prices) {\n    return maxProfitRec(prices, 0, prices.size() - 1);\n}\nint main() {\n    vector<int> prices = {100, 180, 260, 310, 40, 535, 695};\n    cout << maxProfit(prices);\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint maxProfitRec(vector<int> &price, int start, int end) {\n    int res = 0;\n\n    for (int i = start; i < end; i++) {\n        for (int j = i + 1; j <= end; j++) {\n\n            if (price[j] > price[i]) {\n\n                int curr = (price[j] - price[i]) +\n                           maxProfitRec(price, start, i - 1) +\n                           maxProfitRec(price, j + 1, end);\n                res = max(res, curr);\n            }\n        }\n    }\n    return res;\n}\nint maxProfit(vector<int> &prices) {\n    return maxProfitRec(prices, 0, prices.size() - 1);\n}\nint main() {\n    vector<int> prices = {100, 180, 260, 310, 40, 535, 695};\n    cout << maxProfit(prices);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/stock-buy-sell/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def maxProfitRec(price, start, end):\n    res = 0\n    # Try every possible pair of buy (i) and sell (j)\n    for i in range(start, end):\n        for j in range(i + 1, end + 1):\n            # Valid transaction if selling price > buying price\n            if price[j] > price[i]:\n                curr = (price[j] - price[i]) + \\\n                       maxProfitRec(price, start, i - 1) + \\\n                       maxProfitRec(price, j + 1, end)\n                res = max(res, curr)\n    return res\ndef maxProfit(prices):\n    return maxProfitRec(prices, 0, len(prices) - 1)\nif __name__ == \"__main__\":\n    prices = [100, 180, 260, 310, 40, 535, 695]\n    print(maxProfit(prices))",
    "code_without_comments": "def maxProfitRec(price, start, end):\n    res = 0\n\n    for i in range(start, end):\n        for j in range(i + 1, end + 1):\n\n            if price[j] > price[i]:\n                curr = (price[j] - price[i]) + \\\n                       maxProfitRec(price, start, i - 1) + \\\n                       maxProfitRec(price, j + 1, end)\n                res = max(res, curr)\n    return res\ndef maxProfit(prices):\n    return maxProfitRec(prices, 0, len(prices) - 1)\nif __name__ == \"__main__\":\n    prices = [100, 180, 260, 310, 40, 535, 695]\n    print(maxProfit(prices))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/stock-buy-sell/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nint maxProfit(vector<int>& prices) {\n    int n = prices.size();\n     // Local Minima\n    int lMin = prices[0];\n    // Local Maxima\n    int lMax = prices[0];\n    int res = 0;\n    int i = 0;\n    while (i < n - 1) {\n        // Find local minima\n        while (i < n - 1 && prices[i] >= prices[i + 1]) { i++; }\n        lMin = prices[i];\n        // Local Maxima\n        while (i < n - 1 && prices[i] <= prices[i + 1]) { i++; }\n        lMax = prices[i];\n        // Add current profit\n        res = res + (lMax - lMin);\n    }\n    return res;\n}\nint main() {\n    vector<int> prices = {100, 180, 260, 310, 40, 535, 695};\n    cout << maxProfit(prices);\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nint maxProfit(vector<int>& prices) {\n    int n = prices.size();\n\n    int lMin = prices[0];\n\n    int lMax = prices[0];\n    int res = 0;\n    int i = 0;\n    while (i < n - 1) {\n\n        while (i < n - 1 && prices[i] >= prices[i + 1]) { i++; }\n        lMin = prices[i];\n\n        while (i < n - 1 && prices[i] <= prices[i + 1]) { i++; }\n        lMax = prices[i];\n\n        res = res + (lMax - lMin);\n    }\n    return res;\n}\nint main() {\n    vector<int> prices = {100, 180, 260, 310, 40, 535, 695};\n    cout << maxProfit(prices);\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/stock-buy-sell/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <stdio.h>\nint maxProfit(int prices[], int n) {\n    int lMin = prices[0];\n    int lMax = prices[0];\n    int res = 0;\n    int i = 0;\n    while (i < n - 1) {\n        // Find local minima\n        while (i < n - 1 && prices[i] >= prices[i + 1]) { i++; }\n        lMin = prices[i];\n        // Local Maxima\n        while (i < n - 1 && prices[i] <= prices[i + 1]) { i++; }\n        lMax = prices[i];\n        // Add current profit\n        res += (lMax - lMin);\n    }\n    return res;\n}\n// Driver Code\nint main() {\n    int prices[] = {100, 180, 260, 310, 40, 535, 695};\n    int n = sizeof(prices) / sizeof(prices[0]);\n    printf(\"%d\\n\", maxProfit(prices, n));\n    return 0;\n}",
    "code_without_comments": "#include <stdio.h>\nint maxProfit(int prices[], int n) {\n    int lMin = prices[0];\n    int lMax = prices[0];\n    int res = 0;\n    int i = 0;\n    while (i < n - 1) {\n\n        while (i < n - 1 && prices[i] >= prices[i + 1]) { i++; }\n        lMin = prices[i];\n\n        while (i < n - 1 && prices[i] <= prices[i + 1]) { i++; }\n        lMax = prices[i];\n\n        res += (lMax - lMin);\n    }\n    return res;\n}\n\nint main() {\n    int prices[] = {100, 180, 260, 310, 40, 535, 695};\n    int n = sizeof(prices) / sizeof(prices[0]);\n    printf(\"%d\\n\", maxProfit(prices, n));\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/stock-buy-sell/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def maxProfit(prices):\n    n = len(prices)\n    lMin = prices[0]\n    lMax = prices[0]\n    res = 0\n    i = 0\n    while i < n - 1:\n        # Find local minima\n        while i < n - 1 and prices[i] >= prices[i + 1]:\n            i += 1\n        lMin = prices[i]\n        # Local Maxima\n        while i < n - 1 and prices[i] <= prices[i + 1]:\n            i += 1\n        lMax = prices[i]\n        # Add current profit\n        res += (lMax - lMin)\n    return res\nif __name__ == \"__main__\":\n    prices = [100, 180, 260, 310, 40, 535, 695]\n    print(maxProfit(prices))",
    "code_without_comments": "def maxProfit(prices):\n    n = len(prices)\n    lMin = prices[0]\n    lMax = prices[0]\n    res = 0\n    i = 0\n    while i < n - 1:\n\n        while i < n - 1 and prices[i] >= prices[i + 1]:\n            i += 1\n        lMin = prices[i]\n\n        while i < n - 1 and prices[i] <= prices[i + 1]:\n            i += 1\n        lMax = prices[i]\n\n        res += (lMax - lMin)\n    return res\nif __name__ == \"__main__\":\n    prices = [100, 180, 260, 310, 40, 535, 695]\n    print(maxProfit(prices))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/stock-buy-sell/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nint maxProfit(const vector<int>& prices) {\n    int res = 0;\n    // Keep on adding the difference between\n    // adjacent when the prices a\n    for (int i = 1; i < prices.size(); i++) {\n        if (prices[i] > prices[i - 1])\n            res += prices[i] - prices[i - 1];\n    }\n    return res;\n}\nint main() {\n    vector<int> prices = { 100, 180, 260, 310, 40, 535, 695 };\n    cout << maxProfit(prices) << endl;\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nint maxProfit(const vector<int>& prices) {\n    int res = 0;\n\n\n    for (int i = 1; i < prices.size(); i++) {\n        if (prices[i] > prices[i - 1])\n            res += prices[i] - prices[i - 1];\n    }\n    return res;\n}\nint main() {\n    vector<int> prices = { 100, 180, 260, 310, 40, 535, 695 };\n    cout << maxProfit(prices) << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/stock-buy-sell/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <stdio.h>\nint maxProfit(const int* prices, int n) {\n    int res = 0;\n    // Keep on adding the difference between\n    // adjacent when the prices a\n    for (int i = 1; i < n; i++) {\n        if (prices[i] > prices[i - 1])\n            res += prices[i] - prices[i - 1];\n    }\n    return res;\n}\nint main() {\n    int prices[] = { 100, 180, 260, 310, 40, 535, 695 };\n    int size = sizeof(prices) / sizeof(prices[0]);\n    printf(\"%d\\n\", maxProfit(prices, size));\n    return 0;\n}",
    "code_without_comments": "#include <stdio.h>\nint maxProfit(const int* prices, int n) {\n    int res = 0;\n\n\n    for (int i = 1; i < n; i++) {\n        if (prices[i] > prices[i - 1])\n            res += prices[i] - prices[i - 1];\n    }\n    return res;\n}\nint main() {\n    int prices[] = { 100, 180, 260, 310, 40, 535, 695 };\n    int size = sizeof(prices) / sizeof(prices[0]);\n    printf(\"%d\\n\", maxProfit(prices, size));\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/stock-buy-sell/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def maxProfit(prices):\n    res = 0\n    # Keep on adding the difference between\n    # adjacent when the prices a\n    for i in range(1, len(prices)):\n        if prices[i] > prices[i - 1]:\n            res += prices[i] - prices[i - 1]\n    return res\nif __name__ == \"__main__\":\n    prices = [100, 180, 260, 310, 40, 535, 695]\n    print(maxProfit(prices))",
    "code_without_comments": "def maxProfit(prices):\n    res = 0\n\n\n    for i in range(1, len(prices)):\n        if prices[i] > prices[i - 1]:\n            res += prices[i] - prices[i - 1]\n    return res\nif __name__ == \"__main__\":\n    prices = [100, 180, 260, 310, 40, 535, 695]\n    print(maxProfit(prices))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/stock-buy-sell/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "vector<int> computeLPSArray(string &pattern) {\n    int n = pattern.size();\n    vector<int> lps(n, 0);\n    // length of the previous longest prefix suffix\n    int len = 0;\n    int i = 1;\n    while (i < n) {\n        if (pattern[i] == pattern[len]) {\n            len++;\n            lps[i] = len;\n            i++;\n        } else {\n            if (len != 0) {\n                // fall back in the pattern\n                len = lps[len - 1];\n            } else {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n    return lps;\n}",
    "code_without_comments": "vector<int> computeLPSArray(string &pattern) {\n    int n = pattern.size();\n    vector<int> lps(n, 0);\n\n    int len = 0;\n    int i = 1;\n    while (i < n) {\n        if (pattern[i] == pattern[len]) {\n            len++;\n            lps[i] = len;\n            i++;\n        } else {\n            if (len != 0) {\n\n                len = lps[len - 1];\n            } else {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n    return lps;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def computeLPSArray(pattern):\n    n = len(pattern)\n    lps = [0] * n\n    # length of the previous longest prefix suffix\n    len = 0\n    i = 1\n    while i < n:\n        if pattern[i] == pattern[len]:\n            len += 1\n            lps[i] = len\n            i += 1\n        else:\n            if len != 0:\n                # fall back in the pattern\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    return lps\nif __name__ == \"__main__\":\n    pattern = \"ababcab\"\n    print(computeLPSArray(pattern))",
    "code_without_comments": "def computeLPSArray(pattern):\n    n = len(pattern)\n    lps = [0] * n\n\n    len = 0\n    i = 1\n    while i < n:\n        if pattern[i] == pattern[len]:\n            len += 1\n            lps[i] = len\n            i += 1\n        else:\n            if len != 0:\n\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    return lps\nif __name__ == \"__main__\":\n    pattern = \"ababcab\"\n    print(computeLPSArray(pattern))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nvoid constructLps(string &pat, vector<int> &lps) {\n    // len stores the length of longest prefix which\n    // is also a suffix for the previous index\n    int len = 0;\n    // lps[0] is always 0\n    lps[0] = 0;\n    int i = 1;\n    while (i < pat.length()) {\n        // If characters match, increment the size of lps\n        if (pat[i] == pat[len]) {\n            len++;\n            lps[i] = len;\n            i++;\n        }\n        // If there is a mismatch\n        else {\n            if (len != 0) {\n                // Update len to the previous lps value\n                // to avoid reduntant comparisons\n                len = lps[len - 1];\n            }\n            else {\n                // If no matching prefix found, set lps[i] to 0\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n}\nvector<int> search(string &pat, string &txt) {\n    int n = txt.length();\n    int m = pat.length();\n    vector<int> lps(m);\n    vector<int> res;\n    constructLps(pat, lps);\n    // Pointers i and j, for traversing\n    // the text and pattern\n    int i = 0;\n    int j = 0;\n    while (i < n) {\n        // If characters match, move both pointers forward\n        if (txt[i] == pat[j]) {\n            i++;\n            j++;\n            // If the entire pattern is matched\n            // store the start index in result\n            if (j == m) {\n                res.push_back(i - j);\n                // Use LPS of previous index to\n                // skip unnecessary comparisons\n                j = lps[j - 1];\n            }\n        }\n        // If there is a mismatch\n        else {\n            // Use lps value of previous index\n            // to avoid redundant comparisons\n            if (j != 0)\n                j = lps[j - 1];\n            else\n                i++;\n        }\n    }\n    return res;\n}\nint main() {\n    string txt = \"aabaacaadaabaaba\";\n    string pat = \"aaba\";\n    vector<int> res = search(pat, txt);\n    for (int i = 0; i < res.size(); i++)\n        cout << res[i] << \" \";\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nvoid constructLps(string &pat, vector<int> &lps) {\n\n\n    int len = 0;\n\n    lps[0] = 0;\n    int i = 1;\n    while (i < pat.length()) {\n\n        if (pat[i] == pat[len]) {\n            len++;\n            lps[i] = len;\n            i++;\n        }\n\n        else {\n            if (len != 0) {\n\n\n                len = lps[len - 1];\n            }\n            else {\n\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n}\nvector<int> search(string &pat, string &txt) {\n    int n = txt.length();\n    int m = pat.length();\n    vector<int> lps(m);\n    vector<int> res;\n    constructLps(pat, lps);\n\n\n    int i = 0;\n    int j = 0;\n    while (i < n) {\n\n        if (txt[i] == pat[j]) {\n            i++;\n            j++;\n\n\n            if (j == m) {\n                res.push_back(i - j);\n\n\n                j = lps[j - 1];\n            }\n        }\n\n        else {\n\n\n            if (j != 0)\n                j = lps[j - 1];\n            else\n                i++;\n        }\n    }\n    return res;\n}\nint main() {\n    string txt = \"aabaacaadaabaaba\";\n    string pat = \"aaba\";\n    vector<int> res = search(pat, txt);\n    for (int i = 0; i < res.size(); i++)\n        cout << res[i] << \" \";\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def constructLps(pat, lps):\n    # len stores the length of longest prefix which\n    # is also a suffix for the previous index\n    len_ = 0\n    m = len(pat)\n    # lps[0] is always 0\n    lps[0] = 0\n    i = 1\n    while i < m:\n        # If characters match, increment the size of lps\n        if pat[i] == pat[len_]:\n            len_ += 1\n            lps[i] = len_\n            i += 1\n        # If there is a mismatch\n        else:\n            if len_ != 0:\n                # Update len to the previous lps value\n                # to avoid redundant comparisons\n                len_ = lps[len_ - 1]\n            else:\n                # If no matching prefix found, set lps[i] to 0\n                lps[i] = 0\n                i += 1\ndef search(pat, txt):\n    n = len(txt)\n    m = len(pat)\n    lps = [0] * m\n    res = []\n    constructLps(pat, lps)\n    # Pointers i and j, for traversing\n    # the text and pattern\n    i = 0\n    j = 0\n    while i < n:\n        # If characters match, move both pointers forward\n        if txt[i] == pat[j]:\n            i += 1\n            j += 1\n            # If the entire pattern is matched\n            # store the start index in result\n            if j == m:\n                res.append(i - j)\n                # Use LPS of previous index to\n                # skip unnecessary comparisons\n                j = lps[j - 1]\n        # If there is a mismatch\n        else:\n            # Use lps value of previous index\n            # to avoid redundant comparisons\n            if j != 0:\n                j = lps[j - 1]\n            else:\n                i += 1\n    return res\nif __name__ == \"__main__\":\n    txt = \"aabaacaadaabaaba\"\n    pat = \"aaba\"\n    res = search(pat, txt)\n    for i in range(len(res)):\n        print(res[i], end=\" \")",
    "code_without_comments": "def constructLps(pat, lps):\n\n\n    len_ = 0\n    m = len(pat)\n\n    lps[0] = 0\n    i = 1\n    while i < m:\n\n        if pat[i] == pat[len_]:\n            len_ += 1\n            lps[i] = len_\n            i += 1\n\n        else:\n            if len_ != 0:\n\n\n                len_ = lps[len_ - 1]\n            else:\n\n                lps[i] = 0\n                i += 1\ndef search(pat, txt):\n    n = len(txt)\n    m = len(pat)\n    lps = [0] * m\n    res = []\n    constructLps(pat, lps)\n\n\n    i = 0\n    j = 0\n    while i < n:\n\n        if txt[i] == pat[j]:\n            i += 1\n            j += 1\n\n\n            if j == m:\n                res.append(i - j)\n\n\n                j = lps[j - 1]\n\n        else:\n\n\n            if j != 0:\n                j = lps[j - 1]\n            else:\n                i += 1\n    return res\nif __name__ == \"__main__\":\n    txt = \"aabaacaadaabaaba\"\n    pat = \"aaba\"\n    res = search(pat, txt)\n    for i in range(len(res)):\n        print(res[i], end=\" \")",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "class RabinKarpHash {\nprivate:\n    const int mod = 1e9 + 7;\n    const int base = 31;\n    vector<int> hash;\n    vector<int> power;\n    // modular addition\n    int add(int a, int b) {\n        a += b;\n        if (a >= mod) a -= mod;\n        return a;\n    }\n    // modular subtraction\n    int sub(int a, int b) {\n        a -= b;\n        if (a < 0) a += mod;\n        return a;\n    }\n    // modular multiplication\n    int mul(int a, int b) {\n        return (int)((1LL * a * b) % mod);\n    }\n    // convert character to int\n    // ('a' = 1, ..., 'z' = 26)\n    int charToInt(char c) {\n        return c - 'a' + 1;\n    }\npublic:\n    // constructor: precomputes prefix hashes and powers\n    RabinKarpHash(string &s) {\n        int n = s.size();\n        hash.resize(n);\n        power.resize(n);\n        hash[0] = charToInt(s[0]);\n        power[0] = 1;\n        for (int i = 1; i < n; ++i) {\n            hash[i] = add(mul(hash[i - 1], base), charToInt(s[i]));\n            power[i] = mul(power[i - 1], base);\n        }\n    }\n    // get hash of substring s[l...r] in O(1)\n    int getSubHash(int l, int r) {\n        int h = hash[r];\n        if (l > 0) {\n            h = sub(h, mul(hash[l - 1], power[r - l + 1]));\n        }\n        return h;\n    }\n};",
    "code_without_comments": "class RabinKarpHash {\nprivate:\n    const int mod = 1e9 + 7;\n    const int base = 31;\n    vector<int> hash;\n    vector<int> power;\n\n    int add(int a, int b) {\n        a += b;\n        if (a >= mod) a -= mod;\n        return a;\n    }\n\n    int sub(int a, int b) {\n        a -= b;\n        if (a < 0) a += mod;\n        return a;\n    }\n\n    int mul(int a, int b) {\n        return (int)((1LL * a * b) % mod);\n    }\n\n\n    int charToInt(char c) {\n        return c - 'a' + 1;\n    }\npublic:\n\n    RabinKarpHash(string &s) {\n        int n = s.size();\n        hash.resize(n);\n        power.resize(n);\n        hash[0] = charToInt(s[0]);\n        power[0] = 1;\n        for (int i = 1; i < n; ++i) {\n            hash[i] = add(mul(hash[i - 1], base), charToInt(s[i]));\n            power[i] = mul(power[i - 1], base);\n        }\n    }\n\n    int getSubHash(int l, int r) {\n        int h = hash[r];\n        if (l > 0) {\n            h = sub(h, mul(hash[l - 1], power[r - l + 1]));\n        }\n        return h;\n    }\n};",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/rabin-karp-algorithm-for-pattern-searching/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "class RabinKarpHash:\n    def __init__(self, s):\n        self.mod = int(1e9) + 7\n        self.base = 31\n        n = len(s)\n        self.hash = [0] * n\n        self.power = [0] * n\n        # convert character to int\n        # ('a' = 1, ..., 'z' = 26)\n        def charToInt(c):\n            return ord(c) - ord('a') + 1\n        self.hash[0] = charToInt(s[0])\n        self.power[0] = 1\n        for i in range(1, n):\n            self.hash[i] = (self.hash[i - 1] * self.base \\\n                                + charToInt(s[i])) % self.mod\n            self.power[i] = (self.power[i - 1] * \\\n                                    self.base) % self.mod\n    # get hash of substring s[l...r] in O(1)\n    def getSubHash(self, l, r):\n        h = self.hash[r]\n        if l > 0:\n            h = (h - self.hash[l - 1] * \\\n                        self.power[r - l + 1]) % self.mod\n            if h < 0:\n                h += self.mod\n        return h",
    "code_without_comments": "class RabinKarpHash:\n    def __init__(self, s):\n        self.mod = int(1e9) + 7\n        self.base = 31\n        n = len(s)\n        self.hash = [0] * n\n        self.power = [0] * n\n\n        # ('a' = 1, ..., 'z' = 26)\n        def charToInt(c):\n            return ord(c) - ord('a') + 1\n        self.hash[0] = charToInt(s[0])\n        self.power[0] = 1\n        for i in range(1, n):\n            self.hash[i] = (self.hash[i - 1] * self.base \\\n                                + charToInt(s[i])) % self.mod\n            self.power[i] = (self.power[i - 1] * \\\n                                    self.base) % self.mod\n\n    def getSubHash(self, l, r):\n        h = self.hash[r]\n        if l > 0:\n            h = (h - self.hash[l - 1] * \\\n                        self.power[r - l + 1]) % self.mod\n            if h < 0:\n                h += self.mod\n        return h",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/rabin-karp-algorithm-for-pattern-searching/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\nclass RabinKarpHash {\nprivate:\n    const int mod = 1e9 + 7;\n    const int base = 31;\n    vector<int> hash;\n    vector<int> power;\n    // modular addition\n    int add(int a, int b) {\n        a += b;\n        if (a >= mod) a -= mod;\n        return a;\n    }\n    // modular subtraction\n    int sub(int a, int b) {\n        a -= b;\n        if (a < 0) a += mod;\n        return a;\n    }\n    // modular multiplication\n    int mul(int a, int b) {\n        return (int)((1LL * a * b) % mod);\n    }\n    // convert character to int\n    // ('a' = 1, ..., 'z' = 26)\n    int charToInt(char c) {\n        return c - 'a' + 1;\n    }\npublic:\n    // constructor: precomputes prefix hashes and powers\n    RabinKarpHash(string &s) {\n        int n = s.size();\n        hash.resize(n);\n        power.resize(n);\n        hash[0] = charToInt(s[0]);\n        power[0] = 1;\n        for (int i = 1; i < n; ++i) {\n            hash[i] = add(mul(hash[i - 1], base), charToInt(s[i]));\n            power[i] = mul(power[i - 1], base);\n        }\n    }\n    // get hash of substring s[l...r] in O(1)\n    int getSubHash(int l, int r) {\n        int h = hash[r];\n        if (l > 0) {\n            h = sub(h, mul(hash[l - 1], power[r - l + 1]));\n        }\n        return h;\n    }\n};\n// Rabin-Karp search using hash class\nvector<int> searchPattern(string &text, string &pattern) {\n    int n = text.size(), m = pattern.size();\n    RabinKarpHash textHash(text);\n    RabinKarpHash patHash(pattern);\n    int patternHash = patHash.getSubHash(0, m - 1);\n    vector<int> result;\n    for (int i = 0; i <= n - m; i++) {\n        int subHash = textHash.getSubHash(i, i + m - 1);\n        if (subHash == patternHash) {\n            result.push_back(i);\n        }\n    }\n    return result;\n}\nint main() {\n    string txt = \"geeksforgeeks\";\n    string pat = \"geek\";\n    vector<int> positions = searchPattern(txt, pat);\n    for (int idx : positions) {\n        cout << idx << \" \";\n    }\n    cout << endl;\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\nclass RabinKarpHash {\nprivate:\n    const int mod = 1e9 + 7;\n    const int base = 31;\n    vector<int> hash;\n    vector<int> power;\n\n    int add(int a, int b) {\n        a += b;\n        if (a >= mod) a -= mod;\n        return a;\n    }\n\n    int sub(int a, int b) {\n        a -= b;\n        if (a < 0) a += mod;\n        return a;\n    }\n\n    int mul(int a, int b) {\n        return (int)((1LL * a * b) % mod);\n    }\n\n\n    int charToInt(char c) {\n        return c - 'a' + 1;\n    }\npublic:\n\n    RabinKarpHash(string &s) {\n        int n = s.size();\n        hash.resize(n);\n        power.resize(n);\n        hash[0] = charToInt(s[0]);\n        power[0] = 1;\n        for (int i = 1; i < n; ++i) {\n            hash[i] = add(mul(hash[i - 1], base), charToInt(s[i]));\n            power[i] = mul(power[i - 1], base);\n        }\n    }\n\n    int getSubHash(int l, int r) {\n        int h = hash[r];\n        if (l > 0) {\n            h = sub(h, mul(hash[l - 1], power[r - l + 1]));\n        }\n        return h;\n    }\n};\n\nvector<int> searchPattern(string &text, string &pattern) {\n    int n = text.size(), m = pattern.size();\n    RabinKarpHash textHash(text);\n    RabinKarpHash patHash(pattern);\n    int patternHash = patHash.getSubHash(0, m - 1);\n    vector<int> result;\n    for (int i = 0; i <= n - m; i++) {\n        int subHash = textHash.getSubHash(i, i + m - 1);\n        if (subHash == patternHash) {\n            result.push_back(i);\n        }\n    }\n    return result;\n}\nint main() {\n    string txt = \"geeksforgeeks\";\n    string pat = \"geek\";\n    vector<int> positions = searchPattern(txt, pat);\n    for (int idx : positions) {\n        cout << idx << \" \";\n    }\n    cout << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/rabin-karp-algorithm-for-pattern-searching/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "class RabinKarpHash:\n    def __init__(self, s):\n        self.mod = 10**9 + 7\n        self.base = 31\n        n = len(s)\n        self.hash = [0] * n\n        self.power = [0] * n\n        # convert character to int\n        # ('a' = 1, ..., 'z' = 26)\n        def charToInt(c):\n            return ord(c) - ord('a') + 1\n        self.hash[0] = charToInt(s[0])\n        self.power[0] = 1\n        for i in range(1, n):\n            self.hash[i] = (self.hash[i - 1] * self.base \\\n                            + charToInt(s[i])) % self.mod\n            self.power[i] = (self.power[i - 1] * self.base)\\\n                                                % self.mod\n    # get hash of substring s[l...r] in O(1)\n    def getSubHash(self, l, r):\n        h = self.hash[r]\n        if l > 0:\n            h = (h - self.hash[l - 1] * self.power[r - l + 1]) % self.mod\n            if h < 0:\n                h += self.mod\n        return h\n# Rabin-Karp search using hash class\ndef searchPattern(text, pattern):\n    n, m = len(text), len(pattern)\n    textHash = RabinKarpHash(text)\n    patHash = RabinKarpHash(pattern)\n    patternHash = patHash.getSubHash(0, m - 1)\n    result = []\n    for i in range(n - m + 1):\n        subHash = textHash.getSubHash(i, i + m - 1)\n        if subHash == patternHash:\n            result.append(i)\n    return result\nif __name__ == \"__main__\":\n    txt = \"geeksforgeeks\"\n    pat = \"geek\"\n    positions = searchPattern(txt, pat)\n    print(*positions)",
    "code_without_comments": "class RabinKarpHash:\n    def __init__(self, s):\n        self.mod = 10**9 + 7\n        self.base = 31\n        n = len(s)\n        self.hash = [0] * n\n        self.power = [0] * n\n\n        # ('a' = 1, ..., 'z' = 26)\n        def charToInt(c):\n            return ord(c) - ord('a') + 1\n        self.hash[0] = charToInt(s[0])\n        self.power[0] = 1\n        for i in range(1, n):\n            self.hash[i] = (self.hash[i - 1] * self.base \\\n                            + charToInt(s[i])) % self.mod\n            self.power[i] = (self.power[i - 1] * self.base)\\\n                                                % self.mod\n\n    def getSubHash(self, l, r):\n        h = self.hash[r]\n        if l > 0:\n            h = (h - self.hash[l - 1] * self.power[r - l + 1]) % self.mod\n            if h < 0:\n                h += self.mod\n        return h\n\ndef searchPattern(text, pattern):\n    n, m = len(text), len(pattern)\n    textHash = RabinKarpHash(text)\n    patHash = RabinKarpHash(pattern)\n    patternHash = patHash.getSubHash(0, m - 1)\n    result = []\n    for i in range(n - m + 1):\n        subHash = textHash.getSubHash(i, i + m - 1)\n        if subHash == patternHash:\n            result.append(i)\n    return result\nif __name__ == \"__main__\":\n    txt = \"geeksforgeeks\"\n    pat = \"geek\"\n    positions = searchPattern(txt, pat)\n    print(*positions)",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/rabin-karp-algorithm-for-pattern-searching/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\nclass RabinKarpHash {\nprivate:\n    const int mod1 = 1e9 + 7;\n    const int mod2 = 1e9 + 9;\n    const int base1 = 31;\n    const int base2 = 37;\n    vector<int> hash1, hash2;\n    vector<int> power1, power2;\n    // modular addition\n    int add(int a, int b, int mod) {\n        a += b;\n        if (a >= mod) a -= mod;\n        return a;\n    }\n    // modular subtraction\n    int sub(int a, int b, int mod) {\n        a -= b;\n        if (a < 0) a += mod;\n        return a;\n    }\n    // modular multiplication\n    int mul(int a, int b, int mod) {\n        return (int)((1LL * a * b) % mod);\n    }\n    // convert character to int\n    int charToInt(char c) {\n        return c - 'a' + 1;\n    }\npublic:\n    // constructor: precomputes both prefix hashes and powers\n    RabinKarpDoubleHash(string &s) {\n        int n = s.size();\n        hash1.resize(n);\n        hash2.resize(n);\n        power1.resize(n);\n        power2.resize(n);\n        hash1[0] = charToInt(s[0]);\n        hash2[0] = charToInt(s[0]);\n        power1[0] = 1;\n        power2[0] = 1;\n        for (int i = 1; i < n; ++i) {\n            hash1[i] = add(mul(hash1[i - 1], base1, mod1),\n                                            charToInt(s[i]), mod1);\n            power1[i] = mul(power1[i - 1], base1, mod1);\n            hash2[i] = add(mul(hash2[i - 1], base2, mod2),\n                                            charToInt(s[i]), mod2);\n            power2[i] = mul(power2[i - 1], base2, mod2);\n        }\n    }\n    // get double hash of substring s[l...r]\n    vector<int> getSubHash(int l, int r) {\n        int h1 = hash1[r];\n        int h2 = hash2[r];\n        if (l > 0) {\n            h1 = sub(h1, mul(hash1[l - 1], power1[r - l + 1], mod1), mod1);\n            h2 = sub(h2, mul(hash2[l - 1], power2[r - l + 1], mod2), mod2);\n        }\n        return {h1, h2};\n    }\n};",
    "code_without_comments": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\nclass RabinKarpHash {\nprivate:\n    const int mod1 = 1e9 + 7;\n    const int mod2 = 1e9 + 9;\n    const int base1 = 31;\n    const int base2 = 37;\n    vector<int> hash1, hash2;\n    vector<int> power1, power2;\n\n    int add(int a, int b, int mod) {\n        a += b;\n        if (a >= mod) a -= mod;\n        return a;\n    }\n\n    int sub(int a, int b, int mod) {\n        a -= b;\n        if (a < 0) a += mod;\n        return a;\n    }\n\n    int mul(int a, int b, int mod) {\n        return (int)((1LL * a * b) % mod);\n    }\n\n    int charToInt(char c) {\n        return c - 'a' + 1;\n    }\npublic:\n\n    RabinKarpDoubleHash(string &s) {\n        int n = s.size();\n        hash1.resize(n);\n        hash2.resize(n);\n        power1.resize(n);\n        power2.resize(n);\n        hash1[0] = charToInt(s[0]);\n        hash2[0] = charToInt(s[0]);\n        power1[0] = 1;\n        power2[0] = 1;\n        for (int i = 1; i < n; ++i) {\n            hash1[i] = add(mul(hash1[i - 1], base1, mod1),\n                                            charToInt(s[i]), mod1);\n            power1[i] = mul(power1[i - 1], base1, mod1);\n            hash2[i] = add(mul(hash2[i - 1], base2, mod2),\n                                            charToInt(s[i]), mod2);\n            power2[i] = mul(power2[i - 1], base2, mod2);\n        }\n    }\n\n    vector<int> getSubHash(int l, int r) {\n        int h1 = hash1[r];\n        int h2 = hash2[r];\n        if (l > 0) {\n            h1 = sub(h1, mul(hash1[l - 1], power1[r - l + 1], mod1), mod1);\n            h2 = sub(h2, mul(hash2[l - 1], power2[r - l + 1], mod2), mod2);\n        }\n        return {h1, h2};\n    }\n};",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/rabin-karp-algorithm-for-pattern-searching/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nvector<int> zFunction(string s) {\n    int n = s.length();\n    vector<int> z(n);\n    int l = 0, r = 0;\n    for (int i = 1; i < n; i++) {\n        if (i <= r) {\n            int k = i - l;\n            // Case 2: reuse the previously computed value\n            z[i] = min(r - i + 1, z[k]);\n        }\n        // Try to extend the Z-box beyond r\n        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {\n            z[i]++;\n        }\n        // Update the [l, r] window if extended\n        if (i + z[i] - 1 > r) {\n            l = i;\n            r = i + z[i] - 1;\n        }\n    }\n    return z;\n}\nint main(){\n    string s = \"aabxaab\";\n    vector<int> z = zFunction(s);\n    for(int i=0; i < z.size(); ++i){\n        cout<<z[i]<<\" \";\n    }\n}",
    "code_without_comments": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nvector<int> zFunction(string s) {\n    int n = s.length();\n    vector<int> z(n);\n    int l = 0, r = 0;\n    for (int i = 1; i < n; i++) {\n        if (i <= r) {\n            int k = i - l;\n\n            z[i] = min(r - i + 1, z[k]);\n        }\n\n        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {\n            z[i]++;\n        }\n\n        if (i + z[i] - 1 > r) {\n            l = i;\n            r = i + z[i] - 1;\n        }\n    }\n    return z;\n}\nint main(){\n    string s = \"aabxaab\";\n    vector<int> z = zFunction(s);\n    for(int i=0; i < z.size(); ++i){\n        cout<<z[i]<<\" \";\n    }\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/z-algorithm-linear-time-pattern-searching-algorithm/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def zFunction(s):\n    n = len(s)\n    z = [0] * n\n    l, r = 0, 0\n    for i in range(1, n):\n        if i <= r:\n            k = i - l\n            # Case 2: reuse the previously computed value\n            z[i] = min(r - i + 1, z[k])\n        # Try to extend the Z-box beyond r\n        while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n            z[i] += 1\n        # Update the [l, r] window if extended\n        if i + z[i] - 1 > r:\n            l = i\n            r = i + z[i] - 1\n    return z\nif __name__ == \"__main__\":\n    z = zFunction(\"aabxaab\")\n    print(\" \".join(map(str, z)))",
    "code_without_comments": "def zFunction(s):\n    n = len(s)\n    z = [0] * n\n    l, r = 0, 0\n    for i in range(1, n):\n        if i <= r:\n            k = i - l\n\n            z[i] = min(r - i + 1, z[k])\n\n        while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n            z[i] += 1\n\n        if i + z[i] - 1 > r:\n            l = i\n            r = i + z[i] - 1\n    return z\nif __name__ == \"__main__\":\n    z = zFunction(\"aabxaab\")\n    print(\" \".join(map(str, z)))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/z-algorithm-linear-time-pattern-searching-algorithm/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\n// Z-function to compute Z-array\nvector<int> zFunction(string &s) {\n    int n = s.length();\n    vector<int> z(n);\n    int l = 0, r = 0;\n    for (int i = 1; i < n; i++) {\n        if (i <= r) {\n            int k = i - l;\n            // Case 2: reuse the previously computed value\n            z[i] = min(r - i + 1, z[k]);\n        }\n        // Try to extend the Z-box beyond r\n        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {\n            z[i]++;\n        }\n        // Update the [l, r] window if extended\n        if (i + z[i] - 1 > r) {\n            l = i;\n            r = i + z[i] - 1;\n        }\n    }\n    return z;\n}\n// Function to find all occurrences of pattern in text\nvector<int> search(string &text, string &pattern) {\n    string s = pattern + '$' + text;\n    vector<int> z = zFunction(s);\n    vector<int> pos;\n    int m = pattern.size();\n    for (int i = m + 1; i < z.size(); i++) {\n        if (z[i] == m){\n            // pattern match starts here in text\n            pos.push_back(i - m - 1);\n        }\n    }\n    return pos;\n}\nint main() {\n    string text = \"aabxaabxaa\";\n    string pattern = \"aab\";\n    vector<int> matches = search(text, pattern);\n    for (int pos : matches)\n        cout << pos << \" \";\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> zFunction(string &s) {\n    int n = s.length();\n    vector<int> z(n);\n    int l = 0, r = 0;\n    for (int i = 1; i < n; i++) {\n        if (i <= r) {\n            int k = i - l;\n\n            z[i] = min(r - i + 1, z[k]);\n        }\n\n        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {\n            z[i]++;\n        }\n\n        if (i + z[i] - 1 > r) {\n            l = i;\n            r = i + z[i] - 1;\n        }\n    }\n    return z;\n}\n\nvector<int> search(string &text, string &pattern) {\n    string s = pattern + '$' + text;\n    vector<int> z = zFunction(s);\n    vector<int> pos;\n    int m = pattern.size();\n    for (int i = m + 1; i < z.size(); i++) {\n        if (z[i] == m){\n\n            pos.push_back(i - m - 1);\n        }\n    }\n    return pos;\n}\nint main() {\n    string text = \"aabxaabxaa\";\n    string pattern = \"aab\";\n    vector<int> matches = search(text, pattern);\n    for (int pos : matches)\n        cout << pos << \" \";\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/z-algorithm-linear-time-pattern-searching-algorithm/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def zFunction(s):\n    n = len(s)\n    z = [0] * n\n    l, r = 0, 0\n    for i in range(1, n):\n        if i <= r:\n            k = i - l\n            # Case 2: reuse the previously computed value\n            z[i] = min(r - i + 1, z[k])\n        # Try to extend the Z-box beyond r\n        while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n            z[i] += 1\n        # Update the [l, r] window if extended\n        if i + z[i] - 1 > r:\n            l = i\n            r = i + z[i] - 1\n    return z\ndef search(text, pattern):\n    s = pattern + '$' + text\n    z = zFunction(s)\n    pos = []\n    m = len(pattern)\n    for i in range(m + 1, len(z)):\n        if z[i] == m:\n            # pattern match starts here in text\n            pos.append(i - m - 1)\n    return pos\nif __name__ == '__main__':\n    text = 'aabxaabxaa'\n    pattern = 'aab'\n    matches = search(text, pattern)\n    for pos in matches:\n        print(pos, end=' ')",
    "code_without_comments": "def zFunction(s):\n    n = len(s)\n    z = [0] * n\n    l, r = 0, 0\n    for i in range(1, n):\n        if i <= r:\n            k = i - l\n\n            z[i] = min(r - i + 1, z[k])\n\n        while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n            z[i] += 1\n\n        if i + z[i] - 1 > r:\n            l = i\n            r = i + z[i] - 1\n    return z\ndef search(text, pattern):\n    s = pattern + '$' + text\n    z = zFunction(s)\n    pos = []\n    m = len(pattern)\n    for i in range(m + 1, len(z)):\n        if z[i] == m:\n\n            pos.append(i - m - 1)\n    return pos\nif __name__ == '__main__':\n    text = 'aabxaabxaa'\n    pattern = 'aab'\n    matches = search(text, pattern)\n    for pos in matches:\n        print(pos, end=' ')",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/z-algorithm-linear-time-pattern-searching-algorithm/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    string s = \"Hello World\";\n    // Creating a temporary reversed string\n  \t// and assigning it to the s\n    s = string(s.rbegin(), s.rend());\n  \tcout << s;\n    return 0;\n}",
    "code_without_comments": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    string s = \"Hello World\";\n\n\n    s = string(s.rbegin(), s.rend());\n  \tcout << s;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/reverse-a-string-in-c-cpp-different-methods/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    string s = \"Hello World\";\n    stack<char> st;\n    // Push each character of string into stack\n    for (char c : s)\n        st.push(c);\n    // Clear the string\n    s.clear();\n    // Pop characters from stack and add them to\n    // reversed string\n    while (!st.empty()) {\n        s.push_back(st.top());\n        st.pop();\n    }\n    cout << s;\n    return 0;\n}",
    "code_without_comments": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    string s = \"Hello World\";\n    stack<char> st;\n\n    for (char c : s)\n        st.push(c);\n\n    s.clear();\n\n\n    while (!st.empty()) {\n        s.push_back(st.top());\n        st.pop();\n    }\n    cout << s;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/reverse-a-string-in-c-cpp-different-methods/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    string s = \"Hello World\";\n    // Initialize two pointers: left at start\n    //  and right at the end of the string\n    int l = 0;\n    int r = s.length() - 1;\n    // Loop until the two pointers meet in the middle\n    while (l < r) {\n        // Swap characters at position left and right\n        swap(s[l], s[r]);\n        // Move the left pointer to right\n        l++;\n        // Move the right pointer to left\n        r--;\n    }\n    cout << s;\n    return 0;\n}",
    "code_without_comments": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    string s = \"Hello World\";\n\n\n    int l = 0;\n    int r = s.length() - 1;\n\n    while (l < r) {\n\n        swap(s[l], s[r]);\n\n        l++;\n\n        r--;\n    }\n    cout << s;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/reverse-a-string-in-c-cpp-different-methods/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <bits/stdc++.h>\nusing namespace std;\n// Function to reverse the string using recursion\nvoid revStr(string &s, int l, int r) {\n    // Base case: When left and right pointer meet\n    if (l >= r)\n        return;\n    // Swap characters at left and right\n    swap(s[l], s[r]);\n    // Recursive call to reverse remaining substring\n    revStr(s, l + 1, r - 1);\n}\nint main() {\n    string s = \"Hello World\";\n    // Call the recursive function to reverse string\n    revStr(s, 0, s.length() - 1);\n    cout << s;\n    return 0;\n}",
    "code_without_comments": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid revStr(string &s, int l, int r) {\n\n    if (l >= r)\n        return;\n\n    swap(s[l], s[r]);\n\n    revStr(s, l + 1, r - 1);\n}\nint main() {\n    string s = \"Hello World\";\n\n    revStr(s, 0, s.length() - 1);\n    cout << s;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/reverse-a-string-in-c-cpp-different-methods/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <algorithm>\n#include <iostream>\nusing namespace std;\nbool areAnagrams(string &s1, string &s2) {\n    if (s1.length() != s2.length())\n        return false;\n    // Sort both strings\n    sort(s1.begin(), s1.end());\n    sort(s2.begin(), s2.end());\n    // Compare sorted strings\n    return (s1 == s2);\n}\nint main() {\n    string s1 = \"geeks\";\n    string s2 = \"kseeg\";\n\tif(areAnagrams(s1, s2)){\n\t    cout << \"true\" << endl;\n\t}\n\telse{\n\t    cout << \"false\" << endl;\n\t}\n    return 0;\n}",
    "code_without_comments": "#include <algorithm>\n#include <iostream>\nusing namespace std;\nbool areAnagrams(string &s1, string &s2) {\n    if (s1.length() != s2.length())\n        return false;\n\n    sort(s1.begin(), s1.end());\n    sort(s2.begin(), s2.end());\n\n    return (s1 == s2);\n}\nint main() {\n    string s1 = \"geeks\";\n    string s2 = \"kseeg\";\n\tif(areAnagrams(s1, s2)){\n\t    cout << \"true\" << endl;\n\t}\n\telse{\n\t    cout << \"false\" << endl;\n\t}\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/check-whether-two-strings-are-anagram-of-each-other/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <stdio.h>\n#include <string.h>\n// For using bool type\n#include <stdbool.h>\n// Function to compare two characters\n// (used for sorting)\nint compare(const void *a, const void *b) {\n    return (*(char *)a - *(char *)b);\n}\n// Function to check if two strings\n// are anagrams\nbool areAnagrams(char *s1, char *s2) {\n    if (strlen(s1) != strlen(s2)) return false;\n    // Sort both strings\n    qsort(s1, strlen(s1), sizeof(char), compare);\n    qsort(s2, strlen(s2), sizeof(char), compare);\n    // Compare sorted strings\n    return strcmp(s1, s2) == 0;\n}\nint main() {\n    char s1[] = \"geeks\";\n    char s2[] = \"kseeg\";\n    if (areAnagrams(s1, s2)) {\n        printf(\"true\\n\");\n    } else {\n        printf(\"false\\n\");\n    }\n    return 0;\n}",
    "code_without_comments": "#include <stdio.h>\n#include <string.h>\n\n#include <stdbool.h>\n\n\nint compare(const void *a, const void *b) {\n    return (*(char *)a - *(char *)b);\n}\n\n\nbool areAnagrams(char *s1, char *s2) {\n    if (strlen(s1) != strlen(s2)) return false;\n\n    qsort(s1, strlen(s1), sizeof(char), compare);\n    qsort(s2, strlen(s2), sizeof(char), compare);\n\n    return strcmp(s1, s2) == 0;\n}\nint main() {\n    char s1[] = \"geeks\";\n    char s2[] = \"kseeg\";\n    if (areAnagrams(s1, s2)) {\n        printf(\"true\\n\");\n    } else {\n        printf(\"false\\n\");\n    }\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/check-whether-two-strings-are-anagram-of-each-other/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def areAnagrams(s1, s2):\n    if len(s1) != len(s2):\n        return False\n    # Sort both strings\n    s1 = sorted(s1)\n    s2 = sorted(s2)\n    # Compare sorted strings\n    return s1 == s2\nif __name__ == \"__main__\":\n    s1 = \"geeks\"\n    s2 = \"kseeg\"\n    if(areAnagrams(s1,s2)):\n        print(\"true\")\n    else:\n        print(\"false\")",
    "code_without_comments": "def areAnagrams(s1, s2):\n    if len(s1) != len(s2):\n        return False\n\n    s1 = sorted(s1)\n    s2 = sorted(s2)\n\n    return s1 == s2\nif __name__ == \"__main__\":\n    s1 = \"geeks\"\n    s2 = \"kseeg\"\n    if(areAnagrams(s1,s2)):\n        print(\"true\")\n    else:\n        print(\"false\")",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/check-whether-two-strings-are-anagram-of-each-other/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\nbool areAnagrams(string &s1, string &s2) {\n    if(s1.size() != s2.size()){\n        return false;\n    }\n    // create a hashmap to store\n    // character frequencies\n    unordered_map<char, int> charCount;\n    // count frequency of each\n    // character in string s1\n    for(char ch: s1)\n    \tcharCount[ch] += 1;\n    // Count frequency of each\n    // character in string s2\n    for(char ch: s2)\n    \tcharCount[ch] -= 1;\n    // check if all frequencies are zero\n    for (auto& pair : charCount) {\n        if (pair.second != 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    string s1 = \"geeks\";\n    string s2 = \"kseeg\";\n\tif(areAnagrams(s1, s2)){\n\t    cout << \"true\";\n\t}\n\telse{\n\t    cout << \"false\";\n\t}\n    return 0;\n}",
    "code_without_comments": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\nbool areAnagrams(string &s1, string &s2) {\n    if(s1.size() != s2.size()){\n        return false;\n    }\n\n\n    unordered_map<char, int> charCount;\n\n\n    for(char ch: s1)\n    \tcharCount[ch] += 1;\n\n\n    for(char ch: s2)\n    \tcharCount[ch] -= 1;\n\n    for (auto& pair : charCount) {\n        if (pair.second != 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    string s1 = \"geeks\";\n    string s2 = \"kseeg\";\n\tif(areAnagrams(s1, s2)){\n\t    cout << \"true\";\n\t}\n\telse{\n\t    cout << \"false\";\n\t}\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/check-whether-two-strings-are-anagram-of-each-other/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def areAnagrams(s1, s2):\n    if len(s1) != len(s2):\n        return False\n    # create a hashmap to store\n    # character frequencies\n    charCount = {}\n    # count frequency of each\n    # character in string s1\n    for ch in s1:\n        charCount[ch] = charCount.get(ch, 0) + 1\n    # count frequency of each\n    # character in string s2\n    for ch in s2:\n        charCount[ch] = charCount.get(ch, 0) - 1\n    # check if all frequencies are zero\n    for value in charCount.values():\n        if value != 0:\n            return False\n    return True\nif __name__ == \"__main__\":\n    s1 = \"geeks\"\n    s2 = \"kseeg\"\n    if areAnagrams(s1, s2):\n        print(\"true\")\n    else:\n        print(\"false\")",
    "code_without_comments": "def areAnagrams(s1, s2):\n    if len(s1) != len(s2):\n        return False\n\n\n    charCount = {}\n\n\n    for ch in s1:\n        charCount[ch] = charCount.get(ch, 0) + 1\n\n\n    for ch in s2:\n        charCount[ch] = charCount.get(ch, 0) - 1\n\n    for value in charCount.values():\n        if value != 0:\n            return False\n    return True\nif __name__ == \"__main__\":\n    s1 = \"geeks\"\n    s2 = \"kseeg\"\n    if areAnagrams(s1, s2):\n        print(\"true\")\n    else:\n        print(\"false\")",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/check-whether-two-strings-are-anagram-of-each-other/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nbool areAnagrams(string &s1, string &s2) {\n    if (s1.length() != s2.length()) return false;\n    // for lowercase a-z\n    vector<int> freq(26, 0);\n    // Count frequency of each character in s1\n    for(char ch : s1)\n        freq[ch - 'a']++;\n    // Subtract frequency using characters from s2\n    for(char ch : s2)\n        freq[ch - 'a']--;\n    // If any count is not zero, not an anagram\n    for(int count : freq) {\n        if (count != 0)\n            return false;\n    }\n    return true;\n}\nint main() {\n    string s1 = \"geeks\";\n    string s2 = \"kseeg\";\n    if (areAnagrams(s1, s2))\n        cout << \"true\" << endl;\n    else\n        cout << \"false\" << endl;\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\n#include <vector>\nusing namespace std;\nbool areAnagrams(string &s1, string &s2) {\n    if (s1.length() != s2.length()) return false;\n\n    vector<int> freq(26, 0);\n\n    for(char ch : s1)\n        freq[ch - 'a']++;\n\n    for(char ch : s2)\n        freq[ch - 'a']--;\n\n    for(int count : freq) {\n        if (count != 0)\n            return false;\n    }\n    return true;\n}\nint main() {\n    string s1 = \"geeks\";\n    string s2 = \"kseeg\";\n    if (areAnagrams(s1, s2))\n        cout << \"true\" << endl;\n    else\n        cout << \"false\" << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/check-whether-two-strings-are-anagram-of-each-other/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\nbool areAnagrams(char *s1, char *s2) {\n    if (strlen(s1) != strlen(s2)) return false;\n    // for lowercase a-z\n    int freq[26] = {0};\n    // Count frequency of each character in s1\n    for (int i = 0; s1[i] != '\\0'; i++)\n        freq[s1[i] - 'a']++;\n    // Subtract frequency using characters from s2\n    for (int i = 0; s2[i] != '\\0'; i++)\n        freq[s2[i] - 'a']--;\n    // Check if all frequencies are zero\n    for (int i = 0; i < 26; i++) {\n        if (freq[i] != 0)\n            return false;\n    }\n    return true;\n}\nint main() {\n    char s1[] = \"geeks\";\n    char s2[] = \"kseeg\";\n    if (areAnagrams(s1, s2))\n        printf(\"true\\n\");\n    else\n        printf(\"false\\n\");\n    return 0;\n}",
    "code_without_comments": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\nbool areAnagrams(char *s1, char *s2) {\n    if (strlen(s1) != strlen(s2)) return false;\n\n    int freq[26] = {0};\n\n    for (int i = 0; s1[i] != '\\0'; i++)\n        freq[s1[i] - 'a']++;\n\n    for (int i = 0; s2[i] != '\\0'; i++)\n        freq[s2[i] - 'a']--;\n\n    for (int i = 0; i < 26; i++) {\n        if (freq[i] != 0)\n            return false;\n    }\n    return true;\n}\nint main() {\n    char s1[] = \"geeks\";\n    char s2[] = \"kseeg\";\n    if (areAnagrams(s1, s2))\n        printf(\"true\\n\");\n    else\n        printf(\"false\\n\");\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/check-whether-two-strings-are-anagram-of-each-other/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "def areAnagrams(s1, s2):\n    if len(s1) != len(s2):\n        return False\n    # for lowercase a-z\n    freq = [0] * 26\n    # Count frequency of each character in s1\n    for ch in s1:\n        freq[ord(ch) - ord('a')] += 1\n    # Subtract frequency using characters from s2\n    for ch in s2:\n        freq[ord(ch) - ord('a')] -= 1\n    # Check if all frequencies are zero\n    for count in freq:\n        if count != 0:\n            return False\n    return True\nif __name__ == \"__main__\":\n    s1 = \"geeks\"\n    s2 = \"kseeg\"\n    if areAnagrams(s1, s2):\n        print(\"true\")\n    else:\n        print(\"false\")",
    "code_without_comments": "def areAnagrams(s1, s2):\n    if len(s1) != len(s2):\n        return False\n\n    freq = [0] * 26\n\n    for ch in s1:\n        freq[ord(ch) - ord('a')] += 1\n\n    for ch in s2:\n        freq[ord(ch) - ord('a')] -= 1\n\n    for count in freq:\n        if count != 0:\n            return False\n    return True\nif __name__ == \"__main__\":\n    s1 = \"geeks\"\n    s2 = \"kseeg\"\n    if areAnagrams(s1, s2):\n        print(\"true\")\n    else:\n        print(\"false\")",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/check-whether-two-strings-are-anagram-of-each-other/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "#include <iostream>\nusing namespace std;\n// function to check if a substring\n// s[low..high] is a palindrome\nbool checkPal(string &s, int low, int high) {\n    while (low < high) {\n        if (s[low] != s[high])\n            return false;\n        low++;\n        high--;\n    }\n    return true;\n}\n// function to find the longest palindrome substring\nstring getLongestPal(string& s) {\n    int n = s.size();\n    // all substrings of length 1 are palindromes\n    int maxLen = 1, start = 0;\n    // nested loop to mark start and end index\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            // check if the current substring is\n            // a palindrome\n            if (checkPal(s, i, j) && (j - i + 1) > maxLen) {\n                start = i;\n                maxLen = j - i + 1;\n            }\n        }\n    }\n    return s.substr(start, maxLen);\n}\nint main() {\n    string s = \"forgeeksskeegfor\";\n    cout << getLongestPal(s) << endl;\n    return 0;\n}",
    "code_without_comments": "#include <iostream>\nusing namespace std;\n\n\nbool checkPal(string &s, int low, int high) {\n    while (low < high) {\n        if (s[low] != s[high])\n            return false;\n        low++;\n        high--;\n    }\n    return true;\n}\n\nstring getLongestPal(string& s) {\n    int n = s.size();\n\n    int maxLen = 1, start = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n\n\n            if (checkPal(s, i, j) && (j - i + 1) > maxLen) {\n                start = i;\n                maxLen = j - i + 1;\n            }\n        }\n    }\n    return s.substr(start, maxLen);\n}\nint main() {\n    string s = \"forgeeksskeegfor\";\n    cout << getLongestPal(s) << endl;\n    return 0;\n}",
    "has_comments": true,
    "language": "cpp",
    "source_url": "https://www.geeksforgeeks.org/longest-palindrome-substring-set-1/",
    "complexity_weight": 1.0
  },
  {
    "code_with_comments": "# function to check if a substring\n# s[low..high] is a palindrome\ndef checkPal(str, low, high):\n    while low < high:\n        if str[low] != str[high]:\n            return False\n        low += 1\n        high -= 1\n    return True\n# function to find the longest palindrome substring\ndef getLongestPal(s):\n    n = len(s)\n    # all substrings of length 1 are palindromes\n    maxLen = 1\n    start = 0\n    # nested loop to mark start and end index\n    for i in range(n):\n        for j in range(i, n):\n            # check if the current substring is\n            # a palindrome\n            if checkPal(s, i, j) and (j - i + 1) > maxLen:\n                start = i\n                maxLen = j - i + 1\n    return s[start:start + maxLen]\nif __name__ == \"__main__\":\n    s = \"forgeeksskeegfor\"\n    print(getLongestPal(s))",
    "code_without_comments": "\n\ndef checkPal(str, low, high):\n    while low < high:\n        if str[low] != str[high]:\n            return False\n        low += 1\n        high -= 1\n    return True\n\ndef getLongestPal(s):\n    n = len(s)\n\n    maxLen = 1\n    start = 0\n\n    for i in range(n):\n        for j in range(i, n):\n\n\n            if checkPal(s, i, j) and (j - i + 1) > maxLen:\n                start = i\n                maxLen = j - i + 1\n    return s[start:start + maxLen]\nif __name__ == \"__main__\":\n    s = \"forgeeksskeegfor\"\n    print(getLongestPal(s))",
    "has_comments": true,
    "language": "python",
    "source_url": "https://www.geeksforgeeks.org/longest-palindrome-substring-set-1/",
    "complexity_weight": 1.0
  }
]